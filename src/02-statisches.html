<!-- =========================== -->
<!-- VERSION MIT STATISCHEM HTML -->
<!-- =========================== -->
<section data-chapter data-title="Version mit statischem HTML"></section>

<!-- ‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì -->
<!-- Das Grundger√ºst entsteht -->
<!-- ‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì -->
<section data-title="Das Grundger√ºst entsteht">
    <p class="git-commit">
        Git Commit:
        <a href="https://github.com/DennisSchulmeister/dhbwka-wwi-webprog-my-songbook/tree/5b40260b1c7855ec8ec12d97666b4837f004927d" target="_blank">5b40260</a>
    </p>

    <p>
        Bis hierhin sieht unsere App irgendwie noch so gar nicht wie eine App
        aus. Sondern mehr wie eine normale Webseite. Schlimmer noch: Wie ein
        ganz banales ‚ÄûHallo, Welt!‚Äù. An dieser Stelle wollen wir daher das
        Grundlayout der App erstellen, so dass das wir hinterher folgendes
        Ergebnis sehen:
    </p>
    <figure>
        <img src="02/grundstruktur/layout-fertig.jpg" class="border" />
        <figcaption>Das Layout der App, wenn wir hier fertig sind</figcaption>
    </figure>
    <p>
        Der angezeigte Inhalt ist nat√ºrlich nur ein Platzhalter und wird √ºberhaupt
        noch nicht in irgend einer Weise dynamisch erzeugt. Wir k√∂nnen ihn deshalb
        einfach direkt in die HTML-Seite schreiben, damit wir beim Erstellen der
        Stylesheets schon etwas sehen.
        Entferne nun also das <span class="cmd">&lt;h1&gt;</span> aus der
        <span class="fn">src/index.html</span> und ersetze es durch folgenden
        Code. Alle anderen Zeilen bleiben unver√§ndert.
    </p>
    <pre data-gobble>
        <code class="html" data-gobble>
            &lt;!-- ========================= --&gt;
            &lt;!-- Grundger√ºst der Anwendung --&gt;
            &lt;!-- ========================= --&gt;
            &lt;section id="app"&gt;
                &lt;!-- Topbar --&gt;
                &lt;header&gt;
                    &lt;!-- Obere Zeile (fester Inhalt) --&gt;
                    &lt;div class="top left"&gt;
                        &lt;div class="item inactive"&gt;
                            &lt;b&gt;
                                Beispiel einer Browser App: My Songbook
                            &lt;/b&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                    &lt;div class="top right"&gt;
                        &lt;div class="item"&gt;
                            &lt;a href="https://github.com/DennisSchulmeister/dhbwka-wwi-webprog-my-songbook" target="_blank"&gt;GitHub&lt;/a&gt;
                        &lt;/div&gt;
                        &lt;div class="item"&gt;
                            &lt;a href="https://www.wpvs.de/browser-app/" target="_blank"&gt;Programmieranleitung&lt;/a&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;

                    &lt;!-- Untere Zeile (dynamisch je nach View) --&gt;
                    &lt;div class="bottom left"&gt;
                        &lt;div class="item"&gt;
                            Song hinzuf√ºgen
                        &lt;/div&gt;
                        &lt;div class="item"&gt;
                            Sortierung nach Titel
                        &lt;/div&gt;
                    &lt;/div&gt;
                    &lt;div class="bottom right"&gt;
                        &lt;input placeholder="Suchen" /&gt;
                    &lt;/div&gt;
                &lt;/header&gt;

                &lt;!-- Hauptbereich (dynamisch je nach View) --&gt;
                &lt;main&gt;
                    &lt;div class="padding"&gt;
                        Under Construction
                    &lt;/div&gt;
                &lt;/main&gt;
            &lt;/section&gt;
        </code>
    </pre>
    <p>
        Denkt man sich den Dummy-Inhalt weg, l√§sst sich daran auch schon folgender Aufbau
        der Seite erkennen:
    </p>
    <pre data-gobble>
        <code class="html" data-gobble>
            &lt;section id="app"&gt;
                &lt;header&gt;
                    &lt;!-- Obere Zeile (fester Inhalt) --&gt;
                    &lt;div class="top left"&gt;
                        ‚Ä¶ Inhalt in allen Views identisch ‚Ä¶
                    &lt;/div&gt;
                    &lt;div class="top right"&gt;
                        ‚Ä¶ Inhalt in allen Views identisch ‚Ä¶
                    &lt;/div&gt;

                    &lt;!-- Untere Zeile (dynamisch je nach View) --&gt;
                    &lt;div class="bottom left"&gt;
                        ‚Ä¶ Inhalt je nach View ‚Ä¶
                    &lt;/div&gt;
                    &lt;div class="bottom right"&gt;
                        ‚Ä¶ Inhalt je nach View ‚Ä¶
                    &lt;/div&gt;
                &lt;/header&gt;

                &lt;!-- Hauptbereich (dynamisch je nach View) --&gt;
                &lt;main&gt;
                    ‚Ä¶ Inhalt je nach View ‚Ä¶
                &lt;/main&gt;
            &lt;/section&gt;
        </code>
    </pre>
    <p>
        Diese Inhalte m√ºssen wir nun mit den zuvor angelegten Stylesheets in Form bringen,
        da die eingebauten Layoutregeln des Browsers nat√ºrlich nicht wie von Geisterhand
        das obige Bild herbeizaubern werden. Doch zuvor musst du dir von GitHub folgende
        drei Bilder herunterladen:
    </p>
    <ul>
        <li>
            <a href="https://raw.githubusercontent.com/DennisSchulmeister/dhbwka-wwi-webprog-my-songbook/master/src/favicon.svg" target="_blank">src/favicon.svg</a>: Icon der App
        </li>
        <li>
            <a href="https://raw.githubusercontent.com/DennisSchulmeister/dhbwka-wwi-webprog-my-songbook/master/src/background.jpg" target="_blank">src/background.jpg</a>: Hintergrundbild auf gro√üen Bildschirmen
        </li>
        <li>
            <a href="https://raw.githubusercontent.com/DennisSchulmeister/dhbwka-wwi-webprog-my-songbook/master/src/construction.jpg" target="_blank">src/construction.jpg</a>: Platzhalter im Hauptbereich der App
        </li>
    </ul>
    <p>
        Anschlie√üend lege eine neue Datei namens <span class="fn">src/theme.css</span> und
        folgendem Inhalt an. Sie enth√§lt h√§ufig ben√∂tigte
        <a href="https://www.w3schools.com/css/css3_variables.asp" target="_blank">CSS-Variablen</a>,
        die wir an anderer Stelle immer wieder ben√∂tigen werden:
    </p>
    <pre data-gobble>
        <code class="css" data-gobble>
            html {
                --font-color:                     black;
                --highlight-background-color:     rgba(235, 235, 235, 1.0);

                --header-normal-background-color: rgba(017,111,159, 1.0);
                --header-normal-font-color:       rgba(255,255,255, 0.8);
                --header-active-background-color: rgba(255,255,255, 0.2);
                --header-active-font-color:       rgba(255,255,255, 0.9);
            }
        </code>
    </pre>
    <p>
        Damit haben wir erst einmal alle Dateien beisammen. Die Verzeichnisstruktur sollte jetzt
        wie in der n√§chsten Abbildung aussehen:
    </p>
    <figure>
        <img src="02/grundstruktur/alle-dateien.png" />
        <figcaption>Verzeichnisstruktur der Webanwendung an dieser Stelle</figcaption>
    </figure>
    <p>
        Damit das neue Stylesheet wirksam wird, muss es erst noch importiert werden.
        √Ñndere deshalb den Import des alten Stylesheets in der <span class="fn">src/index.js</span>
        zu folgenden zwei Zeilen ab. Achte dabei aber darauf, wirklich erst die Datei
        <span class="fn">./index.css</span> und dann die Datei <span class="fn">./theme.css</span>
        zu importieren:
    </p>
    <pre data-gobble>
        <code class="js" data-gobble>
            import stylesheet from "./index.css";
            import theme from "./theme.css";
        </code>
    </pre>
    <p>
        Der Inhalt der Datei <span class="fn">src/index.css</span> √§ndert sich nun komplett
        zu folgenden Zeilen. Zun√§chst ein paar allgemeine Definitionen:
    </p>
    <pre data-gobble>
        <code class="css" data-gobble>
            /*
             * Dieses Stylesheet enth√§lt nur allgemeine Anweisungen, die sich auf die
             * gesamte App auswirken. Hier d√ºrfen keine √Ñnderungen vorgenommen werden,
             * die sich nur auf bestimmte Bereiche der Anwendung auswirken sollen.
             *
             * Damit @import funktioniert, muss die Anweisung vor allen anderen
             * CSS-Anweisungen stehen. Dieses Stylesheet muss daher auch vor allen
             * anderen importiert werden.
             */
            @import url('https://fonts.googleapis.com/css?family=Roboto');

            html, body {
                padding: 0;
                margin: 0;
                height: 100%;
            }

            body {
                font-family: 'Roboto', sans-serif;
                font-size: 11pt;
                line-height: 1.6;
                color: var(--font-color);
            }
        </code>
    </pre>

    <p>
        Dann ein paar Anpassungen der Schriftgr√∂√üe je nach Bildschirmaufl√∂sung:
    </p>
    <pre data-gobble>
        <code class="css" data-gobble>
            /*
             * Gr√∂√üere Schrift auf gr√∂√üeren Bildschirmen
             * Vgl. https://getbootstrap.com/docs/4.0/layout/overview/#responsive-breakpoints
             */
            @media screen and (min-width: 768px) {
                body,
                input {
                    font-size: 12pt;
                }
            }

            @media screen and (min-width: 992px) {
                body,
                input {
                    font-size: 13pt;
                }
            }

            @media screen and (min-width: 1200px) {
                body,
                input {
                    font-size: 14pt;
                }
            }
        </code>
    </pre>

    <p>
        Und zum Schluss wie immer ein Media Query, um auf gro√üen Bildschirmen
        die Darstellung zu optimieren, sowie ein paar n√ºtzliche Helferlein:
    </p>
    <pre data-gobble>
        <code class="css" data-gobble>
            /*
             * Fl√§chendeckender Seitenhintergrund auf gro√üen Bildschirmen
             */
            @media (min-width: 85em) {
                /* Hintergrundbild hinter dem Hauptbereich der App */
                html {
                    /* https://pixabay.com/de/computer-notebook-kaffee-820281/ */
                    background-image: url(background.jpg);
                    background-attachment: fixed;
                    background-size: cover;
                    background-position: center;
                }

                /* Hauptbereich der App vergr√∂√üern */
                body {
                    display: flex;
                    align-items: stretch;
                    justify-content: center;
                }

                body &gt; * {
                    flex: 1;
                }
            }

            /*
             * H√§ufig ben√∂tigte Hilfsklassen
             */
            .hidden {
                display: none;
            }

            .padding {
                padding: 0.5rem;
            }
        </code>
    </pre>

    <p>
        Wie du (hoffentlich) siehst, werden hier wirklich nur ganz allgemeine Dinge
        geregelt, die sich auf die gesamte App auswirken. Spezifische Anpassungen
        f√ºr einen einzelnen Bereich werden stattdessen in getrennten Stylesheets
        vorgenommen, wobei es im Grunde genommen je JavaScript-Datei eine gleichnamige
        CSS-Datei gibt. Die Datei
        <span class="fn">src/app.css</span> beginnt daher wie immer mit ein paar
        allgemeinen Definitionen:
    </p>
    <pre data-gobble>
        <code class="css" data-gobble>
            /*
             * Dieses Stylesheet darf nur Selektoren beinhalten, die mit #app beginnen.
             * Denn wir wollen nicht, dass hier Eigenschaften aus anderen Bereichen der
             * Anwendung √ºberschrieben werden.
             */
            #app {
                background-color: white;
                flex: 1;
            }
        </code>
    </pre>
    <p>
        Darauf folgt eine gro√üe Zahl an Regeln zur Gestaltung des Kopfbereichs.
        Auch sie fangen alle mit <span class="cmd">#app</span> an, um ihre G√ºltigkeit
        zu begrenzen:
    </p>
    <pre data-gobble>
        <code class="css" data-gobble>
            /*
             * Kopfbereich √ºber dem Inhalt
             */
            #app header {
                background-color: var(--header-normal-background-color);
                color: var(--header-normal-font-color);
            }

            #app header &gt; *,
            #app header input,
            #app header .item {
                display: block;
                box-sizing: border-box;
                width: 100%;
            }

            #app header &gt; .top {
                font-size: 80%;

                border: 0px solid var(--header-active-background-color);
                border-bottom-width: 1px;
            }

            #app header &gt; .top .item,
            #app header &gt; .top input {
                padding: 0.5rem;
            }

            #app header &gt; .bottom {
                border: 0px solid var(--header-active-background-color);
                border-bottom-width: 1px;
            }

            #app header &gt; .bottom .item,
            #app header &gt; .bottom input {
                padding: 1rem 0.5rem 1rem 0.5rem;
            }

            #app header .active,
            #app header .item:not(.inactive):hover {
                background-color: var(--header-active-background-color);
                color: var(--header-active-font-color);
            }

            #app header .item:not(.inactive) {
                cursor: pointer;
            }

            #app header a,
            #app header a:visited {
                color: var(--header-normal-font-color);
                text-decoration: none;
            }

            #app header a:hover {
                color: var(--header-active-font-color);
                text-decoration: underline;
            }

            #app header input {
                background: none;
                color: var(--header-normal-font-color);
                border: 0;
            }
        </code>
    </pre>

    <p>
        Dann wieder etwas tempor√§rer Inhalt, um das Baustellenbild beim Aufruf
        der App anzuzeigen üöß und einen kleinen Hinwestext in der Mitte zu
        platzieren:
    </p>
    <pre data-gobble>
        <code class="css" data-gobble>
            /*
             * Hauptinhalt
             */
            #app main {
                /*
                 * Tempor√§rer Inhalt, solange es noch keinen richtigen Inhalt gibt
                 * Bild: https://pixabay.com/de/handwerker-baustelle-arbeiter-3094035/
                 */
                background-image: url(construction.jpg);
                background-size: 100% auto;
                background-position: bottom center;
                background-repeat: no-repeat;

                color: rgb(255, 246, 23);
                text-shadow: 1px 1px 2px black;
                font-size: 300%;
                font-weight: bold;
                text-align: center;
            }
        </code>
    </pre>
    <p>
        Und zum Schlu√ü wie immer die Anpassung an gro√üe Bildschirme. Die Angabe
        <span class="cmd">(min-width: 85em)</span> in der f√ºnften Zeile muss
        dabei in Einklang mit dem Media Query in der <span class="fn">src/index.css</span>
        stehen, damit die Darstellung passt:
    </p>
    <pre data-gobble>
        <code class="css" data-gobble>
            /*
             * Anpassung an gro√üe Bildschirme, sobald in der index.css das gro√üe
             * Hintergrundbild eingeschaltet wird
             */
            @media screen and (min-width: 85em) {
                /* Rahmen um den Hauptbereich zeichnen */
                #app {
                    max-width: 80em;
                    margin-top: 2em;
                    margin-bottom: 2em;

                    border: 1px solid rgba(32,32,32, 0.2);
                    box-shadow: 1px 1px 3px rgba(0,0,0, 0.1);
                }

                /* Topbar- und Toolbar-Inhalte nebeneinander */
                #app header {
                    display: grid;
                    grid-template-columns: auto 20em;
                }

                #app header .top {
                    grid-row: 1;
                }

                #app header .bottom {
                    grid-row: 2;
                }

                #app header .left {
                    grid-column: 1;

                    display: flex;
                    justify-content: flex-start;
                }

                #app header .right{
                    grid-column: 2;

                    display: flex;
                    justify-content: flex-start;

                    background-color: var(--header-active-background-color);
                    color: var(--header-active-font-color);
                }

                #app header .item {
                    width: auto;
                }

                /* Nur den Bereich unterhalb der Toolbar scrollen */
                #app {
                    display: flex;
                    flex-direction: column;
                }

                #app &gt; main {
                    flex: 1;
                    overflow: auto;
                }
            }
        </code>
    </pre>
    <p>
        Und das war es dann auch schon. Zugegeben war das jetzt zwar viel Copy &amp; Paste.
        Auf dieser Grundlage k√∂nnen wir der App im n√§chsten Schritt nun aber ein wenig Leben einhauchen.
    </p>
</section>

<!-- ‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì -->
<!-- Navigation innerhalb der App -->
<!-- ‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì -->
<section data-title="Navigation innerhalb der App">
    <p class="git-commit">
        Git Commit:
        <a href="https://github.com/DennisSchulmeister/dhbwka-wwi-webprog-my-songbook/tree/11f39e316a354d0be004929e2db621a68fe69527" target="_blank">11f39e3</a>
    </p>

    <p>
        Rein visuell sieht unsere Seite jetzt schon viel mehr wie eine App aus. Man kann aber noch
        nichts anklicken, weshalb es sich im Grunde genommen immer noch um eine statische HTML-Seite
        handelt. An dieser Stelle wollen wir daher das Grundger√ºst etwas erweitern und eine einfache
        Navigation erm√∂glichen. Dadurch soll es m√∂glich sein, zwischen der √úbersichtsseite (die wir
        an dieser Stelle immer noch nicht mit Inhalt f√ºllen werden) und der sp√§teren Detailseite
        umzuschalten, so dass wir dann endg√ºltig von einer echten Browser App sprechen k√∂nnen. Denn
        im Gegensatz zu einer serverseitigen Webanwendung soll das hin und her Schalten zwischen den
        Seiten komplett im Browser geschehen, ohne hierf√ºr eine neue Seite vom Server anzufordern.
    </p>

    <h3>Umstrukturierung des HTML-Codes</h3>
    <p>
        Im ersten Schritt m√ºssen wir die Datei <span class="fn">src/index.html</span> so umbauen,
        dass jeder Bereich der App eine eigene <span class="cmd">&lt;section&gt;</span> bekommt,
        die wir √ºber eine eindeutige Id adressieren k√∂nnen. Allerdings sollen diese neuen Bereiche
        nicht sichtbar sein. Die CSS-Klasse <span class="cmd">hidden</span> stellt deshalb sicher,
        dass wirklich nur die erste <span class="cmd">&lt;section id="app"&gt;</span> mit dem
        Anwendungsrahmen und sonst nichts angezeigt wird.
    </p>
    <pre data-gobble>
        <code class="html" data-gobble>
            &lt;!DOCTYPE html&gt;
            &lt;html&gt;
                &lt;head&gt;
                    &lt;meta charset="utf-8" /&gt;
                    &lt;title&gt;My Songbook&lt;/title&gt;
                    &lt;link rel="shortcut icon" href="favicon.svg"&gt;

                    &lt;script src="index.js"&gt;&lt;/script&gt;
                &lt;/head&gt;
                &lt;body&gt;
                    &lt;!-- ========================= --&gt;
                    &lt;!-- Grundger√ºst der Anwendung --&gt;
                    &lt;!-- ========================= --&gt;
                    &lt;section id="app"&gt;
                        ‚Ä¶
                    &lt;/section&gt;

                    &lt;!-- ====================== --&gt;
                    &lt;!-- View: Vorhandene Songs --&gt;
                    &lt;!-- ====================== --&gt;
                    &lt;section id="song-overview" class="hidden"&gt;
                        ‚Ä¶
                    &lt;/section&gt;

                    &lt;!-- ================================== --&gt;
                    &lt;!-- View: Song anzeigen und bearbeiten --&gt;
                    &lt;!-- ================================== --&gt;
                    &lt;section id="song-display-edit" class="hidden"&gt;
                        ‚Ä¶
                    &lt;/section&gt;
                &lt;/body&gt;
            &lt;/html&gt;
        </code>
    </pre>
    <p>
        Anschlie√üend k√∂nnen wir den Dummy-Inhalt aus dem Grundger√ºst wieder entfernen, so dass
        davon nur folgende Zeilen √ºbrig bleiben. Den festen Inhalt der Topbar, der wirklich immer zu
        sehen sein soll, behalten wir hier nat√ºrlich bei. Ebenso alle anderen Zeilen der HTML-Datei.
    </p>
    <pre data-gobble>
        <code class="html" data-gobble>
            &lt;!-- ========================= --&gt;
            &lt;!-- Grundger√ºst der Anwendung --&gt;
            &lt;!-- ========================= --&gt;
            &lt;section id="app"&gt;
                &lt;!-- Topbar --&gt;
                &lt;header&gt;
                    &lt;!-- Obere Zeile (fester Inhalt) --&gt;
                    &lt;div class="top left"&gt;
                        &lt;div class="item inactive"&gt;
                            &lt;b&gt;
                                Beispiel einer Browser App: My Songbook
                            &lt;/b&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                    &lt;div class="top right"&gt;
                        &lt;div class="item"&gt;
                            &lt;a href="https://github.com/DennisSchulmeister/dhbwka-wwi-webprog-my-songbook" target="_blank"&gt;GitHub&lt;/a&gt;
                        &lt;/div&gt;
                        &lt;div class="item"&gt;
                            &lt;a href="https://www.wpvs.de/browser-app/" target="_blank"&gt;Programmieranleitung&lt;/a&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;

                    &lt;!-- Untere Zeile (dynamisch je nach View) --&gt;
                &lt;/header&gt;

                &lt;!-- Hauptbereich (dynamisch je nach View) --&gt;
                &lt;main&gt;
                &lt;/main&gt;
            &lt;/section&gt;
        </code>
    </pre>
    <p>
        Den eben entfernten HTML-Code bauen wir stattdessen weiter unten in die <span class="cmd">&lt;section&gt;</span>
        f√ºr die √úbersichtsseite wieder ein.¬π
    </p>
    <pre data-gobble>
        <code class="html" data-gobble>
            &lt;!-- ====================== --&gt;
            &lt;!-- View: Vorhandene Songs --&gt;
            &lt;!-- ====================== --&gt;
            &lt;section id="song-overview" class="hidden"&gt;
                &lt;!-- Topbar --&gt;
                &lt;header&gt;
                    &lt;div class="left"&gt;
                        &lt;div class="item new-song"&gt;
                            Song hinzuf√ºgen
                        &lt;/div&gt;
                        &lt;div class="item"&gt;
                            Sortierung nach Titel
                        &lt;/div&gt;
                    &lt;/div&gt;
                    &lt;div class="right"&gt;
                        &lt;input placeholder="Suchen" /&gt;
                    &lt;/div&gt;
                &lt;/header&gt;

                &lt;!-- Hauptbereich --&gt;
                &lt;main&gt;
                    &lt;div class="padding"&gt;
                        √úbersicht
                    &lt;/div&gt;
                &lt;/main&gt;
            &lt;/section&gt;
        </code>
    </pre>
    <p>
        ¬π
        <small>
            Die CSS-Klasse <span class="cmd">bottom</span> f√ºr die beiden <span class="cmd">&lt;div&gt;</span>
            in der Topbar haben wir hier absicshtlich weggelassen. Doch dazu sp√§ter mehr.
        </small>
    </p>
    <p>
        Und auch die Detailseite gestalten wir √§hnlich, da sie zu diesem Zeitpunkt nat√ºrlich auch noch keinen
        wirklichen Inhalt besitzt. Immerhin bekommt sie in der Topbar jedoch bereits einen Eintrag, mit dem der
        Anwender zur√ºck auf die √úbersichtsseite gelangen soll.
    </p>
    <pre data-gobble>
        <code class="html" data-gobble>
            &lt;!-- ================================== --&gt;
            &lt;!-- View: Song anzeigen und bearbeiten --&gt;
            &lt;!-- ================================== --&gt;
            &lt;section id="song-display-edit" class="hidden"&gt;
                &lt;!-- Topbar --&gt;
                &lt;header&gt;
                    &lt;div class="left"&gt;
                        &lt;!-- Leer --&gt;
                    &lt;/div&gt;
                    &lt;div class="right"&gt;
                        &lt;div class="item overview"&gt;
                            Zur√ºck zur √úbersicht
                        &lt;/div&gt;
                    &lt;/div&gt;
                &lt;/header&gt;

                &lt;!-- Hauptbereich --&gt;
                &lt;main&gt;
                    &lt;div class="padding"&gt;
                        Song anzeigen/bearbeiten
                    &lt;/div&gt;
                &lt;/main&gt;
            &lt;/section&gt;
        </code>
    </pre>

    <h3>Austausch der sichtbaren Inhalte mit JavaScript</h3>
    <p>
        Mit diesen √Ñnderungen nun an Ort und Stelle k√∂nnen wir uns an die Ausprogrammierung der
        <span class="cmd">App</span>-Klasse innerhalb der Datei <span class="fn">src/app.js</span>
        machen. Denn sie soll f√ºr die Navigation innerhalb der App zust√§ndig sein und zwischen den
        verschiedenen Ansichten umschalten. Die eigentliche Arbeit macht dabei die folgende, neue
        Methode, wobei der Unterstrich am Anfang des Namens ausdr√ºckt, dass sie nur innerhalb der
        Klasse selbst aufgerufen werden sollte. Erzwungen wird das von JavaScript allerdings nicht.
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            /**
             * Auswechseln des sichtbaren Inhalts der App. Hierf√ºr muss der Methode
             * ein Objekt mit folgendem Aufbau √ºbergeben werden:
             *
             *   {
                    className: "CSS-Klassenname",
             *      topbar: [DOM Element, DOM Element, DOM Element, ...],
             *      main: [DOM Element, DOM Element, DOM Element, ...],
             *   }
             *
             * Beide Attribute (topbar und main) sind optional, was dazu f√ºhrt, dass
             * im jeweiligen Bereich einfach nichts angezeigt wird. Werden sie jedoch
             * mitgegeben, m√ºssen sie mit forEach(element =&gt; { ‚Ä¶ }) iteriert werden
             * k√∂nnen, um ihren Inhalt in den DOM-Baum zu integrieren.
             *
             * Wichtig ist, dass die √ºbergebenen Elemente noch an keiner Stelle im
             * DOM vorhanden sein d√ºrfen. Werden die Elemente in der index.html
             * als Vorlage definiert, muss hier deshalb eine Kopie anstelle der
             * Elemente selbst √ºbergeben werden!
             *
             * @param {Object} content Objekt mit den anzuzeigenden DOM-Elementen
             */
            _switchVisibleContent(content) {
                // &lt;header&gt; und &lt;main&gt; des HTML-Grundger√ºsts ermitteln
                let app = document.querySelector("#app");
                let header = document.querySelector("#app &gt; header");
                let main = document.querySelector("#app &gt; main");

                // Zuvor angezeigte Inhalte entfernen
                // Bei der Topbar nur die untere Zeile, im Hauptbereich alles!
                app.className = "";
                header.querySelectorAll(".bottom").forEach(e =&gt; e.parentNode.removeChild(e));
                main.innerHTML = "";

                // CSS-Klasse √ºbernehmen, um die viewspezifischen CSS-Regeln zu aktivieren
                if (content && content.className) {
                    app.className = content.className;
                }

                // Neue Inhalte der Topbar einf√ºgen
                if (content && content.topbar) {
                    content.topbar.forEach(element =&gt; {
                        element.classList.add("bottom");
                        header.appendChild(element);
                    });
                }

                // Neue Inhalte des Hauptbereichs einf√ºgen
                if (content && content.main) {
                    content.main.forEach(element =&gt; {
                        main.appendChild(element);
                    });
                }
            }
        </code>
    </pre>
    <p>
        Der Quellcode ist im Grunde genommen nicht sehr kompliziert. Dennoch gehen wir ihn an dieser
        Stelle kurz durch, um sicherzustellen, dass du ihn auch wirklich verstehst:
    </p>
    <ol>
        <li>
            Zun√§chst greift die Methode auf das DOM zu, um sich die
            <span class="cmd">&lt;section id="app"&gt;</span> sowie die darin enthaltenen
            <span class="cmd">&lt;header&gt;</span>- und
            <span class="cmd">&lt;main&gt;</span>-Elemente zu besorgen.
        </li>
        <li>
            Anschlie√üend werden die zuvor sichtbaren Inhalte verworfen. Im Falle der
            Topbar mit einer <span class="cmd">forEach()</span>-Schleife, die nur
            die Elemente der unteren Zeile erwischt. Im Hauptbereich wird stattdessen
            das <span class="cmd">innerHTML</span>-Attribut √ºberschrieben, was
            seinen kompletten Inhalt l√∂scht.
        </li>
        <li>
            Dann wird mit einer <span class="cmd">if</span>-Abfrage gebpr√ºft, ob
            ob das <span class="cmd">content</span>-Objekt ein Attribut mit dem
            Namen <span class="cmd">classList</span> enth√§lt. Falls ja wird die
            CSS-Klasse des <span class="cmd">&lt;section id="app"&gt;</span>
            entsprechend abge√§ndert, damit etwaige CSS-Regeln, die sich auf
            diese Klasse beziehen, wirksam werden k√∂nnen.
        </li>
        <li>
            Danach wird gepr√ºft, ob ein neuer Inhalt f√ºr die Topbar √ºbergeben wurde.
            Falls ja, wird in einer Schleife jedem dieser Elemente die CSS-Klasse
            <span class="cmd">bottom</span> hinzugef√ºgt, um sie in der untere Zeile
            der Topbar zu verankern. Gleichzeitig werden sie an den
            <span class="cmd">&lt;header&gt;</span> innerhalb von
            <span class="cmd">&lt;section id="app"&gt;</span> angeh√§ngt.
        </li>
        <li>
            Dann erfolgt mit einer √§hnlichen Abfrage eine Pr√ºfung f√ºr den Hauptbereich
            der App, nur dass den Elementen hier keine zus√§tzliche CSS-Klasse mitgegeben
            werden muss.
        </li>
    </ol>

    <p>
        Mit dieser Methode k√∂nnen wir nun den angezeigten Inhalt der App variieren. Wirklich
        anwenderfreundlich ist sie aber noch nicht, da wir ihr, um eine neue View anzuzeigen,
        genau die hierf√ºr notwendigen DOM-Elemente mitgegeben m√ºssen. Besser w√§re es jedoch,
        wenn wir eine bestimmte View einfach aufrufen k√∂nnten, ohne genau zu wissen, wie sie
        letztlich aufgebaut ist. Wir ben√∂tigen daher f√ºr jede View eine weitere Methode, die
        genau diesen Zweck erf√ºllt. Doch hierf√ºr m√ºssen wir uns erst noch √ºberlegen, wie wir
        den restlichen Quellcode der App weiter strukturieren sollen.
    </p>

    <h3>Eine Klasse je Bildschirmseite</h3>
    <p>
        Nat√ºrlich k√∂nnten wir die komplette Anwendungslogik einfach in der Datei <span class="fn">src/app.js</span>
        und der Klasse <span class="cmd">App</span> ausprogrammieren. Dem Computer w√§re das ziemlich gleich.
        Allerdings wissen wir, dass die beiden Views mit der √úbersicht und zur Anzeige eines Songtexts nicht
        wirklich viel gemeinsam haben. Alles in eine Klasse zu packen w√§re daher ziemlich un√ºbersichtlich.
        Das alte Sprichwort ‚Äûteile und herrsche‚Äù liefert stattdessen viel bessere Ergebnisse, da es uns an die
        <a href="https://t3n.de/news/prinzipien-software-entwicklung-solid-615556/" target="_blank">SOLID-Kriterien</a>
        und hier insbesondere an das Single-Responsibility-Prinzip erinnert. Es liegt deshalb nahe, f√ºr
        jede Bildschirmseite eine eigene Klasse vorzusehen. Und f√ºr jede Klasse dementsprechend eine
        eigene JavaScript-Datei und ein eigenes Stylesheet, die wir, um die √úbersichtlichkeit noch
        weiter zu erh√∂hen, jeweils in ein eigenes Verzeichnis packen.
    </p>
    <p>
        Bevor wir also weiter programmieren, lege zun√§chst folgende Dateistruktur an. Die Dateien
        k√∂nnen dabei zun√§chst noch leer bleiben:
    </p>
    <ul>
        <li>
            <span class="fn">src/song-overview/song-overview.js:</span> Klasse <span class="cmd">SongOverview</span> f√ºr die √úbersichtsseite
        </li>
        <li>
            <span class="fn">src/song-overview/song-overview.css:</span> Stylesheet f√ºr die √úbersichtsseite
        </li>
        <li>
            <span class="fn">src/song-display-edit/song-display-edit.js:</span> Klasse <span class="cmd">SongDisplayEdit</span> f√ºr die Detailseite
        </li>
        <li>
            <span class="fn">src/song-display-edit/song-display-edit.css:</span> Stylesheet f√ºr die Detailseite
        </li>
    </ul>
    <p>
        Das Ergebnis sollte dann so aussehen:
    </p>
    <figure>
        <img src="02/navigation/neue-dateien.png" />
        <figcaption>Erweiterte Verzeichnisstruktur f√ºr die √úbersichts- und die Detailseite</figcaption>
    </figure>
    <p>
        Die beiden Stylesheets sind am einfachsten. Hier wollen wir zun√§chst nur etwas Dummy-Inhalt
        einbauen, damit wir sp√§ter sehen, ob sie auch wirklich ausgewertet werden. F√ºge daher in die
        Datei <span class="fn">src/song-overview/song-overview.css</span> folgende Zeile ein:
    </p>
    <pre data-gobble>
        <code class="css" data-gobble>
            /*
             * Dieses Stylesheet darf nur Selektoren beinhalten, die mit .song-overview
             * beginnen. Denn wir wollen nicht, dass hier Eigenschaften aus anderen Bereichen
             * der Anwendung √ºberschrieben werden.
             */
            .song-overview main {
                color: orangered !important;
            }
        </code>
    </pre>
    <p>
        In die <span class="fn">src/song-display-edit/song-display-edit.css</span> f√ºge folgende Zeilen:
    </p>
    <pre data-gobble>
        <code class="css" data-gobble>
            /*
             * Dieses Stylesheet darf nur Selektoren beinhalten, die mit .song-display-edit
             * beginnen. Denn wir wollen nicht, dass hier Eigenschaften aus anderen Bereichen
             * der Anwendung √ºberschrieben werden.
             */
            .song-display-edit main {
                color: orchid !important;
            }
        </code>
    </pre>
    <p>
        Bei den beiden Klassen wird es hingegen schon interessanter, da wir uns noch gar
        keine Gedanken dar√ºber gemacht haben, welche Methoden sie besitzen sollen und
        wann diesie aufgerufen werden. Letztlich gibt es auch gar keine universelle L√∂sung
        daf√ºr, in der Praxis hat sich aber ganz unabh√§ngig von der Art der Anwendung oder
        der verwendeten UI-Technologie folgende, grundlegende Struktur bew√§hrt:
    </p>
    <ol>
        <li>
            Jedes Mal, wenn eine View aufgerufen wird, wird ein neues Objekt der dazugeh√∂rigen
            Klasse erzeugt. Das Objekt bleibt dabei so lange aktiv, wie die View sichtbar ist.
        </li>
        <li>
            Wird von einer View auf dieselbe View nur mit anderen Daten gewechselt (zum Beispiel
            von der Detailseite eines Songs zur Detailseite eines anderen Songs), wird hierf√ºr
            ebenfalls ein neues Objekt erzeugt.
        </li>
        <li>
            Denn dies erm√∂glicht es, die Klassen einfach zu halten und die f√ºr die Ermittlung der
            anzuzeigenden Daten ben√∂tigten Informationen wie die Song-ID einfach dem Konstruktor
            zu √ºbergeben.
        </li>
        <li>
            Bevor eine neue View aufgerufen wird, wird die Methode <span class="cmd">onShow()</span>
            des jeweiligen Objekts aufgerufen.
        </li>
        <li>
            Davor wird jedoch erst die Methode <span class="cmd">onLeave()</span> der aktuell sichtbaren
            View aufgerufen, um ihr die M√∂glichkeit zu geben, Aufr√§umarbeiten durchzuf√ºhren oder den
            Seitenwechsel zu unterbinden.
        </li>
        <li>
            Eine Methode mit dem Namen <span class="cmd">getTitle()</span> gibt den Titel der aktuellen
            View zur√ºck, um ihn in der Titelzeile des Browserfensters anzuzeigen.
        </li>
        <li>
            Sobald eine View verlassen wurde, kann das dazugeh√∂rige Objekt abger√§umt werden.
        </li>
    </ol>
    <p>
        Damit haben wir einen klaren Lebenszyklus definiert, der genau vorschreibt, zu welchem Zeitpunkt
        neue Objekte entstehen, welche Methoden dementsprechend aufgerufen werden und wann die Objekte
        wieder verschwinden. Au√üerdem haben wir eine M√∂glichkeit geschaffen, besondere F√§lle wie das
        Vorliegen nicht gespeicherter Daten abzufangen, bei denen wir den Anwender erst fragen m√ºssen,
        ob er seine √Ñnderungen sichern will, oder wir den Aufruf der Folgeseite ganz einfach unterbinden.
    </p>
    <p>
        Die Datei <span class="fn">src/song-overview/song-overview.js</span> soll somit folgenden Inhalt besitzen:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            "use strict";

            import stylesheet from "./song-overview.css";

            /**
             * View mit der √úbersicht der vorhandenen Songs.
             */
            class SongOverview {
                /**
                 * Konstruktor.
                 * @param {Objekt} app Zentrales App-Objekt der Anwendung
                 */
                constructor(app) {
                    this._app = app;
                }

                /**
                 * Von der Klasse App aufgerufene Methode, um die Seite anzuzeigen. Die
                 * Methode gibt daher ein passendes Objekt zur√ºck, das an die Methode
                 * _switchVisibleContent() der Klasse App √ºbergeben werden kann, um ihr
                 * die darzustellenden DOM-Elemente mitzuteilen.
                 *
                 * @return {Object} Darzustellende DOM-Elemente gem√§√ü Beschreibung der
                 * Methode App._switchVisibleContent()
                 */
                onShow() {
                    // Machen wir gleich
                }

                /**
                 * Von der Klasse App aufgerufene Methode, um festzustellen, ob der Wechsel
                 * auf eine neue Seite erlaubt ist. Wird hier true zur√ºckgegeben, wird der
                 * Seitenwechsel ausgef√ºhrt.
                 *
                 * @param  {Function} goon Callback, um den Seitenwechsel zu einem sp√§teren
                 * Zeitpunkt fortzuf√ºhren, falls wir hier false zur√ºckgeben
                 * @return {Boolean} true, wenn der Seitenwechsel erlaubt ist, sonst false
                 */
                onLeave(goon) {
                    return true;
                }

                /**
                 * @return {String} Titel f√ºr die Titelzeile des Browsers
                 */
                get title() {
                    return "√úbersicht";
                }
            }

            export default SongOverview;
        </code>
    </pre>
    <p>
        Die Datei <span class="fn">src/song-display-edit/song-display-edit.js</span> soll hingegen
        folgenden Inhalt besitzen:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            "use strict";

            import stylesheet from "./song-display-edit.css";

            /**
             * View zur Anzeige oder zum Bearbeiten eines Songs.
             */
            class SongDisplayEdit {
                /**
                 * Konstruktor.
                 *
                 * @param {Objekt} app  Zentrales App-Objekt der Anwendung
                 * @param {String} id   ID des darzustellenden Songs
                 * @param {String} mode "new", "display" oder "edit"
                 */
                constructor(app, id, mode) {
                    this._app = app;
                    this._id = id;
                    this._mode = mode;
                }

                /**
                 * Von der Klasse App aufgerufene Methode, um die Seite anzuzeigen. Die
                 * Methode gibt daher ein passendes Objekt zur√ºck, das an die Methode
                 * _switchVisibleContent() der Klasse App √ºbergeben werden kann, um ihr
                 * die darzustellenden DOM-Elemente mitzuteilen.
                 *
                 * @return {Object} Darzustellende DOM-Elemente gem√§√ü Beschreibung der
                 * Methode App._switchVisibleContent()
                 */
                onShow() {
                    // Machen wir gleich
                }

                /**
                 * Von der Klasse App aufgerufene Methode, um festzustellen, ob der Wechsel
                 * auf eine neue Seite erlaubt ist. Wird hier true zur√ºckgegeben, wird der
                 * Seitenwechsel ausgef√ºhrt.
                 *
                 * @param  {Function} goon Callback, um den Seitenwechsel zu einem sp√§teren
                 * Zeitpunkt fortzuf√ºhren, falls wir hier false zur√ºckgeben
                 * @return {Boolean} true, wenn der Seitenwechsel erlaubt ist, sonst false
                 */
                onLeave(goon) {
                    return true;
                }

                /**
                 * @return {String} Titel f√ºr die Titelzeile des Browsers
                 */
                get title() {
                    switch (this._mode) {
                        case "new":
                            return "Song hinzuf√ºgen";
                        case "edit":
                            return "Song bearbeiten";
                        default:
                            return "Song anzeigen";
                    }
                }
            }

            export default SongDisplayEdit;
        </code>
    </pre>

    <h3>Weitere Methoden f√ºr die Klasse App</h3>
    <p>
        Da der Vertrag mit dem View-Klassen nun klar ist, besitzen wir alle Informationen, um die
        Klasse <span class="cmd">App</span> zu Ende zu programmieren. F√ºge deshalb √ºber der Methode
        <span class="cmd">_switchVisibleContent()</span> eine neue Methode mit dem Namen
        <span class="cmd">_switchVisibleView()</span> ein, die sie aufruft und hierf√ºr ein
        View-Objekt entgegen nimmt:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            /**
             * Hilfsklasse zum Umschalten auf eine neue Seite. Sie ruft zun√§chst die
             * Methode onLeave() der gerade sichtbaren View auf und pr√ºft damit, ob
             * die View verlassen werden kann. Falls ja ruft sie die Methode onShow()
             * der neuen View auf und √ºbergibt das Ergebnis an die eigene Methode
             * _switchVisibleContent(), um den sichtbaren Inhalt der Seite auszutauschen.
             *
             * @param  {Object} view View-Objekt mit einer onShow()-Methode
             * @return {Boolean} Flag, ob die neue Seite aufgerufen werden konnte
             */
            _switchVisibleView(view) {
                // Callback, mit dem die noch sichtbare View den Seitenwechsel zu einem
                // sp√§teren Zeitpunkt fortf√ºhren kann, wenn sie in der Methode onLeave()
                // false zur√ºckliefert. Dadurch erh√§lt sie die M√∂glichkeit, den Anwender
                // zum Beispiel zu fragen, ob er ungesicherte Daten speichern will,
                // bevor er die Seite verl√§sst.
                let goon = () =&gt; this._switchVisibleView(view);

                // Aktuelle View fragen, ob eine neue View aufgerufen werden darf
                if (this._currentView && !this._currentView.onLeave(goon)) {
                    return false;
                }

                // Alles klar, aktuelle View nun wechseln
                document.title = `${this._title} ‚Äì ${view.title}`;

                this._currentView = view;
                this._switchVisibleContent(view.onShow());
                return true;
            }

            /**
             * ‚Ä¶
             */
            _switchVisibleContent(content) {
                ‚Ä¶
            }
        </code>
    </pre>
    <p>
        Die zwei Instanzattribute <span class="cmd">this._currentView</span> und
        <span class="cmd">this._title</span> m√ºssen hierf√ºr noch im Konstruktor
        definiert werden:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            /**
             * Konstruktor.
             */
            constructor() {
                this._title = "My Songbook";
                this._currentView = null;
            }
        </code>
    </pre>
    <p>
        Und damit das Ganze einfach zu verwenden ist, legen wir nun f√ºr jede View eine
        eigene, f√ºr die √∂ffentliche Verwendung freigebene Methode an, mit der sie √ºberall
        in der App aufgerufen werden kann. Die Methode <span class="cmd">start()</span>
        passen wir bei der Gelegenheit dann auch gleich noch an, damit beim Aufruf der App
        immer die √úberssichtsseite geladen wird:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            ‚Ä¶
            import SongDisplayEdit from "./song-display-edit/song-display-edit.js";
            import SongOverview from "./song-overview/song-overview.js";

            /**
             * ‚Ä¶
             */
            class App {
                ‚Ä¶

                /**
                 * Ab hier beginnt die Anwendung zu laufen.
                 */
                start() {
                    this.showSongOverview();
                }

                /**
                 * Aufruf der √úbersichtsseite der vorhandenen Songs.
                 * @return {Boolean} Flag, ob die neue Seite aufgerufen werden konnte
                 */
                showSongOverview() {
                    let view = new SongOverview(this);
                    this._switchVisibleView(view);
                }

                /**
                 * Aufruf der Detailseite zur Anzeige oder zum Bearbeiten eines Songs.
                 *
                 * @param  {String} id Song-ID
                 * @param  {String} mode "new", "display" oder "edit"
                 * @return {Boolean} Flag, ob die neue Seite aufgerufen werden konnte
                 */
                showSongDisplayEdit(id, mode) {
                    let view = new SongDisplayEdit(this, id, mode);
                    this._switchVisibleView(view);
                }

                /**
                 * ‚Ä¶
                 */
                _switchVisibleView(view) {
                    ‚Ä¶
                }
            }
        </code>
    </pre>

    <h3>Ausprogrammieren der onShow()-Methoden</h3>
    <p>
        Eine winzige Kleinigkeit fehlt jetzt aber noch, bevor das Ganze auch wirklich funktioniert:
        Wir m√ºssen noch die Methode <span class="cmd">onShow()</span> unserer beiden View-Klassen
        ausprogrammieren. Denn noch √ºbergeben wir dem <span class="cmd">App</span>-Objekt keine
        DOM-Elemente zum Anzeigen und wir registrieren auch noch keine Event Handler, mit denen
        der Anwender zwischen den Seiten umherschalten k√∂nnte.
    </p>
    <p>
        √ñffne daher noch einmal die Datei <span class="fn">src/song-overview/song-overview.js</span>
        und ersetze die <span class="cmd">onShow()</span>-Methode durch die nun folgende Version:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            onShow() {
                // Anzuzeigende HTML-Elemente ermitteln
                let section = document.querySelector("#song-overview").cloneNode(true);

                let content = {
                    className: "song-overview",
                    topbar: section.querySelectorAll("header &gt; *"),
                    main: section.querySelectorAll("main &gt; *"),
                };

                // Event Handler registrieren
                let newSongItem = section.querySelector("header .item.new-song");

                newSongItem.addEventListener("click", () =&gt; {
                    this._app.showSongDisplayEdit("", "new");
                })

                // Ergebnis zur√ºckliefern
                return content;
            }
        </code>
    </pre>
    <p>
        In der Datei <span class="fn">src/song-display-edit/song-display-edit.js</span> ersetze
        die <span class="cmd">onShow()</span>-Methode durch folgende Version:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            onShow() {
                // Anzuzeigende HTML-Elemente ermitteln
                let section = document.querySelector("#song-display-edit").cloneNode(true);

                let content = {
                    className: "song-display-edit",
                    topbar: section.querySelectorAll("header &gt; *"),
                    main: section.querySelectorAll("main &gt; *"),
                };

                // Event Handler registrieren
                let overviewItem = section.querySelector("header .item.overview");

                overviewItem.addEventListener("click", () =&gt; {
                    this._app.showSongOverview();
                })

                // Ergebnis zur√ºckliefern
                return content;
            }
        </code>
    </pre>
    <p>
        Beide Methoden sind prinzipiell gleich aufgebaut. Um sie zu verstehen m√ºssen wir allerdings
        erst einen Bogen zur√ºck zum Anfang machen. Dort haben wir n√§mlich den HTML-Code der Datei
        <span class="fn">src/index.html</span> etwas umger√§umt und zwei
        <span class="cmd">&lt;section&gt;</span>-Elemente f√ºr die beiden Unterseiten angelegt.
        Auf diese Elemente greifen wir nun zu, um die anzuzeigenden HTML-Elemente aus dem Document
        Object Model auszulesen. Allerdings erzeugen wir durch Aufruf der Methode
        <span class="cmd">cloneNode(true)</span> eine tiefe Kopie der ausgelesenen Elemente, da der
        Kommentar vor der Methode <span class="cmd">App._switchVisibleContent()</span> eindeutig
        besagt, dass ihr keine Elemente √ºbergeben werden d√ºrfen, die sich bereits im DOM-Baum der
        HTML-Seite befinden.
    </p>
    <p>
        Mit diesen Elementen bauen wir dann das <span class="cmd">content</span>-Objekt auf, welches
        die Methode <span class="cmd">App._switchVisibleContent()</span> von uns erwartet. Daraufhin
        suchen wir uns in der Topbar jeweils ein Element, mit dem der Anwender zwischen den Seiten
        umschalten kann und registrieren einen Click-Event-Handler darauf. In der entsprechenden
        Handler-Funktion rufen wir daher die jeweils richtige <span class="cmd">show‚Ä¶()</span>-Methode
        des <span class="cmd">App</span>-Objekts auf, um die Seite tats√§chlich zu wechseln.
    </p>
    <p>
        Und am Ende geben wir die <span class="cmd">content</span>-Struktur zur√ºck, damit die Methode
        <span class="cmd">App._switchVisibleView()</span>, von der wir aufgerufen werden, sie an die
        Methode <span class="cmd">App._switchVisibleContent()</span> √ºbergeben kann.
    </p>
    <p>
        Wenn du alles richtig gemacht hast, solltest du nun zwischen den beiden Seiten umherschalten
        k√∂nnen. Dabei sollte dann auch aufgrund der unterschiedlichen Stylesheets die Schriftfarbe von
        orange auf lila wechseln, wie in der folgenden Animation dargestellt.
    </p>
    <figure>
        <img src="02/navigation/seiten-wechseln.gif" class="border"/>
        <figcaption>All der M√ºhen Lohn: Eine funktionierende Navigation innerhalb der App</figcaption>
    </figure>
</section>

<!-- ‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì -->
<!-- Integration des Single Page Routers -->
<!-- ‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì -->
<section data-title="Integration des Single Page Routers">
    <p class="git-commit">
        Git Commit:
        <a href="https://github.com/DennisSchulmeister/dhbwka-wwi-webprog-my-songbook/tree/f3c23b477cbe7bed0c182bbcc00526452f9a1f60" target="_blank">f3c23b4</a>
    </p>

    <p>
        Zugegeben, das war schon eine ganze Menge Code, der da eben zusammenpassen musste, bevor wir
        wirklich zwischen den beiden Seiten hin und her schalten konnten. Doch damit hast du nun eine
        vollst√§ndige Grundstruktur zur Verf√ºgung, die im Grunde genommen auf jede Art von Anwendung
        ausgerollt werden kann. Du musst nur die beiden Klassen f√ºr die Song√ºbersicht und die Songdetails
        durch eigene Klassen ersetzen. Ein paar Nachteile hat die bisherige L√∂sung aber noch, weshalb
        wir sie an dieser Stelle noch etwas verfeinern wollen:
    </p>
    <ul>
        <li>
            Die Views unserer App besitzen keine eindeutigen URLs und k√∂nnen daher nur per JavaScript
            aufgerufen werden. Dadurch kann eine View (zum Beispiel f√ºr einen bestimmten Song) nicht
            durch Eingabe der richtigen Adresse im Browser direkt aufgerufen werden.
        </li>
        <li>
            Auch k√∂nnen wir keine einfachen <span class="cmd">&lt;a&gt;</span>-Elemente innerhalb des
            HTML-Codes verwenden, um einen Link auf eine andere View zu platzieren. Wir m√ºssen immer
            Event-Handler-Funktionen schreiben und den Seitenwechsel mit JavaScript durchf√ºhren.
        </li>
        <li>
            Der Zur√ºck-Button des Browsers sowie ganz allgemein die Nutzung des Browserverlaufs
            wird nicht unterst√ºtzt.
        </li>
    </ul>
    <p>
        Die L√∂sung all dieser Probleme h√∂rt auf den Namen
        <a href="https://css-tricks.com/using-the-html5-history-api/" target="_blank">HTML5 History API</a>.
        Doch anstatt jetzt uns jetzt selbst damit herumzuschlagen (die Details richtig hinzubekommen ist
        tats√§chlich nicht ganz einfach), wollen wir auf eine Library zur√ºckgreifen, die das alles viel
        besser kann. Wir wollen einen ‚ÄûSingle Page Router‚Äù verwenden, der es uns ganz einfach erm√∂glicht,
        eine URL-Struktur f√ºr unsere App zu definieren und dabei festzulegen, was beim Aufruf welcher URL
        passieren soll. Den Grundstock daf√ºr haben wir bereits im letzten Teilkapitel gelegt. Jetzt geht
        es nur noch darum, die ganze Sache ein wenig zu optimieren.
    </p>

    <h3>Installation von Navigo</h3>
    <p>
        Die Library, die wir hier verwenden wollen, hei√üt <a href="https://github.com/krasimir/navigo" target="_blank">Navigo</a>.
        Sie implementiert einen einfachen Single Page Router, der im Gegensatz zu vielen √§hnlichen
        Bibliotheken ganz ohne fremde Abh√§ngigkeiten auskommt und daher in nahezu jede beliebige
        Webanwendung integriert werden kann. Und wie das
        <a href="https://github.com/krasimir/navigo/blob/master/README.md" target="_blank">README auf GitHub</a>
        andeutet, scheint sie relativ einfach nutzbar zu sein. Grund genug also mal wieder das gute alte
        Terminal anzuschmei√üen, mit einem beherzten <span class="cmd">cd "Verzeichnisname"</span> in unser
        Projektverzeichnis zu wechseln und die Library mit folgendem Befehl zu installieren:
    </p>
    <p class="cmd">
        npm add --save-dev navigo
    </p>
    <p>
        Die installation sollte dabei in gewohnter node.js-Manier schnell und ger√§uschlos √ºber die B√ºhne gehen.
    </p>
    <figure>
        <img src="02/spa-router/installation-navigo.jpg" />
        <figcaption>Installation des <span class="scr">navigo</span> Single Page Routers</figcaption>
    </figure>

    <h3>Anpassungen an der App-Klasse</h3>
    <p>
        Um den Single Page Router zu initialisieren m√ºssen wir ein paar kleinere Umbauten der
        <span class="cmd">App</span>-Klasse vornehmen. Allerdings nichts allzu dramatisches.
        Zun√§chst m√ºssen wir die Klasse <span class="cmd">Navigo</span> aus dem Modul
        <span class="fn">navigo/lib/navigo.js</span> importieren, was wir dank Parcel einfach
        tun k√∂nnen, ohne hierf√ºr auch nur eine Datei umkopieren zu m√ºssen. Beachte, dass der
        Pfad in der <span class="cmd">import</span>-Anweisung hierf√ºr <u>nicht</u> mit
        <span class="cmd">./</span> anfangen darf.
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            ‚Ä¶
            import Navigo from "navigo/lib/navigo.js";
            import SongDisplayEdit from "./song-display-edit/song-display-edit.js";
            import SongOverview from "./song-overview/song-overview.js";
            ‚Ä¶

            class App { ‚Ä¶ }
        </code>
    </pre>
    <p>
        Danach k√∂nnen wir den Konstruktor von <span class="cmd">App</span> wie folgt erweitern:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            constructor() {
                this._title = "My Songbook";
                this._currentView = null;

                // Single Page Router aufsetzen
                this._router = new Navigo();
                this._currentUrl = "";
                this._navAborted = false;

                this._router.on({
                    "*":                       () =&gt; this.showSongOverview(),
                    "/song/new/":              () =&gt; this.showSongDisplayEdit("", "new"),
                    "/song/display/:id/":  params =&gt; this.showSongDisplayEdit(params.id, "display"),
                    "/song/edit/:id/":     params =&gt; this.showSongDisplayEdit(params.id, "edit"),
                });

                this._router.hooks({
                    after: (params) =&gt; {
                        if (!this._navAborted) {
                            // Navigation durchf√ºhren, daher die neue URL merken
                            this._currentUrl = this._router.lastRouteResolved().url;
                        } else {
                            // Navigation abbrechen, daher die URL in der Adresszeile
                            // auf den alten Wert der bisherigen View zur√ºcksetzen
                            this._router.pause(true);
                            this._router.navigate(this._currentUrl);
                            this._router.pause(false);

                            this._navAborted = false;
                        }
                    }
                });
            }
        </code>
    </pre>
    <p>
        Das sieht jetzt erst einmal sehr komplex aus. Wichtig ist aber nur der Aufruf von
        <span class="cmd">this._router.on({‚Ä¶})</span>, der das Herzst√ºck dieser Anpassung
        darstellt. Alle anderen Zeilen, bis auf die Erzeugung des Router-Objekts selbst
        k√∂nnte man auch weglassen. Sie werden nur ben√∂tigt, weil wir die Navigation in
        bestimmten F√§llen unterbrechen wollen und wie Navigo hierf√ºr ein wenig zum Mitspielen
        √ºberreden m√ºssen.
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            this._router.on({
                "*":                       () =&gt; this.showSongOverview(),
                "/song/new/":              () =&gt; this.showSongDisplayEdit("", "new"),
                "/song/display/:id/":  params =&gt; this.showSongDisplayEdit(params.id, "display"),
                "/song/edit/:id/":     params =&gt; this.showSongDisplayEdit(params.id, "edit"),
            });
        </code>
    </pre>
    <p>
        Diese Zeilen definieren die URL-Struktur der App, wobei jedes URL-Pattern mit einer
        anonymen Lambda-Funktion (zu erkennen am Doppelpfeil <span class="cmd">=&gt;</span>)
        verkn√ºpft ist. Es liegt nahe, dass der Router die entsprechende Lambda-Funktionen
        aufruft, wenn eine URL erkannt wurde, um dadurch den sichtbaren Inhalt zu wechseln.
        Praktischerweise k√∂nnen wir hier unsere Methoden von vorhin direkt weiterverwenden.
    </p>
    <p>
        In der <span class="cmd">start()</span>-Methode m√ºssen wir nun nicht mehr explizit
        die √úbersichtsseite aufrufen. Stattdessen sagen wir dem Router, dass er nun daf√ºr
        verantwortlich ist, die URL, mit der die gesamte App gestartet wurde, auszuwerten,
        um die erste View zu ermitteln:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            start() {
                this._router.resolve();
            }
        </code>
    </pre>
    <p>
        Das sind eigentlich schon alle √Ñnderungen an der Klasse <span class="cmd">App</span>.
        Damit aber das Unterbrechen der Navigation richtig funktioniert, m√ºssen wir die
        Methode <span class="cmd">_switchVisibleView()</span> noch ein klein wenig modifizieren.
        Die neue Version lautet wie folgt:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            _switchVisibleView(view) {
                // Callback, mit dem die noch sichtbare View den Seitenwechsel zu einem
                // sp√§teren Zeitpunkt fortf√ºhren kann, wenn sie in der Methode onLeave()
                // false zur√ºckliefert. Dadurch erh√§lt sie die M√∂glichkeit, den Anwender
                // zum Beispiel zu fragen, ob er ungesicherte Daten speichern will,
                // bevor er die Seite verl√§sst.
                let newUrl = this._router.lastRouteResolved().url;
                let goon = () =&gt; {
                    // ?goon an die URL h√§ngen, weil der Router sonst nicht weiternavigiert
                    this._router.navigate(newUrl + "?goon");
                }

                // Aktuelle View fragen, ob eine neue View aufgerufen werden darf
                if (this._currentView && !this._currentView.onLeave(goon)) {
                    this._navAborted = true;
                    return false;
                }

                // Alles klar, aktuelle View nun wechseln
                document.title = `${this._title} ‚Äì ${view.title}`;

                this._currentView = view;
        </code>
    </pre>
    <p>
        Im Vergleich zur alten Version setzen wir hier noch ein Kennzeichen, wenn die
        Navigation durch die aktuell sichtbare View unterbunden wird, damit wir im weiter
        oben definieren ‚ÄûAfter Hook‚Äù von Navigo die Adresszeile des Browsers wieder auf
        die alte URL zur√ºcksetzen k√∂nnen. Au√üerdem m√ºssen wir die Callbackfunktion
        <span class="cmd">goon()</span> ein wenig anders implementieren.
    </p>
    <p>
        Zu guter Letzt kommen noch zwei weitere Zeilen ganz am Ende der
        <span class="cmd">_switchVisibleContent</span>-Methode hinzu, um
        die in einer View enthaltenen Links auf andere App-Seiten zu aktiveren.
        Die Links werden hierf√ºr am zus√§tzlichen HTML-Attribut <span class="cmd">data-navigo</span>
        erkannt (siehe weiter unten in der <span class="fn">src/index.html</span>):
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            _switchVisibleContent(content) {
                ‚Ä¶
                // Navigo an die Links in der View binden
                this._router.updatePageLinks();
            }
        </code>
    </pre>

    <h3>Vereinfachung der restlichen Quellcodes</h3>
    <p>
        Undank sei der Welten Lohn, sagt man. Nicht jedoch an dieser Stelle. Zwar ist
        die Klasse <span class="cmd">App</span> durch die neuerlichen √Ñnderungen nochmal
        ein klein wenig komplexer geworden, daf√ºr vereinfachen sich aber alle anderen
        Quellcodes. Und wir haben eine ordentliche URL-Struktur, mit der wir jede View der
        App √ºber eine eigene URL direkt aufrufen oder als Lesezeichen im Browser speichern
        k√∂nnen (sofern der Webserver richtig konfiguriert wurde). Und der Zur√ºck-Button des
        Browsers tut nun auch das, was er soll.
    </p>
    <p>
        Zun√§chst einmal wollen wir die <span class="cmd">onShow()</span>-Methode der beiden
        View-Klassen etwas aufr√§umen. Hier fallen die Event Handler komplett weg, so dass die
        Methoden nun nur noch so aussehen:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            // src/song-overview/song-overview.js:
            onShow() {
                let section = document.querySelector("#song-overview").cloneNode(true);

                return {
                    className: "song-overview",
                    topbar: section.querySelectorAll("header &gt; *"),
                    main: section.querySelectorAll("main &gt; *"),
                };
            }
        </code>
    </pre>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            // src/song-display-edit/song-display-edit.js:
            onShow() {
                let section = document.querySelector("#song-display-edit").cloneNode(true);

                return {
                    className: "song-display-edit",
                    topbar: section.querySelectorAll("header &gt; *"),
                    main: section.querySelectorAll("main &gt; *"),
                };
            }
        </code>
    </pre>
    <p>
        Wir k√∂nnen tats√§chlich die H√§lfte des Quellcodes einfach wegschmei√üen! Und da wir zum
        Umschalten zwischen den Views nun kein explizites JavaScript mehr ben√∂tigen, k√∂nnen wir
        die <span class="fn">src/index.html</span> jetzt auch so anpassen, dass hierf√ºr einfache
        Links verwendet werden. Die Definitionen innerhalb der Topbar √§ndern sich dadurch wie folgt:
    </p>
    <pre data-gobble>
        <code class="html" data-gobble>
            &lt;div class="item"&gt;
                &lt;a href="/song/new/" data-navigo&gt;
                    Song hinzuf√ºgen
                &lt;/a&gt;
            &lt;/div&gt;

            ‚Ä¶

            &lt;div class="item"&gt;
                &lt;a href="/" data-navigo&gt;
                    Zur√ºck zur √úbersicht
                &lt;/a&gt;
            &lt;/div&gt;
        </code>
    </pre>
    <p>
        Wenn es gut l√§uft, sollte das Ergebnis nun wie folgt aussehen. Beachte dabei, wie sich
        die URL in der Adresszeile des Browsers automatisch √§ndert:
    </p>
    <figure>
        <img src="02/spa-router/seiten-wechseln.gif" class="border"/>
        <figcaption>Navigation innerhalb der App mit Hilfe des Single Page Routers</figcaption>
    </figure>

    <h3>Hinweis zum Parcel-Entwicklungsserver</h3>
    <p>
        Leider vertr√§gt sich das Prinzip eines Single Page Routers nicht immer 100%ig mit dem
        Hot Module Replacement (automatisches Nachladen der Seite bei einer Quellcode√§nderung)
        des Parcel-Entwicklungsservers. Deshalb kann es nach einer √Ñnderung am Quellcode passieren,
        dass die Seite zwar neul√§dt, in der Adresszeile des Browsers aber noch eine alte URL steht.
        In diesem Fall entferne am Besten alle Bestandteile nach der Port-Nummer der URL und lade
        die Seite erneut. Dadurch kannst du Navigo und Parcel wieder in Einklang bringen. In der
        Produktivversion der App kann das nicht passieren, da es hier ein automatisches Neuladen
        der Seite ja nicht gibt. Allerdings muss der Webserver dort so konfiguriert werden, dass
        er immer den Inhalt der Datei <span class="fn">index.html</span> zur√ºckliefert, wenn auf
        einen unbekannten Pfad zugegriffen wird.
    </p>
</section>

<!-- ‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì -->
<!-- Definition des Datenmodells -->
<!-- ‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì -->
<section data-title="Definition des Datenmodells">
    <p class="git-commit">
        Git Commit:
        <a href="https://github.com/DennisSchulmeister/dhbwka-wwi-webprog-my-songbook/tree/50d6ceb20b42415f71e8461bf2d59b8681792969" target="_blank">50d6ceb</a>
    </p>

    <h3>Welche M√∂glichkeiten kommen in Frage?</h3>
    <p>
        W√ºrden wir eine serverseitige Webanwendung anstelle einer Browser App schreiben, w√§re die
        Frage, wie die Daten der Anwendung gespeichert werden sollen, ganz einfach zu beantworten.
        Sehr wahrscheinlich k√∂nnten wir die Daten einfach in einer relationalen Datenbank ablegen,
        deren Integration das Webframework unserer Wahl f√ºr uns regelt. Oder wir k√∂nnten auf eine
        der vielen NoSQL-Datenbanken zugreifen, die als Alternative zu den klassischen SQL-Datenbanken
        angeboten werden. Innerhalb einer reinen Browser App ohne Backend-Sever haben wir diese
        M√∂glichkeiten nicht. Doch auch hier m√ºssen wir auf eine komfortable Datenhaltung nicht
        verzichten, sondern k√∂nnen zwischen den folgenden Alternativen w√§hlen:
    </p>
    <ul>
        <li>
            Wir k√∂nnten eine Cloud-Datenbank wie
            <a href="https://firebase.google.com/" target="_blank">Google Firebase</a> nutzen.
        </li>
        <li>
            Wir k√∂nnten einen Datenbankserver mit HTTP-Schnittstelle wie
            <a href="http://couchdb.apache.org/" target="_blank">Apache CouchDB</a>
            via AJAX aufrufen.
        </li>
        <li>
            Wir k√∂nnten mit der
            <a href="https://www.tutorialspoint.com/html5/html5_indexeddb.htm" target="_blank">IndexDB API</a>
            von HTML5 die Daten im Browser speichern.
        </li>
        <li>
            Wir k√∂nnten eine Bibliothek wie <a href="http://dexie.org" target="_blank">Dexie</a> nutzen,
            die einfacher als IndexDB funktioniert.
        </li>
    </ul>
    <p>
        Man kann hier nicht sagen, welche L√∂sung besser als die andere ist, da sie alle f√ºr
        bestimmte Anwendungen sinnvoll sein k√∂nnen. IndexDB ist dabei jedoch die aufw√§ndigste
        L√∂sung, da die API sehr umfangreich und im Vergleich auch umst√§ndlicher zu nutzen ist.
        Die anderen Alternativen sind einfacher zu durchschauen und deshalb auch mit weniger
        Aufwand verbunden.
    </p>
    <p>
        In unserer Beispielanwendung haben wir uns aufgrund folgender Vorteile f√ºr
        Dexie entschieden:
    </p>
    <ul>
        <li>
            Die Bibliothek kann rein browserseitig ohne einen Datenbankserver im Hintergrund
            genutzt werden.
        </li>
        <li>
            Die API ist einfach aufgebaut und auf der Projektwebseite gut dokumentiert.
        </li>
        <li>
            Die API bietet nahezu alle Funktionen, die man von einer SQL-Datenbank
            gewohnt ist.
        </li>
        <li>
            Das Datenmodell kann versioniert werden, so dass es in sp√§teren Anwendungsversionen
            ohne Datenverlust weiterentwickelt werden kann.
        </li>
    </ul>

    <h3>Installation von Dexie</h3>
    <p>
        Wie immer l√§sst sich Dexie mit <span class="cmd">npm</span> ganz einfach installieren.
        Allerdings m√ºssen wir dieses Mal noch ein weiteres Paket installieren:
    </p>
    <p class="cmd">
        cd "Projektverzeichnis" <br />
        npm add --save-dev dexie <br />
        npm add --save-dev babel-plugin-transform-runtime
    </p>
    <figure>
        <img src="02/db/dexie-installation.png" />
        <figcaption>
            Installation von <span class="scr">dexie</span>
        </figcaption>
    </figure>
    <p>
        Anschlie√üend musst du im Projektverzeichnis der App eine Datei mit dem Namen
        <span class="fn">.babelrc</span> anlegen. Sie muss folgenden Inhalt besitzen,
        damit die von Dexie zur√ºckgelieferten, asynchronen
        <a href="https://scotch.io/tutorials/javascript-promises-for-dummies" target="_blank">Promise-Objekte</a>
        auch mit Parcel funktionieren:¬π
    </p>
    <pre data-gobble>
        <code class="json" data-gobble>
            {
                "presets": [
                    ["env", {
                        "targets": {
                            "browsers": ["last 1 Chrome version"]
                        }
                    }]
                ]
            }
        </code>
    </pre>
    <p>
        ¬π
        <small>
            Wir arbeiten dadurch um eine Art Bug in Parcel herum. Daf√ºr wird auch das Paket
            <span class="scr">babel-plugin-transform-runtime </span> ben√∂tigt.
        </small>
    </p>
    <p>
        Dadurch stehen dir dann folgende M√∂glichkeiten in JavaScript zur Verf√ºgung:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            // Dexie-Klasse importieren
            import Dexie from "dexie/dist/dexie.js";

            // Neue Datenbank mit zwei Tabellen definieren
            // ++id definiert ein automatisch hochgez√§hltes Schl√ºsselfeld.
            // Es m√ºssen nur Felder angegeben werden, f√ºr die ein Index ben√∂tigt wird.
            let database = new Dexie("My-Songbook");

            database.version(1).stores({
                users: "++id, username",
                songtexts: "++id, artist, title",
            });

            // Neuen Datensatz anlegen
            database.songtexts.add({
                artist: "Queen",
                title:  "I Want To Break Free",
                format: "html",
                data:   "‚Ä¶ HTML-String ‚Ä¶",
            });

            // Vorhandenen Datensatz aktualisieren
            database.songtexts.put({
                id:     4711,
                artist: "Joe Cocker",
                title:  "I Come In Peace",
                format: "html",
                data:   "‚Ä¶ HTML-String ‚Ä¶",
            });

            // Vorhandenen Datensatz einlesen
            let song = await database.songtexts.get(815);

            // Vorhandenen Datensatz l√∂schen
            database.songtexts.delete(721);

            // Alle vorhandenen Datens√§tze l√∂schen
            database.songtexts.clear();

            // Vorhandene Eintr√§ge anhand einer Filter-Funktion durchsuchen
            // (als Alternative zu den eingebauten WHERE-Bedinungen von Dexie)
            // und das Ergebnis als Array zur√ºckliefern
            let songs = await database.songtexts
                .filter(entry =&gt; entry.artist.toLowerCase().search("queen") &gt;= 0)
                .toArray();
        </code>
    </pre>
    <p>
        Dar√ºber hinaus bietet Dexie noch einiges mehr, was wir in der Besipielanwendung
        allerdings nicht ben√∂tigen. Weitere Informationen bietet die
        <a href="http://dexie.org/docs/API-Reference">API-Beschreibung</a> auf der Webseite.
    </p>

    <h3>Kapselung der der Datenbankzugriffe</h3>
    <p>
        Aus Gr√ºnden der √úbersichtlichkeit wollen wir auch hier das Single-Responsibility-Prinzip
        anwenden und alle Datenbankzugriffe in einer eigenen Klasse kapseln, anstatt sie √ºber den
        gesamten Quellcode zu verteilen. Zwar ist die Dexie-API an und f√ºr sich bereits relativ
        einfach, wir k√∂nnen dadurch den Quellcode aber noch √ºbersichtlicher machen und uns auch
        ein St√ºck weit von der API abschirmen, so dass wir sie im Zweifellsfall sp√§ter relativ
        einfach ersetzen k√∂nnten. Lege daher eine neue Datei mit dem Namen
        <span class="fn">src/database.js</span> und folgendem Inhalt an:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
        "use strict";

        import Dexie from "dexie/dist/dexie.js";

        // Datenbankdefinition:
        //
        //   * ++id = Automatisch Hochgez√§hlter Datenbankschl√ºssel
        //   * artist, title = Indexfelder f√ºr WHERE-Abfragen und die Sortierung
        //   * Alle anderen Felder m√ºssen nicht deklariert werden!
        //   * Vgl. http://dexie.org/docs/API-Reference
        let database = new Dexie("My-Songbook");

        database.version(1).stores({
            songtexts: "++id, artist, title",
        });

        /**
         * Datenbankzugriffsklasse f√ºr Songtexte. Diese Klasse bietet verschiedene
         * Methoden, um Songtexte zu speichern und wieder auszulesen. Im Hintergrund
         * wird hierf√ºr Dexie zur lokalen Speicherung im Browser genutzt.
         */
        class Songtexts {
        }

        export default
            database,
            Songtexts,
        };
        </code>
    </pre>
    <p>
        Diese Klasse wollen wir nun nach und nach um alle ben√∂tigten Methoden erweitern.
        Zun√§chst um eine Funktion zum Speichern neuer Songtexte:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            /**
             * Einen neuen Songtext speichern oder einen vorhandenen Songtext
             * aktualisieren. Das Songtext-Objekt sollte hierf√ºr folgenden Aufbau
             * besitzen:
             *
             * {
             *     artist: "Name des K√ºnstlers",
             *     title: "Name des Songs",
             *     format: "html",
             *     data: "HTML-String",
             * }
             *
             * @param  {Object}  songtext Zu speichernder Songtext
             * @return {Promise} Asynchrones Promise-Objekt
             */
            async saveNew(songtext) {
                return database.songtexts.add(songtext);
            }
        </code>
    </pre>
    <p>
        Dann um eine Funktion zum erneuten Speichern eines vorhandenen Songtexts:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            /**
             * Bereits vorhandenen Songtext aktualisieren.
             * @param  {Object}  songtext Zu speichernder Songtext
             * @return {Promise} Asynchrones Promise-Objekt
             */
            async update(songtext) {
                return database.songtexts.put(songtext);
            }
        </code>
    </pre>
    <p>
        Dann um zwei Funktionen zum L√∂schen von Songtexten:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            /**
             * Vorhandenen Songtext anhand seiner ID l√∂schen.
             * @param  {String}  id ID des zu l√∂schenden Songtexts
             * @return {Promise} Asynchrones Promise-Objekt
             */
            async delete(id) {
                return database.songtexts.delete(id);
            }

            /**
             * L√∂scht alle Songtexte!
             * @return {Promise} Asynchrones Promise-Objekt
             */
            async clear() {
                return database.songtexts.clear();
            }
        </code>
    </pre>
    <p>
        Sowie eine Funktion, um einen Songtext direkt auszulesen:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            /**
             * Vorhandenen Songtext anhand seiner ID auslesen.
             * @param  {String}  id ID des zu lesenden Songtexts
             * @return {Promise} Asynchrones Promise-Objekt mit dem Songtext
             */
            async getById(id) {
                return database.songtexts.get(id);
            }
        </code>
    </pre>
    <p>
        Und eine Funktion, die uns entweder alle Songtexte oder alle Texte
        anhand eines bestimmten Suchbegriffs zur√ºckliefert:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            /**
             * Gibt eine Liste mit allen Songtexten zur√ºck, deren Titel oder K√ºnstler
             * den gesuchten Wert enthalten.
             *
             * @param  {String}  query Gesuchter Titel oder K√ºnstler
             * @return {Promise} Asynchrones Promise-Objekt mit dem Suchergebnis
             */
            async search(query) {
                if (!query) query = "";
                query = query.toUpperCase();

                let result = database.songtexts.filter(songtext =&gt; {
                    let artist = songtext.artist.toUpperCase();
                    let title  = songtext.title.toUpperCase();
                    return artist.search(query) &gt; -1 || title.search(query) &gt; -1;
                });

                return result.toArray();
            }
        </code>
    </pre>
    <p>
        Die fertige Klasse sollte danach ungef√§hr so aussehen:
    </p>
    <figure>
        <img src="02/db/database-code.png" />
        <figcaption>
            Quellcode der fertigen <span class="cmd">Songtexts</span>-Klasse
        </figcaption>
    </figure>

    <h3>Ein kleiner Test vorab</h3>
    <p>
        Um die Funktionsweise der neuen Klasse zu testen, wollen wir etwas Testcode in die
        App einbauen, der beim Aufruf der √úbersichtsseite ausgef√ºhrt wird. Hierf√ºr m√ºssen wir
        die Datei <span class="fn">src/song-overview/song-overview.js</span> zun√§chst um
        folgenden Import erweitern:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
        import Database from "../database.js";
        </code>
    </pre>
    <p>
        Den Testcode k√∂nnen wir dann einfach in den Konstruktor einbauen. Dabei wollen wir
        nicht alle Methoden konsequent durchtesten. Wir wollen nur ein paar Testdaten anlegen
        und in der Konsole beobachten, was dabei passiert. √Ñndere die Konstruktor daher wie
        folgt ab. Sp√§ter werden wir den Testcode wieder entfernen.
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            constructor(app) {
                this._app = app;

                // Test der Datenbankklasse f√ºr Songtexte
                let test = async () =&gt; {
                    let songtexts = new Database.Songtexts();
                    await songtexts.clear();

                    let songs = await songtexts.search();
                    console.log("Alle Songs:", songs);

                    if (songs.length === 0) {
                        console.log("Bisher noch keine Songs vorhanden, lege deshalb Testdaten an");

                        await Promise.all([
                            songtexts.saveNew({
                                artist: "Queen",
                                title: "I Want To Break Free",
                                format: "html",
                                data: "HTML-Code f√ºr &lt;b&gt;I Want To Break Free&lt;/b&gt; von &lt;b&gt;Queen&lt;/b&gt;",
                            }),
                            songtexts.saveNew({
                                artist: "Queen",
                                title: "Radio Ga Ga",
                                format: "html",
                                data: "HTML-Code f√ºr &lt;b&gt;Radio Ga Ga&lt;/b&gt; von &lt;b&gt;Queen&lt;/b&gt;",
                            }),
                            songtexts.saveNew({
                                artist: "Michael Jackson",
                                title: "Billie Jean",
                                format: "html",
                                data: "HTML-Code f√ºr &lt;b&gt;Billie Jean&lt;/b&gt; von 6lt;b&gt;Michael Jackson&lt;/b&gt;",
                            }),
                        ]);

                        let songs = await songtexts.search();
                        console.log("Gespeicherte Songs:", songs);
                    }

                    songs = await songtexts.search("queen");
                    console.log('Suche nach dem Begriff "queen":', songs);
                }

                test();
                // Ende des Testcodes
            }
        </code>
    </pre>
    <p>
        Beim Start der Anwendung sollte dann folgendes Ergebnis in der Browserkonsole protokolliert werden:
    </p>
    <figure>
        <img src="02/db/testcode-konsole.png" class="border" />
        <figcaption>Protokollausgabe des Testcodes. Man sieht sch√∂n, wie die gespeicherten Objekte aufgebaut sind.</figcaption>
    </figure>
    <p>
        Wie du anhand des Quellcodes erkennen kannst, kannst du mit <span class="cmd">await</span>
        das Ergebnis einer asynchronen Methode abwarten. Das wird an dieser Stelle ben√∂tigt, da
        die Aufrufe von Dexie den Aufrufer nicht blockieren sondern nur dazu f√ºhren, dass die
        gew√ºnschte Datenbank√§nderung im Hintergrund ausgef√ºhrt wird. Das funktioniert allerdings
        nur, wenn die rufende Methode mit <span class="cmd">async</span> gekennzeichnet wurde,
        da JavaScript den Programmfluss sonst nicht unterbrechen kann, um ohne den Browser zu
        blockieren auf die Antwort zu warten. Dabei f√ºhrt jedes <span class="cmd">await</span>
        zu einer Unterbrechung, bis das gew√ºnschte Ergebnis zur Verf√ºgung steht. Soll allerdings
        nicht auf jedes Ergebnis nacheinander sondern gleichzeitig gewartet werden (das Programm
        soll dann erst weiterlaufen, wenn alle Ergebnisse vorliegen, unabh√§ngig von der Reihenfolge),
        kann das mit <span class="cmd">await Promise.all([ ... ])</span> erreicht werden.
    </p>
</section>

<!-- ‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì -->
<!-- async/await w√§hrend der Navigation -->
<!-- ‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì -->
<section data-title="async/await w√§hrend der Navigation">
    <p class="git-commit">
        Git Commit:
        <a href="https://github.com/DennisSchulmeister/dhbwka-wwi-webprog-my-songbook/tree/58d30597f334b2963a227f4f0b5597e09c30b4cc" target="_blank">58d3059</a>
    </p>

    <h3>Nebenl√§ufigkeit in JavaScript: Teil 1</h3>
    <p>
        An dieser Stelle ist noch etwas mehr Hintergrundwissen erforderlich, was es mit den
        asynchronen Methoden von Dexie und unserer Datenbankklasse auf sich hat. Dazu musst
        du wissen, dass es in JavaScript keine Threads wie in anderen Programmiersprachen
        gibt, mit denen nebenl√§ufige Programmfl√ºsse realisiert werden k√∂nnen. Stattdessen gibt
        es (stark vereinfacht gesagt) nur einen Hauptthread, in dem zu verschiedenen Zeitpunkten
        wirklich alles passiert, was der Browser macht:¬π
    </p>
    <ul>
        <li>
            Das Einlesen und Auswerten des HTML-Codes
        </li>
        <li>
            Das Nachladen von Stylesheets, Bildern und JavaScript-Dateien
        </li>
        <li>
            Die Ausf√ºhrung des JavaScript-Codes
        </li>
        <li>
            Die Darstellung der Webseite auf dem Bildschirm
        </li>
    </ul>
    <p>
        ¬π
        <small>
            Theoretisch kann es zwar vorkommen, dass ein bestimmter Browser die genannten Aktionen
            in mehreren Threads nebenl√§ufig ausf√ºhrt. Dies ist dann aber ein Implementierungsdetail
            des jeweiligen Browsers und kann mit JavaScript nicht beeinflusst werden. Die Sprache
            JavaScript kennt das Konzept von Threads nicht.
        </small>
    </p>
    <p>
        Als Folge daraus kann lang laufender JavaScript-Code die gesamte Browser-Performance
        verschlechtern oder den Browser gar komplett einfrieren. Da JavaScript anfangs aber nur
        f√ºr kleine Codeschnippsel in ansonsten v√∂llig statischen HTML-Dateien gedacht war, wurde
        bei der Definition der Sprache zun√§chst kein Wert auf Performance oder Nebenl√§ufigkeit
        gelegt. Erst in j√ºngerer Zeit hat sich dies ver√§ndert, sodass JavaScript inzwischen
        zwar immer noch keine Threads, daf√ºr aber folgende Konzepte der nebenl√§ufigen Programmierung
        kennt:
    </p>
    <ul>
        <li>
            <a href="https://de.wikipedia.org/wiki/Web_Worker" target="_blank">Web Worker:</a>
            Funktionieren √§hnlich wie Threads, indem sie es erlauben, eine Quelldatei mit Javascript-Code
            nachzuladen, der im Hintergrund unabh√§ngig vom Hauptthread ausgef√ºhrt wird.
        </li>
        <li>
            <a href="https://de.wikipedia.org/wiki/Future_(Programmierung)" target="_blank">Promises:</a>
            Erlauben es, eine einzelne Funktion im Hintergrund auszuf√ºhren, ohne dass hierf√ºr eine eigene Codedatei
            vom Server abgerufen werden muss. √Ñhnlich zu einem Event Handler kann eine Callback-Funktion registriert
            werden, die nach Abschluss der Hintergrundaktion im Hauptthread ausgef√ºhrt wird.
        </li>
        <li>
            <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" target="_blank">Asynchrone Funktionen:</a>
            Stellen eine syntaktische Vereinfachung dar, um einen Quellcode, in dem viel mit Promises gearbeitet wird,
            einfacher zu strukturieren. Eine asynchrone Funktion wird immer im Hintergrund ausgef√ºhrt, ohne dass hierf√ºr
            explizit ein Promise-Objekt erzeugt werden muss.
        </li>
    </ul>
    <p>
        Web Worker werden f√ºr die Arbeit mit Dexie nicht ben√∂tigt. Promises und asynchrone Methoden jedoch schon,
        weshalb wir sie uns hier ein wenig genauer anschauen wollen. Zun√§chst einmal wollen wir dabei zeigen,
        wie (ohne Verwendung asyonchroner Funktionen) ein Promise-Objekt erzeugt werden kann, um eine Aktion
        im Hintergrund auszuf√ºhren:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            let promise = new Promise((resolve, reject) =&gt; {
                // Hier musst du dir eine lange Berechnung denken, die m√∂glicherweise
                // den Browser einfrieren k√∂nnte. Sie liefert als Ergebnis die Zahl 42.
                // Manchmal l√§uft sie aber auch auf einen Fehler. Zur Sicherheit l√§uft
                // sie im Hintergrund.
                if (new Date().getSeconds() % 2) {
                    resolve(42);
                } else {
                    reject("Fehler: Aufruf in ungeraden Sekunden nicht erlaubt!");
                }
            });
        </code>
    </pre>
    <p>
        Wie du siehst, muss einfach nur ein <span class="cmd">Promise</span>-Objekt erzeugt und
        diesem die im Hintergrund auszuf√ºhrende Funktion √ºbergeben werden. Die Funktion kann dabei
        bis zu zwei Parameter besitzen, √ºber die ein Ergebnis oder eine Fehlermeldung an den
        Hauptthread zur√ºckgegeben werden kann. Hierf√ºr kann der Hauptthread mehrere Callbacks
        registrieren, die nach Abschluss der Hintergrundaktion ausgef√ºhrt werden:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            promise.then(ergebnis =&gt; {
                // Diese Funktion wird im Hauptthread ausgef√ºhrt und bekommt
                // den Wert aus der obigen resolve()-Zeile √ºbergeben.
                alert(`Das Ergebnis lautet ${ergebnis}.`);
            }).catch(fehler =&gt; {
                // Diese Funktion wird auch im Hauptthread ausgef√ºhrt. Sie
                // bekommt den Wert aus der obigen reject()-Zeile √ºbergeben.
                alert(fehler);
            });
        </code>
    </pre>
    <p>
        Je nach aktueller Sekunde zeigt der obige Code die Zahl 42 oder einen Fehler.
    </p>
    <figure>
        <img src="02/async/promise-resolved.png" class="border" />
        <figcaption>Karlsruhe, 23:36:00: Die Frisur h√§lt!</figcaption>
    </figure>
    <figure>
        <img src="02/async/promise-rejected.png" class="border" />
        <figcaption>Mannheim, eine Sekunde sp√§ter: Der Code l√§uft auf einen Fehler.</figcaption>
    </figure>

    <h3>Nebenl√§ufigkeit in JavaScript: Teil 2</h3>
    <p>
        Im Grunde genommen lassen sich auf die eben gezeigte Weise beliebige, langl√§ufige
        Aktionen, wie das Speichern von Daten in einer Datenbank, in den Hintergrund verlagern,
        ohne dabei die Performance des Browsers herunterzuziehen. Auch l√§sst sich auf diese
        Weise ganz einfach der Zeitpunkt abfangen, an dem Dexie eine √Ñnderung in der Datenbank
        auch wirklich ausgef√ºhrt hat, da Dexie (und auch unsere <span class="cmd">Database</span>-Klasse)
        immer ein <span class="cmd">Promise</span>-Objekt zur√ºckliefern. Zum Beispiel so:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            let songtexts = new Database.Songtexts();
            let promise = songtexts.search();

            promise.then(songs =&gt; {
                // Die gesuchten Songs stehen nun zur Verf√ºgung und k√∂nnen
                // via DOM-Manipulation angezeigt werden
                songs.forEach(song => {
                    <b>‚Ä¶ Songs anzeigen ‚Ä¶</b>
                });
            }).catch(error => {
                <b>‚Ä¶ Fehlerbehandlung ‚Ä¶</b>
            });

            // ACHTUNG! W√§hrend der Code ab dieser Zeile ausgef√ºhrt wird,
            // l√§uft der Datenbankzugriff durch Dexie noch. An dieser Stelle
            // k√∂nnen wir noch nicht auf das Ergebnis zugreifen. Nur die
            // obige R√ºckruffunktion des Promise-Objekts, die allerdings
            // erst irgendwann sp√§ter aufgerufen wird, bekommt das gew√ºnschte
            // Ergebnis √ºbergeben
            <b>‚Ä¶ Sonstiger Quellcode ‚Ä¶</b>
        </code>
    </pre>
    <p>
        Gerade, wenn man viele Datenbankzugriffe hintereinander ausf√ºhren will, kann das
        schnell un√ºbersichtlich werden. Mit Hilfe des Schl√ºsselworts <span class="cmd">await</span>
        l√§sst sich der Code jedoch ganz einfach schreiben:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            async function searchAndDisplaySongs() {
                try {
                    let songtexts = new Database.Songtexts();
                    let songs = await songtexts.search();

                    songs.forEach(song => {
                        <b>‚Ä¶ Songs anzeigen ‚Ä¶</b>
                    });
                } catch (error) {
                    <b>‚Ä¶ Fehlerbehandlung ‚Ä¶</b>
                }
            }

            searchAndDisplaySongs();
        </code>
    </pre>
    <p>
        Dieser Code bewirkt exakt das Gleiche, kommt aber v√∂llig ohne Callbacks aus!
        Stattdessen wird der Code bei der <span class="cmd">await</span>-Anweisung
        einfach so lange unterbrochen, bis das von <span class="cmd">songtexts.search()</span>
        zur√ºckgegebene <span class="cmd">Promise</span>-Objekt entweder ein Ergebnis
        oder einen Fehler liefert.
    </p>
    <p>
        Einen kleinen Nachteil hat das Schl√ºsselwort <span class="cmd">await</span> allerdings,
        weshalb es nicht in jeder Situation genutzt werden kann. Es darf nur innerhalb einer
        Funktion verwendet werden, die mit <span class="cmd">async</span> als asynchrone Funktion
        gekennzeichnet wurde, weshalb der Aufruf oben in die Funktion
        <span class="cmd">searchAndDisplaySongs()</span> verschoben wurde. Au√üerhalb einer solchen
        Funktion f√ºhrt <span class="cmd">await</span> zu einem Syntaxfehler und damit zu einem
        kompletten Abbruch des JavaScript-Codes!
    </p>
    <p>
        Der Grund daf√ºr liegt, wie so oft, in der Abw√§rtskompatibilit√§t von JavaScript. Fr√ºher
        gab es das Schl√ºsselwort <span class="cmd">await</span> nicht, so dass es eine gro√üe
        Anzahl von produktivem JavaScript-Code gibt, der sich m√∂glicherweise falsch verh√§lt,
        wenn er f√ºr eine nicht genau vorhersagbare Zeit unterbrochen und erst sp√§ter wieder
        fortgef√ºhrt wird. Also musste man sich eine neue Syntax einfallen lassen, die ganz klar
        kennzeichnet, wenn eine Funktion prinzipiell unterbrechbar ist. Ein viel wichtiger Grund
        ist jedoch, wie <span class="cmd">async</span> und <span class="cmd">await</span> technisch
        realisiert wurden:
    </p>
    <ul>
        <li>
            <span class="cmd">async:</span> Sorgt daf√ºr, dass der gesamte Code der hiermit
            gekennzeichneten Funktion <b>immer</b> im Hintergrund ausgef√ºhrt wird und die Funktion
            deshalb ein <span class="cmd">Promise</span>-Objekt zur√ºckliefert.
        </li>
        <li>
            <span class="cmd">await:</span> Unterbricht die aktuelle Hintergrundfunktion, um auf
            das Ende einer anderen Hintergrundfunktion zu warten.
        </li>
    </ul>
    <p>
        Unser Einf√ºhrungsbeispiel von ganz oben l√§sst sich deshalb mit <span class="cmd">async</span>
        wie folgt vereinfachen, bewirkt aber exakt dasselbe wie in der alten Version:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            let beispiel = async () =&gt; {
                // Hier musst du dir eine lange Berechnung denken, die m√∂glicherweise
                // den Browser einfrieren k√∂nnte. Sie liefert als Ergebnis die Zahl 42.
                // Manchmal l√§uft sie aber auch auf einen Fehler. Zur Sicherheit l√§uft
                // sie im Hintergrund.
                if (new Date().getSeconds() % 2) {
                    return 42;
                } else {
                    throw "Fehler: Aufruf in ungeraden Sekunden nicht erlaubt!";
                }
            };
         </code>
    </pre>
    <p>
        Diese Funktion liefert implizit immer ein <span class="cmd">Promise</span> als
        Ergebnis zur√ºck, weshalb das zweite Beispiel im Grunde genommen unver√§ndert
        weiter funktioniert:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            let promise = beispiel();

            promise.then(ergebnis =&gt; {
                // Diese Funktion wird im Hauptthread ausgef√ºhrt und bekommt
                // den Wert aus der obigen resolve()-Zeile √ºbergeben.
                alert(`Das Ergebnis lautet ${ergebnis}.`);
            }).catch(fehler =&gt; {
                // Diese Funktion wird auch im Hauptthread ausgef√ºhrt. Sie
                // bekommt den Wert aus der obigen reject()-Zeile √ºbergeben.
                alert(fehler);
            });
        </code>
    </pre>
    <p>
        Mit <span class="cmd">await</span> l√§sst sich aber auch dies vereinfachen, wie
        wir ja schon gesehen haben:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            let aufruf_von_beispiel = async () =&gt; {
                try {
                    let ergebnis = await beispiel();
                    alert(`Das Ergebnis lautet ${ergebnis}.`);
                } catch (fehler) {
                    alert(fehler);
                }
            };

            aufruf_von_beispiel();
        </code>
    </pre>
    <figure>
        <img src="02/async/await-resolved.png" class="border" />
        <figcaption>Auch hier bekommen wir mal ein Ergebnis ‚Ä¶</figcaption>
    </figure>
    <figure>
        <img src="02/async/await-rejected.png" class="border" />
        <figcaption>‚Ä¶ und mal die Fehlermeldung.</figcaption>
    </figure>

    <h3>Ausbauen des Testcodes</h3>
    <p>
        Mit soviel theoretischem Hintergrundwissen im Hinterkopf wird es nun Zeit, unseren
        Testcode aus der Klasse <span class="cmd">SongOverview</span> wieder auszubauen.
        Wenn er wenigstens einmal ausgef√ºhrt wurde, brauchen wir ihn ab jetzt nicht mehr.
        √ñffne daher die Datei <span class="fn">src/song-overview/song-overview.js</span>
        und ersetze den Konstruktor wieder durch seine alte Version:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            constructor(app) {
                this._app = app;
            }
        </code>
    </pre>
    <p>
        Bevor du den Code entfernst, schaue ihn dir aber nochmal ganz genau an. Du solltest
        jetzt in der Lage sein zu verstehen, wof√ºr die ganzen <span class="cmd">async</span>,
        <span class="cmd">await</span> und <span class="cmd">Promise.all()</span> ben√∂tigt werden.
    </p>

    <h3>Asynchrone Methodenaufrufe w√§hrend der Navigation erlauben</h3>
    <p>
        Wenn wir nun gleich die √úbersichtsseite ausprogrammieren wollen, um dort alle in der
        Datenbank gespeicherten Songs anzuzeigen, m√ºssen wir in der Lage sein, innerhalb der
        <span class="cmd">onShow()</span>-Methode der Klasse <span class="cmd">SongOverview</span>
        unsere asynchronen Datenbankmethoden aufzurufen und dabei auf das Ergebnis der
        Datenbankanfrage zu warten, bevor wir es zur Anzeige bringen. Dank unserem neuen Wissen
        √ºber Promises kein Problem, sch√∂ner w√§re es jedoch, wenn wir auch hier das Schl√ºsselwort
        <span class="cmd">await</span> verwenden k√∂nnte, um den Quellcode zu vereinfachen.
    </p>
    <p>
        Zun√§chst m√ºssen wir die Methoden <span class="cmd">onShow()</span> und <span class="cmd">onLeave()</span>
        daher zu asynchronen Methoden machen, indem wir ihnen das Schl√ºsselwort <span class="cmd">await</span>
        vorne anstellen. Rufe daher die beiden Dateien <span class="fn">src/song-overview/song-overview.js</span>
        und <span class="fn">src/song-display-edit/song-display-edit.js</span> auf und √§ndere die beiden Methoden
        entsprechend ab:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            // src/song-overview/song-overview.js
            class SongOverview {
                ‚Ä¶
                <b>async</b> onShow() {
                    ‚Ä¶
                }

                <b>async</b> onLeave() {
                    ‚Ä¶
                }
                ‚Ä¶
            }
        </code>
    </pre>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            // src/song-display-edit/song-display-edit.js
            class SongDisplayEdit {
                ‚Ä¶
                <b>async</b> onShow() {
                    ‚Ä¶
                }

                <b>async</b> onLeave() {
                    ‚Ä¶
                }
                ‚Ä¶
            }
        </code>
    </pre>
    <p>
        Dadurch wird dann eine Anpassung an der Klasse <span class="cmd">App</span>
        in der Datei <span class="fn">src/app.js</span> notwendig, in der wir die
        Methode <span class="cmd">_switchVisibleView()</span> austauschen m√ºssen:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            <b>async</b> _switchVisibleView(view) {
                // Callback, mit dem die noch sichtbare View den Seitenwechsel zu einem
                // sp√§teren Zeitpunkt fortf√ºhren kann, wenn sie in der Methode onLeave()
                // false zur√ºckliefert. Dadurch erh√§lt sie die M√∂glichkeit, den Anwender
                // zum Beispiel zu fragen, ob er ungesicherte Daten speichern will,
                // bevor er die Seite verl√§sst.
                let newUrl = this._router.lastRouteResolved().url;
                let goon = () =&gt; {
                    // ?goon an die URL h√§ngen, weil der Router sonst nicht weiternavigiert
                    this._router.navigate(newUrl + "?goon");
                }

                // Aktuelle View fragen, ob eine neue View aufgerufen werden darf
                <b>if (this._currentView) {</b>
                    <b>let goonAllowed = await this._currentView.onLeave(goon);</b>

                    <b>if (!goonAllowed) {</b>
                        <b>this._navAborted = true;</b>
                        <b>return false;</b>
                    <b>}</b>
                <b>}</b>

                // Alles klar, aktuelle View nun wechseln
                document.title = `${this._title} ‚Äì ${view.title}`;

                this._currentView = view;
                this._switchVisibleContent(<b>await</b> view.onShow());
                return true;
            }
        </code>
    </pre>
    <p>
        Dadurch sind dann alle Vorbereitungen abgeschlossen, damit wir die √úbersichtsseite
        nun ausprogrammieren k√∂nnen. Auch wenn die √Ñnderung selbst nur sehr klein war,
        verstehst du jetzt wenigstens, was sie bewirkt und warum wir sie ben√∂tigen.
    </p>
</section>

<!-- ‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì -->
<!-- Die √úbersichtsseite entsteht -->
<!-- ‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì -->
<section data-title="Die √úbersichtsseite entsteht">
    <p class="git-commit">
        Git Commit:
        <a href="https://github.com/DennisSchulmeister/dhbwka-wwi-webprog-my-songbook/tree/141d8b1ae7507464fce7fdc2622cd38e70a601a0" target="_blank">141d8b1</a>
    </p>

    <h3>Gestaltung der √úbersichtsseite</h3>
    <p>
        An dieser Stelle wird es nun Zeit, den Dummy-Inhalt der App wieder zu entfernen und
        durch richtigen Inhalt zu ersetzen. √ñffne daher die Datei <span class="fn">src/app.css</span>
        und entferne folgenden Bereich:
    </p>
    <pre data-gobble>
        <code class="css" data-gobble>
            /*
             * Hauptinhalt
             */
            #app main {
                /*
                 * Tempor√§rer Inhalt, solange es noch keinen richtigen Inhalt gibt
                 * Bild: https://pixabay.com/de/handwerker-baustelle-arbeiter-3094035/
                 */
                background-image: url(construction.jpg);
                background-size: 100% auto;
                background-position: bottom center;
                background-repeat: no-repeat;

                color: rgb(255, 246, 23);
                text-shadow: 1px 1px 2px black;
                font-size: 300%;
                font-weight: bold;
                text-align: center;
            }
        </code>
    </pre>
    <p>
        Stattdessen bauen wir in die <span class="fn">src/index.html</span> folgenden
        neuen Inhalt an, damit wir uns an das Stylehsset f√ºr die √úbersichtsseite machen
        k√∂nnen. Auch dieser Inhalt verschwindet gleich wieder, zun√§chst ben√∂tigen wir
        ihn aber, um die Stylesheets schreiben zu k√∂nnen.
    </p>
    <pre data-gobble>
        <code class="html" data-gobble>
            &lt;!-- ====================== --&gt;
            &lt;!-- View: Vorhandene Songs --&gt;
            &lt;!-- ====================== --&gt;
            &lt;section id="song-overview" class="hidden"&gt;
                &lt;!-- Topbar --&gt;
                &lt;header&gt;
                    <b>Diesen Inhalt nicht √§ndern!</b>
                &lt;/header&gt;

                &lt;!-- Hauptbereich --&gt;
                &lt;main&gt;
                    &lt;ul&gt;
                        &lt;li&gt;
                            &lt;div class="padding no-data"&gt;
                                Noch keine Texte vorhanden
                            &lt;/div&gt;
                        &lt;/li&gt;

                        &lt;li data-section-title="A"&gt;
                            &lt;div class="section-title"&gt;
                                A
                            &lt;/div&gt;
                        &lt;/li&gt;
                        &lt;li class="entry" data-song-title="Another Day In Paradise" data-song-artist="Phil Collins"&gt;
                            &lt;div class="song-title"&gt;
                                Another Day In Paradise
                            &lt;/div&gt;
                            &lt;div class="song-artist"&gt;
                                Phil Collins
                            &lt;/div&gt;
                        &lt;/li&gt;
                        &lt;li class="entry" data-song-title="Another One Bites The Dust" data-song-artist="Queen"&gt;
                            &lt;div class="song-title"&gt;
                                Another One Bites The Dust
                            &lt;/div&gt;
                            &lt;div class="song-artist"&gt;
                                Queen
                            &lt;/div&gt;
                        &lt;/li&gt;

                        &lt;li data-section-title="B"&gt;
                            &lt;div class="section-title"&gt;
                                B
                            &lt;/div&gt;
                        &lt;/li&gt;
                        &lt;li class="entry" data-song-title="Bennie And The Jets" data-song-artist="Elton John"&gt;
                            &lt;div class="song-title"&gt;
                                Bennie And The Jets
                            &lt;/div&gt;
                            &lt;div class="song-artist"&gt;
                                Elton John
                            &lt;/div&gt;
                        &lt;/li&gt;
                    &lt;/ul&gt;
                &lt;/main&gt;
            &lt;/section&gt;
        </code>
    </pre>
    <p>
        Anstelle des alten Inhalts zeigen wir nun eine Liste der vorhandenen Songtexte an.
        Wie du siehst, spielt sich alles in einem <span class="cmd">&lt;ul&gt;</span>-Element
        ab, wobei es verschiedene Listeneintr√§ge gibt. Der Eintrag, wenn noch keine Songtexte
        vorhanden sind, sieht so aus:
    </p>
    <pre data-gobble>
        <code class="html" data-gobble>
            &lt;li&gt;
                &lt;div class="padding no-data"&gt;
                    Noch keine Texte vorhanden
                &lt;/div&gt;
            &lt;/li&gt;
        </code>
    </pre>
    <p>
        Zwischen√ºberschriften sehen so aus:
    </p>
    <pre data-gobble>
        <code class="html" data-gobble>
            &lt;li data-section-title="A"&gt;
                &lt;div class="section-title"&gt;
                    A
                &lt;/div&gt;
            &lt;/li&gt;
        </code>
    </pre>
    <p>
        Und die eigentlichen Songtexte sehen so aus:
    </p>
    <pre data-gobble>
        <code class="html" data-gobble>
            &lt;li class="entry" data-song-title="Another Day In Paradise" data-song-artist="Phil Collins"&gt;
                &lt;div class="song-title"&gt;
                    Another Day In Paradise
                &lt;/div&gt;
                &lt;div class="song-artist"&gt;
                    Phil Collins
                &lt;/div&gt;
            &lt;/li&gt;
        </code>
    </pre>
    <p>
        Auf diese Struktur k√∂nnen wir nun zugreifen, um das Stylesheet zu schreiben. Doch zuvor
        ben√∂tigen wir noch ein paar weitere Variablen in der Datei <span class="fn">src/theme.css</span>.
    </p>
    <pre data-gobble>
        <code class="css" data-gobble>
            html {
                <b>Bisherige Variablen bitte beibehalten ‚Ä¶</b>

                --overview-heading-background-color: rgb(230,230,230);
                --overview-heading-font-color:       rgb(78,81,116);
                --overview-list-hover-color:         rgba(0,0,0, 0.05);
            }
        </code>
    </pre>
    <p>
        Damit k√∂nnen wir nun die Datei <span class="fn">src/song-overview/song-overview.css</span>
        durch folgende Version ersetzen.
    </p>
    <pre data-gobble>
        <code class="css" data-gobble>
            .song-overview ul {
                list-style: none;
                margin: 0;
                padding: 0;
                font-size: 130%;
            }

            .song-overview .no-data {
                color: var(--header-normal-background-color);
                text-shadow: 1px 1px 1px rgba(0,0,0, 0.25);
            }

            .song-overview li {
                border: 0px solid var(--overview-heading-background-color);
                border-bottom-width: 1px;
            }

            .song-overview .entry:hover {
                background-color: var(--overview-list-hover-color);
                cursor: pointer;
            }

            .song-overview li &gt; div {
                padding: 0 0.5rem 0 0.5rem;
            }

            .song-overview .section-title {
                background: var(--overview-heading-background-color);
                color: var(--overview-heading-font-color);
                font-weight: bold;
            }

            .song-overview .song-artist {
                font-size: 75%;
            }
        </code>
    </pre>
    <p>
        Das Ergebnis sollte dann so aussehen:
    </p>
    <figure>
        <img src="02/song-overview/statischer-inhalt.png" class="border" />
        <figcaption>Das fertige Layout der √úbersichtsseite (hier noch mit statischem Inhalt)</figcaption>
    </figure>

    <h3>Eintr√§ge aus der Datenbank lesen und anzeigen</h3>
    <p>
        Das sieht ja schon ganz gut aus. Jetzt soll der Inhalt aber auch aus der Datenbank kommen.
        Der eben noch in die <span class="fn">src/index.html</span> eingef√ºgte HTML-Code reduziert
        sich deshalb nun zu folgenden paar Zeilen. Es kommt alles weg bis auf die Liste selbst
        dargestellt durch das <span class="cmd">&lt;ul&gt;</span>-Element.
    </p>
    <pre data-gobble>
        <code class="html" data-gobble>
            &lt;!-- ====================== --&gt;
            &lt;!-- View: Vorhandene Songs --&gt;
            &lt;!-- ====================== --&gt;
            &lt;section id="song-overview" class="hidden"&gt;
                &lt;!-- Topbar --&gt;
                &lt;header&gt;
                    <b>Diesen Inhalt nicht √§ndern!</b>
                &lt;/header&gt;

                &lt;!-- Hauptbereich --&gt;
                &lt;main&gt;
                    &lt;ul&gt;&lt;/ul&gt;
                &lt;/main&gt;
            &lt;/section&gt;
        </code>
    </pre>
    <p>
        Weiter geht es in der Datei <span class="fn">src/song-overview/song-overview.js</span>,
        in der wir zwei neue Methoden zum Lesen der Songs aus der Datenbank und zur Anzeige
        der gefundenen Eintr√§ge ben√∂tigen. Die Methode zum Lesen der Songs sieht wie folgt aus.
        Sie ist im Grunde genommen ganz einfach, durch den umfangreichen Kommentar am Anfang
        und die Vergleichsfunktion zum Sortieren der Songs wirkt sie allerdings gr√∂√üer, als sie
        in Wirklichkeit ist.
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            /**
             * Diese Methode greift auf die Datenbank zu und sucht die gespeicherten
             * Songs. Optional kann ein Suchbegriff mitgegeben werden, der innerhalb
             * des Songtitels oder des K√ºnstlernamens vorkommen muss. Ebenso kann
             * einer von folgenden Werten mitgegeben werden, um die Ergebnisliste zu
             * sortieren:
             *
             *   * "title": Sortierung nach Songtitel und K√ºnstler
             *   * "artist": Sortierung nach K√ºnstler und Songtitel
             *
             * Die Ergebnisliste hat folgendes Format:
             *
             * [
             *      {
             *          id: "Datenbank-ID",                 // Schl√ºsselwert der Datenbank
             *          artist: "Name des K√ºnstlers",       // Name des K√ºnstlers
             *          title: "Name des Songs",            // Name des Songs
             *          format: "html",                     // Bisher immer "html"
             *          data: "HTML-String",                // HTML-String mit Songinhalt
             *      }, {
             *        ‚Ä¶
             *      }
             * ]
             *
             * @param  {String} query Suchbegriff (optional)
             * @param  {String} sort Sortierung (optional)
             * @return {Array} Liste der gefundenen Songs
             */
            async _searchSongs(query, sort) {
                // Songs suchen
                let songtexts = new Database.Songtexts();
                let songs = await songtexts.search(query);

                // Ergebnis sortieren
                songs.sort((lhs, rhs) =&gt; {
                    let resultArtist = lhs.artist.localeCompare(rhs.artist);
                    let resultTitle = lhs.title.localeCompare(rhs.title);

                    if (sort === "artist") {
                        // Sortierung nach K√ºnstler und Songtitel
                        if (resultArtist != 0) {
                            return resultArtist;
                        } else {
                            return resultTitle;
                        }
                    } else {
                        // Sortierung nach Songtitel und K√ºnstler
                        if (resultTitle != 0) {
                            return resultTitle;
                        } else {
                            return resultArtist;
                        }
                    }
                });

                return songs;
            }
        </code>
    </pre>
    <p>
        Die Methode zur Ausgabe der gefundenen Songs in der HTML-Oberfl√§che ist allerdings
        tats√§chlich etwas l√§nglich, weil wir hier relativ viele DOM-Objekte erzeugen und
        aufrufen m√ºssen, um den dynamischen HTML-Code zu generieren. In den sp√§teren Teilen
        der Anleitung werden wir diesen Code deshalb nochmal √ºberarbeiten.
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            /**
             * Diese Methode nimmt die von searchSongs() generierte Liste mit Songtexten
             * entgegen und zeigt sie auf der Seite an. Hierf√ºr muss der Methode √ºber
             * den Parameter groupBy einer von folgenden beiden Strings mitgegeben
             * werden:
             *
             *   * "title": Gruppierung anhand erstem Buchstaben des Titels
             *   * "artist": Gruppierung anhand des K√ºnstlers
             *
             * Im Parameter parentNode muss das &lt;ul&gt;-Element √ºbergeben werden, in
             * welches die Listeneintr√§ge eingef√ºgt werden sollen.
             *
             * @param {Array} songs Liste der darzustellenden Songs
             * @param {String} groupBy Kriterium f√ºr die Zwischen√ºberschriften
             * @param {HTMLNode} parentNode &lt;ul&gt;-Element der Liste
             */
            _renderList(songs, groupBy, parentNode) {
                parentNode.innerHTML = "";

                if (songs.length &lt; 1) {
                    // Hinweistext, wenn noch keine Songs vorhanden sind
                    parentNode.innerHTML += `
                        &lt;li&gt;
                            &lt;div class="padding no-data"&gt;
                                Noch keine Texte vorhanden
                            &lt;/div&gt;
                        &lt;/li&gt;
                    `;
                } else {
                    // Zwischen√ºberschriften und Songtexte
                    let currentGroup = "";

                    songs.forEach(song =&gt; {
                        // Zwischen√ºberschrift zur Gruppierung der Songs
                        //
                        // &lt;li data-section-title="A"&gt;
                        //     &lt;div class="section-title"&gt;
                        //         A
                        //     &lt;/div&gt;
                        // &lt;/li&gt;
                        let songGroup1 = "";
                        let songGroup2 = "";

                        if (groupBy === "title") {
                            songGroup1 = song.title.trim()[0].toUpperCase();
                            songGroup2 = songGroup1;
                        } else {
                            songGroup1 = song.artist.trim();
                            songGroup2 = songGroup1.toUpperCase();
                        }

                        if (currentGroup != songGroup2) {
                            currentGroup = songGroup2;

                            let liGroup = document.createElement("li");
                            liGroup.dataset.sectionTitle = songGroup1;

                            let divGroup = document.createElement("div");
                            divGroup.classList.add("section-title");
                            divGroup.textContent = songGroup1;

                            parentNode.appendChild(liGroup);
                            liGroup.appendChild(divGroup);
                        }

                        // Der eigentliche Song
                        //
                        // &lt;li class="entry" data-song-title="Another Day In Paradise" data-song-artist="Phil Collins"&gt;
                        //     &lt;div class="song-title"&gt;
                        //         Another Day In Paradise
                        //     &lt;/div&gt;
                        //     &lt;div class="song-artist"&gt;
                        //         Phil Collins
                        //     &lt;/div&gt;
                        // &lt;/li&gt;
                        let liSong = document.createElement("li");
                        liSong.classList.add("entry");
                        liSong.dataset.songTitle = song.title.trim();
                        liSong.dataset.songArtist = song.artist.trim();

                        let divTitle = document.createElement("div");
                        divTitle.classList.add("song-title");
                        divTitle.textContent = song.title.trim();

                        let divArtist = document.createElement("div");
                        divArtist.classList.add("song-artist");
                        divArtist.textContent = song.artist.trim();

                        parentNode.appendChild(liSong);
                        liSong.appendChild(divTitle);
                        liSong.appendChild(divArtist);
                    });
                }
            }
        </code>
    </pre>
    <p>
        Jetzt m√ºssen wir die beiden Methoden nur noch an der richtigen Stelle aufrufen,
        um etwas auf dem Bildschirm zu sehen. Die Methode <span class="cmd">onShow()</span>
        ist genau der richtige Ort daf√ºr, da wir die Songliste beim Aufruf der Seite lesen
        und auf den Bildschirm bringen wollen. √Ñndere die <span class="cmd">onShow()</span>-Methode
        daher wie folgt ab:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            async onShow() {
                let section = document.querySelector("#song-overview").cloneNode(true);

                <b>let order = "title";</b>
                <b>let query = "";</b>

                <b>let songs = await this._searchSongs(query, order);</b>
                <b>this._renderList(songs, order, section.querySelector("main &gt; ul"));</b>

                return {
                    className: "song-overview",
                    topbar: section.querySelectorAll("header &gt; *"),
                    main: section.querySelectorAll("main &gt; *"),
                };
            }
        </code>
    </pre>
    <p>
        Und schon sollte sich dir folgendes Bild bieten. Vorausgesetzt nat√ºrlich, dass
        die Testeintr√§ge noch in deiner lokalen Datenbank enthalten sind. Sollten keine
        Eintr√§ge zu sehen sein, baue nochmal den Testcode zu ihrer Erzeugung ein und
        stelle sicher, dass in der Browserkonsole keine Fehlermeldungen entstehen.
    </p>
    <figure>
        <img src="02/song-overview/dynamischer-inhalt.png" class="border" />
        <figcaption>Sieht fast gleich aus, die Eintr√§ge kommen jetzt aber aus der Datenbank.</figcaption>
    </figure>
</section>

<!-- ‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì -->
<!-- Schlankheitskur f√ºr den Kopfbereich -->
<!-- ‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì -->
<section data-title="Schlankheitskur f√ºr den Kopfbereich">
    <p class="git-commit">
        Git Commit:
        <a href="https://github.com/DennisSchulmeister/dhbwka-wwi-webprog-my-songbook/tree/c1ff138153d04bd9d91d405f5aa489f17343a343" target="_blank">c1ff138</a>
    </p>

    <p>
        Nachdem die Darstellung der Songliste nun funktioniert, wird es Zeit, die
        Sortier- und Suchfunktion auszuprogrammieren. Zuvor wollen wir uns aber noch
        einem kleinen Usability-Problem annehmen. Und zwar dem Kopfbereich, der in der
        mobilen Ansicht zwar gut zu bedienen ist, daf√ºr aber viel zu viel Platz einnimmt.
        Im folgenden Screenshot sieht man, dass auf einem Smartphone fast die halbe
        Bildschirmh√∂he verloren geht:
    </p>
    <figure style="max-width: 25em;">
        <img src="02/kopfzeile/mobile-vorher.png" class="border" />
        <figcaption>Der Kopfbereich belegt fast den halben Bildschirm</figcaption>
    </figure>
    <p>
        Die L√∂sung des Problems ist im Grunde genommen ganz einfach, erfordert an dieser
        Stelle aber ein wenig Programmierarbeit: Wir ben√∂tigen ein
        <a href="https://de.wikipedia.org/wiki/Hamburger-Men%C3%BC-Icon" target="_blank">Hamburger-Men√º</a>.
        So soll die fertige L√∂sung daher aussehen:
    </p>
    <figure style="max-width: 25em;">
        <img src="02/kopfzeile/menue-zugeklappt.png" class="border" />
        <figcaption>Anfangs ist das Men√º zugeklappt.</figcaption>
    </figure>
    <figure style="max-width: 25em;">
        <img src="02/kopfzeile/menue-aufgeklappt.png" class="border" />
        <figcaption>Bei Klick auf das Symbol erscheint die volle Auswahl.</figcaption>
    </figure>
    <p>
        Zun√§chst m√ºssen wir das Hamburger-Icon im HTML-Code definieren, was mit folgender
        kleinen Anpassung in  <span class="fn">src/index.html</span> gelingt. Gleichzeitig
        f√ºgen wir dem umgebenden <span class="cmd">&lt;div&gt;</span> noch zwei CSS-Klassen
        hinzu, auf die wir mit JavaScript gleich zugreifen werden.
    </p>
    <pre data-gobble>
        <code class="html" data-gobble>
            &lt;section id="app"&gt;
                ‚Ä¶
                    &lt;div class="item <b>hamburger-menu menu-closed</b>"&gt;
                        &lt;b&gt;
                            <b>&lt;span class="menu-icon"&gt;‚â°&lt;/span&gt;</b>
                            Beispiel einer Browser App: My Songbook
                        &lt;/b&gt;
                    &lt;/div&gt;
                ‚Ä¶
            &lt;/section&gt;
        </code>
    </pre>
    <p>
        Zus√§tzlich kennzeichnen wir die auf dem Smartphone zun√§chst auszublendenden Men√ºpunkte
        mit der CSS-Klasse <span class="cmd">menu-content</span>:
    </p>
    <pre data-gobble>
        <code class="html" data-gobble>
            &lt;section id="app"&gt;
                ‚Ä¶
                &lt;div class="top right <b>menu-content</b>"&gt;
                    ‚Ä¶
                &lt;/div&gt;
                ‚Ä¶
            &lt;/section&gt;

            &lt;section id="song-overview" class="hidden"&gt;
                ‚Ä¶
                &lt;div class="left <b>menu-content</b>"&gt;
                    ‚Ä¶
                &lt;/div&gt;
                ‚Ä¶
            &lt;/section&gt;

            &lt;section id="song-display-edit" class="hidden"&gt;
                ‚Ä¶
                &lt;div class="left <b>menu-content</b>"&gt;
                    ‚Ä¶
                &lt;/div&gt;
                ‚Ä¶
            &lt;/section&gt;
        </code>
    </pre>
    <p>
        Damit ist der HTML-Code schon auf das neue Men√º vorbereitet. Allerdings
        brauchen wir das Hamburger-Icon nur in der Smartphone-Ansicht, da auf
        gro√üen Bildschirmen alles beim Alten bleiben soll. Folgende Zeilen in
        <span class="fn">src/app.css</span> reichen daf√ºr schon aus:
    </p>
    <pre data-gobble>
        <code class="css" data-gobble>
            /*
             * Anpassung an gro√üe Bildschirme, sobald in der index.css das gro√üe
             * Hintergrundbild eingeschaltet wird
             */
            @media screen and (min-width: 85em) {
                ‚Ä¶
                /* Men√º-Icon ausblenden */
                #app header .menu-icon {
                    display: none;
                }
                ‚Ä¶
            }
        </code>
    </pre>
    <p>
        Die einzelnen Men√ºpunkte werden wir zur Laufzeit durch Hinzuf√ºgen der CSS-Klasse
        <span class="cmd">hidden</span> ausblenden. Diese ist bereits im Stylesheet
        <span class="fn">src/index.css</span> definiert, muss aber noch um den Zusatz
        <span class="cmd">!important</span> erg√§nzt werden:
    </p>
    <pre data-gobble>
        <code class="css" data-gobble>
            .hidden {
                display: none !important;
            }
        </code>
    </pre>
    <p>
        Fehlt nur noch das dazugeh√∂rige JavaScript. Dieses f√ºgen wir am Ende des
        Konstruktors der Klasse <span class="cmd">App</span>, also in der Datei
        <span class="fn">src/app.js</span> ein. Los geht's mit einem Event Handler,
        der das Men√º bei Klick auf die Titelzeile auf- und zuklappt:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            class App {
                /**
                 * Konstruktor.
                 */
                constructor() {
                    ‚Ä¶
                    // Hamburger-Men√º f√ºr kleine Bildschirme erm√∂glichen
                    let menuButton = document.querySelector("header .hamburger-menu");

                    menuButton.addEventListener("click", () =&gt; {
                        // Nur auf kleinen Bildschirmen auf den Klick reagieren
                        if (menuButton.classList.contains("inactive")) return;

                        // Sichtbarkeit des Men√ºs umschalten
                        let menuState = "menu-open";
                        if (menuButton.classList.contains("menu-open")) menuState = "menu-closed";

                        menuButton.classList.remove("menu-open");
                        menuButton.classList.remove("menu-closed");
                        menuButton.classList.add(menuState);

                        // Men√ºeintr√§ge ein-/ausblenden
                        document.querySelectorAll("header .menu-content").forEach(element =&gt; {
                            if (menuState === "menu-open") {
                                element.classList.remove("hidden");
                            } else {
                                element.classList.add("hidden");
                            }
                        });
                    });
                }
                ‚Ä¶
            }
        </code>
    </pre>
    <p>
        In der ersten Zeile holen wir uns das <span class="cmd">&lt;div&gt;</span> mit dem Titel
        in des Hamburger-Icons. F√ºr dieses wird dann ein Event Listener registriert, der bei jedem
        Mausklick (bzw. Touchdruck) auf das Event feuert. Innerhalb der Funktion passiert dann
        folgendes:
    </p>
    <ol>
        <li>
            Zun√§chst wird gepr√ºft, ob die Titelzeile die CSS-Klasse <span class="cmd">inactive</span>
            besitzt. Sie ist bisher noch nicht gesetzt, wird sp√§ter aber immer dann zugewiesen,
            wenn die Anwendung in der vollen Ansicht f√ºr gro√üe Bildschirme dargestellt wird. Ist dies
            der Fall, kann die Funktion direkt wieder verlassen werden.
        </li>
        <li>
            Anschlie√üend wird gepr√ºft, ob das <span class="cmd">&lt;div&gt;</span> die CSS-Klassen
            <span class="cmd">menu-open</span> oder <span class="cmd">menu-closed</span> besitzt,
            je nachdem, ob das Men√º aktuell auf- oder zugeklappt ist. Der dabei gefundene Wert wird
            dann durch den jeweils anderen Wert ersetzt.
        </li>
        <li>
            Zum Schluss werden die einzelnen Men√ºpunkte in Abh√§ngigkeit des eben ermittelten Wertes
            ein- oder ausgeblendet. Dies erfolgt durch Zuweisung der CSS-Klasse <span class="cmd">hidden</span>,
            die in der Datei <span class="fn">src/index.jss</span> definiert ist.
        </li>
    </ol>
    <p>
        Jetzt muss nur noch der Hovereffekt f√ºr die Titelzeile auf gro√üen Bildschirmen
        unterbinden und sichergestellt werden, dass das Men√º in der Smartphone-Ansicht
        zun√§chst immer ausgeblendet ist. Au√üerdem wollen wir das Men√º automatisch
        automatisch aktivieren, wenn sich die Gr√∂√üe des Browserfensters √§ndert und die
        gesamte Ansicht auf den Smartphone-Modus wechselt. Direkt nach dem oben gezeigten
        JavaScript-Code (immer noch im Konstruktor der Klasse <span class="cmd">App</span>)
        muss daher folgender Code eingef√ºgt werden. Der Quellcode sollte an dieser Stelle
        ziemlich selbsterkl√§rend sein:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            class App {
                /**
                 * Konstruktor.
                 */
                constructor() {
                    <b>‚Ä¶ Code von eben ‚Ä¶</b>

                    let _initHamburgerMenu = () =&gt; {
                        // Men√ºbutton auf gro√üen Bildschirmen inaktiv schalten
                        // Klasse .inactive f√ºr das Element mit .hamburger-menu setzen
                        let menuIcon = document.querySelector("header .menu-icon");
                        let largeScreen = true;

                        if (getComputedStyle(menuIcon).display === "none") {
                            menuButton.classList.add("inactive");
                        } else {
                            menuButton.classList.remove("inactive");
                            largeScreen = false;
                        }

                        //  Men√ºeintr√§ge auf kleinen Bildschirmen anfangs ausblenden
                        // und auf gro√üen Bildschirmen immer anzeigen
                        document.querySelectorAll("header .menu-content").forEach(element =&gt; {
                            if (largeScreen) {
                                element.classList.remove("hidden");
                            } else {
                                element.classList.add("hidden");
                            }
                        });
                    };

                    window.addEventListener("resize", () =&gt; {
                        _initHamburgerMenu();
                    });

                    _initHamburgerMenu();
                }
                ‚Ä¶
            }
        </code>
    </pre>
</section>

<!-- ‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì -->
<!-- Sortierung und Suche -->
<!-- ‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì -->
<section data-title="Sortierung und Suche">
    <p class="git-commit">
        Git Commit:
        <a href="https://github.com/DennisSchulmeister/dhbwka-wwi-webprog-my-songbook/tree/c8ce106d0d513ab6121867b2d0b5d7ed0f998ba9" target="_blank">c8ce106</a>
    </p>

    <p>
        Aktuell wird die Songliste auf der √úbersichtsseite immer nach Titel sortiert
        angezeigt. Bei vielen Eintr√§gen ist es aber manchmal besser, die Eintr√§ge
        nach K√ºnstler zu sortieren, oder einen gew√ºnschten Song einfach mal schnell
        suchen zu k√∂nnen. Beides wollen wir deshalb nun ausprogrammieren, wobei wir
        wie immer mit ein paar kleinen Anpassungen am HTML-Code in
        <span class="fn">src/index.html</span> beginnen.
    </p>
    <pre data-gobble>
        <code class="html" data-gobble>
            ‚Ä¶
            &lt;section id="song-overview" class="hidden"&gt;
                &lt;!-- Topbar --&gt;
                &lt;header&gt;
                    &lt;div class="left menu-content"&gt;
                        &lt;div class="item"&gt;
                            &lt;a href="/song/new/" data-navigo&gt;
                                Song hinzuf√ºgen
                            &lt;/a&gt;
                        &lt;/div&gt;
                        <b>&lt;div class="item cmd-sort" data-sort-by="title"&gt;
                            &lt;a&gt;
                                Liste nach Titel sortieren
                            &lt;/a&gt;
                        &lt;/div&gt;
                        &lt;div class="item cmd-sort" data-sort-by="artist"&gt;
                            &lt;a&gt;
                                Liste nach K√ºnstler sortieren
                            &lt;/a&gt;
                        &lt;/div&gt;</b>
                    &lt;/div&gt;
                    &lt;div class="right"&gt;
                        &lt;input <b>class="search"</b> placeholder="Suchen" /&gt;
                    &lt;/div&gt;
                &lt;/header&gt;
                ‚Ä¶
            &lt;/section&gt;
            ‚Ä¶
        </code>
    </pre>
    <p>
        Auf diese Weise haben wir nun zwei Men√ºpunkte zum √Ñndern der Sortierung.
        Mit JavaScript werden wir dann sicherstellen, dass immer nur einer davon
        angezeigt wird, je nachdem wonach die Liste zuletzt sortiert wurde.
        Au√üerdem hat das Suchfeld nun noch eine CSS-Klasse bekommen, durch dies
        einfacher in JavaScript angesprochen werden kann. Wollen wir die entsprechenden
        deshalb gleich mal Anpassungen anschauen. Es beginnt mit ein paar Hilfsvariablen
        im Konstruktor der Klasse <span class="cmd">SongOverview</span> in der
        Datei <span class="fn">src/song-overview/song-overview.js</span>:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            class SongOverview {
                ‚Ä¶
                constructor(app) {
                    this._app = app;

                    // Suche und Sortierung
                    this._order = "";
                    this._sort = "";
                    this._searchTimeout = null;

                    this._sortButtons = null;
                    this._searchField = null;
                    this._listElement = null;
                }
                ‚Ä¶
            }
        </code>
    </pre>
    <p>
        In der Methode <span class="cmd">onShow()</span> entfernen wir die vier Zeilen in der Mitte,
        die sich um den Aufruf der beiden anderen Methoden <span class="cmd">_searchSongs()</span>
        und <span class="cmd">_renderList</span> k√ºmmern, so dass nur noch die erste Zeile und die
        <span class="cmd">return</span>-Anweisung am Ende √ºbrig bleiben. Stattdessen f√ºgen wir folgende
        Zeilen ein:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            async onShow() {
                let section = document.querySelector("#song-overview").cloneNode(true);
                <b>
                this._sortButtons = section.querySelectorAll("header .cmd-sort");
                this._searchField = section.querySelector("header .search");
                this._listElement = section.querySelector("main &gt; ul");

                this._searchAndUpdateView("", "title");
                </b>
                return {
                    className: "song-overview",
                    topbar: section.querySelectorAll("header &gt; *"),
                    main: section.querySelectorAll("main &gt; *"),
                };
            }
        </code>
    </pre>
    <p>
        Wir rufen also nun die neue Methode <span class="cmd">_searchAndUpdateView()</span>
        auf, die wie folgt am Ende der Klasse eingef√ºgt werden kann:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            /**
             * Diese Methode umh√ºllt die beiden Methoden _searchSongs() und
             * _renderList(), um die Liste der darzustellenden Songs zu ermitteln
             * und anzuzeigen. Dabei werden auch die anderen Inhalte der Seite
             * wie die Toolbar oder das Suchfeld aktualisiert.
             *
             * @param  {String} query Suchbegriff
             * @param  {String} sort Sortierung und Gruppierung
             */
            async _searchAndUpdateView(query, sort) {
                // Songs suchen und anzeigen
                this._query = query;
                this._sort = sort;

                let songs = await this._searchSongs(query, sort);
                this._renderList(songs, sort, this._listElement);

                // Sortierbuttons in der Toolbar umschalten
                this._sortButtons.forEach(element =&gt; {
                    if (element.dataset.sortBy === sort) {
                        element.classList.add("hidden");
                    } else {
                        element.classList.remove("hidden");
                    }
                });

                // Text im Suchfeld aktualisieren
                if (!this._searchField.value === query) {
                    this._searchField.value = query;
                }
            }
        </code>
    </pre>
    <p>
        Funktional hat sich dadurch erst mal nichts ver√§ndert. Wir haben jedoch eine
        wunderbare All-In-One-Methode, die immer daf√ºr sorgt, dass alle UI-Elemente
        korrekt dargestellt werden, wenn wir die Sortierung √§ndern oder eine Suche
        ausf√ºhren. Hier werden zum Beispiel die Buttons zum Sortieren der Liste ein-
        und ausgeblendet, je nachdem, welche Sortierung gerade aktiv ist. Aktuell ist
        das noch fest-verdrahtet die Sortierung nach Titel. Wir k√∂nnen nun aber ganz
        einfach einen Event Handler einbauen, um dies zu √§ndern. Hierzu gehen wir
        wieder in die Methode <span class="cmd">onShow()</span> zur√ºck und f√ºgen vor
        den <span class="cmd">return</span>-Anweisung folgende Zeilen hinzu:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            async onShow() {
                <b>‚Ä¶ bisherigen Code bitte stehen lassen ‚Ä¶</b>

                // Event Listener zum Sortieren der Liste
                this._sortButtons.forEach(element =&gt; {
                    element.addEventListener("click", event =&gt; {
                        this._searchAndUpdateView(this._query, element.dataset.sortBy);
                        event.preventDefault();
                    });
                });

                return ‚Ä¶
            }
        </code>
    </pre>
    <p>
        Wir m√ºssen innerhalb des Event Listeners tats√§chlich nur die neue Methode
        <span class="cmd">_searchAndUpdateView()</span> aufrufen und ihr im zweiten
        Parameter den Namen der Sortierspalte mitgeben. Praktischerweise haben wir
        diesen in einem <span class="cmd">data</span>-Attribut bereits im HTML-Code
        hinterlegt, so dass hier nur der Attribut weitergereicht werden muss.
    </p>
    <figure>
        <img src="02/songliste/sortierung-titel.png" class="border" />
        <figcaption>Kennen wir schon: Die Sortierung nach Titel</figcaption>
    </figure>
    <figure>
        <img src="02/songliste/sortierung-artist.png" class="border" />
        <figcaption>Es geht aber auch anders: Hier sortiert nach K√ºnstler</figcaption>
    </figure>

    <p>
        Die Suche funktioniert jetzt dann genau so einfach. Wir m√ºssen einfach an
        derselben Stelle wie eben einen weiteren Event Handler einbauen. Diesen
        programmieren wir so, dass nach jedem Tastendruck sp√§testens nach einer
        halben Sekunde die Suche ausgef√ºhrt wird, stellen dabei aber sicher, dass
        die zeitversetzte Suche nur dann vorgemerkt wird, wenn es nicht bereits
        ohnehin eine Vormerkung gibt. Bei <span class="kbd">Enter</span> wollen
        wir die Suche au√üerdem direkt ausf√ºhren und eine eventuell bestehende
        Vormerkung verwerfen. Der JavaScript-Code hierf√ºr sieht so aus:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            async onShow() {
                <b>‚Ä¶ bisherigen Code bitte stehen lassen ‚Ä¶</b>

                // Event Listener zum Suchen von Songs
                this._searchField.addEventListener("keyup", event =&gt; {
                    if (event.key === "Enter") {
                        // Bei Enter sofort suchen
                        this._searchAndUpdateView(this._searchField.value, this._sort);

                        if (this._searchTimeout) {
                            window.clearTimeout(this._searchTimeout);
                            this._searchTimeout = null;
                        }
                    } else {
                        // Bei sonstigem Tastendruck nur alle halbe Sekunde suchen
                        if (!this._searchTimeout) {
                            this._searchTimeout = window.setTimeout(() =&gt; {
                                this._searchAndUpdateView(this._searchField.value, this._sort);
                                this._searchTimeout = null;
                            }, 500);
                        }
                    }
                });

                return ‚Ä¶
            }
        </code>
    </pre>
    <p>
        Ohne die automatische Suche nach einer halben Sekunde w√§re der Quellcode
        nat√ºrlich etwas k√ºrzer und √ºbersichtlicher. Wirklich kompliziert ist die
        hier gezeigte Version dann aber doch wieder nicht. G√∂nnen wir dem Anwender
        oder der Anwenderin daher den Luxus, auch ohne <span class="kbd">Enter</span>
        zu dr√ºcken suchen zu k√∂nnen.
    </p>
    <figure>
        <img src="02/songliste/suche.png" class="border" />
        <figcaption>Eine Suche noch besser als die von Google ü§£</figcaption>
    </figure>
</section>

<!-- ‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì -->
<!-- Songtexte anzeigen und bearbeiten-->
<!-- ‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì -->
<section data-title="Songtexte anzeigen und bearbeiten">
    <p class="git-commit">
        Git Commit:
        <a href="https://github.com/DennisSchulmeister/dhbwka-wwi-webprog-my-songbook/tree/XXX" target="_blank">XXX</a>
    </p>

    <!--
    Ausprogrammieren der Detailseite zu einem Songtext
    Bearbeitung √ºber contenteditable ohne WYSIWIG-Formatierung
    Buttons zum L√∂schen und Bearbeiten bereits vorsehen
    Bei Klick auf "L√∂schen" direkt l√∂schen und zur√ºck zur √úbersicht
    -->
</section>

<!-- ‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì -->
<!-- Modales Popup vor dem L√∂schen -->
<!-- ‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì -->
<section data-title="Modales Popup vor dem L√∂schen">
    <p class="git-commit">
        Git Commit:
        <a href="https://github.com/DennisSchulmeister/dhbwka-wwi-webprog-my-songbook/tree/XXX" target="_blank">XXX</a>
    </p>

    <!--
    CSS/JS-Code f√ºr einen modalen Dialog
    Eigene Komponente <popup-ask-delete>
    Aufruf des Dialogs an der richtigen Stelle
    -->
</section>

<!-- ‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì -->
<!-- Ein Editor f√ºr alle F√§lle -->
<!-- ‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì -->
<section data-title="Ein Editor f√ºr alle F√§lle">
    <p class="git-commit">
        Git Commit:
        <a href="https://github.com/DennisSchulmeister/dhbwka-wwi-webprog-my-songbook/tree/XXX" target="_blank">XXX</a>
    </p>

    <!--
    Wechsel in den √Ñnderungsmodus der Detailseite
    contenteditable-Attribut f√ºr Titel und Interpret
    Event Handler um ENTER abzufangen (keine neue Zeile bzw. <div> bei ENTER, daf√ºr ins n√§chste Feld springen, event.preventDefaul())
    <textarea> zum Bearbeiten des HTML-Codes des Textes
    Installation von Qilk
    WYSIWIG-Bearbeiten des Textes mit Quilk
    √Ñnderungen sichern bei Okay, Seite neuladen bei Abbrechen
    -->
</section>

<!-- ‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì -->
<!-- Onlinesuche und Anlage eines Songs -->
<!-- ‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì -->
<section data-title="Onlinesuche und Anlage eines Songs">
    <p class="git-commit">
        Git Commit:
        <a href="https://github.com/DennisSchulmeister/dhbwka-wwi-webprog-my-songbook/tree/XXX" target="_blank">XXX</a>
    </p>

    <!--
    Neue <popup-create-song>-Komponente ausprogrammieren (viel Copy & Paste)
    Installation von lyric-get
    Abruf eines Songs mit lyric-get
    Bessere Alternative: Fetch API mit await
    Abruf des Songs mit der Fetch API, Auswerten des JSON-Strings
    Aufruf der Detailseite im Neuanlagemodus
    Hierf√ºr notwendige Anpassungen an der Detailseite
    -->
</section>
