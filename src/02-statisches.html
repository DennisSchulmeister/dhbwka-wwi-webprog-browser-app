<!-- =========================== -->
<!-- VERSION MIT STATISCHEM HTML -->
<!-- =========================== -->
<section data-chapter data-title="Version mit statischem HTML"></section>

<!-- –––––––––––––––––––––––– -->
<!-- Das Grundgerüst entsteht -->
<!-- –––––––––––––––––––––––– -->
<section data-title="Das Grundgerüst entsteht">
    <p class="git-commit">
        Git Commit:
        <a href="https://github.com/DennisSchulmeister/dhbwka-wwi-webprog-my-songbook/tree/abc1fc83de19c5d9f8b666cc4980515335e425be" target="_blank">abc1fc8</a>
    </p>

    <p>
        Bis hierhin sieht unsere App irgendwie noch so gar nicht wie eine App
        aus. Sondern mehr wie eine normale Webseite. Schlimmer noch: Wie ein
        ganz banales „Hallo, Welt!”. An dieser Stelle wollen wir daher das
        Grundlayout der App erstellen, so dass das wir hinterher folgendes
        Ergebnis sehen:
    </p>
    <figure>
        <img src="02/grundstruktur/layout-fertig.jpg" class="border" />
        <figcaption>Das Layout der App, wenn wir hier fertig sind</figcaption>
    </figure>
    <p>
        Der angezeigte Inhalt ist natürlich nur ein Platzhalter und wird überhaupt
        noch nicht in irgend einer Weise dynamisch erzeugt. Wir können ihn deshalb
        einfach direkt in die HTML-Seite schreiben, damit wir beim Erstellen der
        Stylesheets schon etwas sehen.
        Entferne nun also das <span class="cmd">&lt;h1&gt;</span> aus der
        <span class="fn">src/index.html</span> und ersetze es durch folgenden
        Code. Alle anderen Zeilen bleiben unverändert.
    </p>
    <pre data-gobble>
        <code class="html" data-gobble>
            &lt;!-- ========================= --&gt;
            &lt;!-- Grundgerüst der Anwendung --&gt;
            &lt;!-- ========================= --&gt;
            &lt;section id="app"&gt;
                &lt;!-- Topbar --&gt;
                &lt;header&gt;
                    &lt;!-- Obere Zeile (fester Inhalt) --&gt;
                    &lt;div class="top left"&gt;
                        &lt;div class="item inactive"&gt;
                            &lt;b&gt;
                                Beispiel einer Browser App: My Songbook
                            &lt;/b&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                    &lt;div class="top right"&gt;
                        &lt;div class="item"&gt;
                            &lt;a href="https://github.com/DennisSchulmeister/dhbwka-wwi-webprog-my-songbook" target="_blank"&gt;GitHub&lt;/a&gt;
                        &lt;/div&gt;
                        &lt;div class="item"&gt;
                            &lt;a href="https://www.wpvs.de/browser-app/" target="_blank"&gt;Programmieranleitung&lt;/a&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;

                    &lt;!-- Untere Zeile (dynamisch je nach View) --&gt;
                    &lt;div class="bottom left"&gt;
                        &lt;div class="item"&gt;
                            Song hinzufügen
                        &lt;/div&gt;
                        &lt;div class="item"&gt;
                            Sortierung nach Titel
                        &lt;/div&gt;
                    &lt;/div&gt;
                    &lt;div class="bottom right"&gt;
                        &lt;input placeholder="Suchen" /&gt;
                    &lt;/div&gt;
                &lt;/header&gt;

                &lt;!-- Hauptbereich (dynamisch je nach View) --&gt;
                &lt;main&gt;
                    &lt;div class="padding"&gt;
                        Under Construction
                    &lt;/div&gt;
                &lt;/main&gt;
            &lt;/section&gt;
        </code>
    </pre>
    <p>
        Denkt man sich den Dummy-Inhalt weg, lässt sich auch schon der Aufbau
        der Seite erkennen:
    </p>
    <pre data-gobble>
        <code class="html" data-gobble>
            &lt;section id="app"&gt;
                &lt;header&gt;
                    &lt;!-- Obere Zeile (fester Inhalt) --&gt;
                    &lt;div class="top left"&gt;
                        … Inhalt in allen Views identisch …
                    &lt;/div&gt;
                    &lt;div class="top right"&gt;
                        … Inhalt in allen Views identisch …
                    &lt;/div&gt;

                    &lt;!-- Untere Zeile (dynamisch je nach View) --&gt;
                    &lt;div class="bottom left"&gt;
                        …
                    &lt;/div&gt;
                    &lt;div class="bottom right"&gt;
                        …
                    &lt;/div&gt;
                &lt;/header&gt;

                &lt;!-- Hauptbereich (dynamisch je nach View) --&gt;
                &lt;main&gt;
                    …
                &lt;/main&gt;
            &lt;/section&gt;
        </code>
    </pre>
    <p>
        Diese Inhalte müssen wir nun mit den zuvor angelegten Stylesheets in Form bringen,
        da die eingebauten Layoutregeln des Browsers natürlich nicht wie von Zauberhand
        einfach das obigen Layout erzeugen werden. Doch zuvor musst du dir von GitHub
        folgende drei Bilder herunterladen:
    </p>
    <ul>
        <li>
            <a href="https://raw.githubusercontent.com/DennisSchulmeister/dhbwka-wwi-webprog-my-songbook/master/src/favicon.svg" target="_blank">src/favicon.svg</a>: Icon der App
        </li>
        <li>
            <a href="https://raw.githubusercontent.com/DennisSchulmeister/dhbwka-wwi-webprog-my-songbook/master/src/background.jpg" target="_blank">src/background.jpg</a>: Hintergrundbild auf großen Bildschirmen
        </li>
        <li>
            <a href="https://raw.githubusercontent.com/DennisSchulmeister/dhbwka-wwi-webprog-my-songbook/master/src/construction.jpg" target="_blank">src/construction.jpg</a>: Platzhalter im Hauptbereich der App
        </li>
    </ul>
    <p>
        Anschließend lege eine neue Datei namens <span class="fn">src/theme.css</span> und
        folgendem Inhalt an. Sie enthält häufig benötigte
        <a href="https://www.w3schools.com/css/css3_variables.asp" target="_blank">CSS-Variablen</a>,
        die wir an anderer Stelle immer wieder benötigen werden:
    </p>
    <pre data-gobble>
        <code class="css" data-gobble>
            html {
                --font-color:                     black;
                --highlight-background-color:     rgab(235, 235, 235, 1.0);

                --header-normal-background-color: rgba(017,111,159, 1.0);
                --header-normal-font-color:       rgba(255,255,255, 0.8);
                --header-active-background-color: rgba(255,255,255, 0.2);
                --header-active-font-color:       rgba(255,255,255, 0.9);
            }
        </code>
    </pre>
    <p>
        Damit haben wir erst einmal alle Dateien beisammen. Die Verzeichnisstruktur sollte jetzt
        wie in der nächsten Abbildung bei dir aussehen:
    </p>
    <figure>
        <img src="02/grundstruktur/alle-dateien.png" />
        <figcaption>Verzeichnisstruktur der Webanwendung an dieser Stelle</figcaption>
    </figure>
    <p>
        Damit das neue Stylesheet nun aber auch wirken kann, muss es erst noch importiert werden.
        Ändere deshalb den Import des alten Stylesheets in der <spann class="fn">src/index.js</spann>
        zu folgenden zwei Zeilen ab. Achte dabei aber darauf, wirklich erst die Datei
        <span class="fn">./index.css</span> und dann die Datei <span class="fn">./theme.css</span>
        zu importieren:
    </p>
    <pre data-gobble>
        <code class="js" data-gobble>
            import stylesheet from "./index.css";
            import theme from "./theme.css";
        </code>
    </pre>
    <p>
        Der Inhalt der Datei <span class="fn">src/index.css</span> ändert sich nun komplett
        zu folgenden Zeilen. Zunächst ein paar allgemeine Definitionen:
    </p>
    <pre data-gobble>
        <code class="css" data-gobble>
            /*
             * Dieses Stylesheet enthält nur allgemeine Anweisungen, die sich auf die
             * gesamte App auswirken. Hier dürfen keine Änderungen vorgenommen werden,
             * die sich nur auf bestimmte Bereiche der Anwendung auswirken sollen.
             *
             * Damit @import funktioniert, muss die Anweisung vor allen anderen
             * CSS-Anweisungen stehen. Dieses Stylesheet muss daher auch vor allen
             * anderen importiert werden.
             */
            @import url('https://fonts.googleapis.com/css?family=Roboto');

            html, body {
                padding: 0;
                margin: 0;
                height: 100%;
            }

            body {
                font-family: 'Roboto', sans-serif;
                font-size: 11pt;
                line-height: 1.6;
                color: var(--font-color);
            }
        </code>
    </pre>

    <p>
        Dann ein paar Anpassungen der Schriftgröße je nach Bildschirmauflösung:
    </p>
    <pre data-gobble>
        <code class="css" data-gobble>
            /*
             * Größere Schrift auf größeren Bildschirmen
             * Vgl. https://getbootstrap.com/docs/4.0/layout/overview/#responsive-breakpoints
             */
            @media screen and (min-width: 768px) {
                body,
                input {
                    font-size: 12pt;
                }
            }

            @media screen and (min-width: 992px) {
                body,
                input {
                    font-size: 13pt;
                }
            }

            @media screen and (min-width: 1200px) {
                body,
                input {
                    font-size: 14pt;
                }
            }
        </code>
    </pre>

    <p>
        Und zum Schluss wie immer ein Media Query, um auf großen Bildschirmen
        die Darstellung zu optimieren, sowie ein paar nützliche Helferlein:
    </p>
    <pre data-gobble>
        <code class="css" data-gobble>
            /*
             * Flächendeckender Seitenhintergrund auf großen Bildschirmen
             */
            @media (min-width: 80em) {
                /* Hintergrundbild hinter dem Hauptbereich der App */
                html {
                    /* https://pixabay.com/de/computer-notebook-kaffee-820281/ */
                    background-image: url(background.jpg);
                    background-attachment: fixed;
                    background-size: cover;
                    background-position: center;
                }

                /* Hauptbereich der App vergrößern */
                body {
                    display: flex;
                    align-items: stretch;
                    justify-content: center;
                }

                body > * {
                    flex: 1;
                }
            }

            /*
             * Häufig benötigte Hilfsklassen
             */
            .hidden {
                display: none;
            }

            .padding {
                padding: 0.5rem;
            }
        </code>
    </pre>

    <p>
        Wie du (hoffentlich) siehst, werden hier wirklich nur ganz allgemeine Dinge
        geregelt, die sich auf die gesamte App auswirken. Spezifische Anpassungen
        für einen einzelnen Bereich werden stattdessen in getrennten Stylesheets
        vorgenommen, wobei es im Grunde genommen je JavaScript-Datei eine gleichnamige
        CSS-Datei gibt. Die Datei
        <span class="fn">src/app.css</span> beginnt daher wie immer mit ein paar
        allgemeinen Definitionen:
    </p>
    <pre data-gobble>
        <code class="css" data-gobble>
            /*
             * Dieses Stylesheet darf nur Selektoren beinhalten, die mit #app beginnen.
             * Denn wir wollen nicht, dass hier Eigenschaften aus anderen Bereichen der
             * Anwendung überschrieben werden.
             */
            #app {
                background-color: white;
                flex: 1;
            }
        </code>
    </pre>
    <p>
        Daraufhin folgt eine große Zahl an Regeln zur Gestaltung des Kopfbereichs.
        Auch sie fangen alle mit <span class="cmd">#app</span> an, um ihre Gültigkeit
        zu begrenzen:
    </p>
    <pre data-gobble>
        <code class="css" data-gobble>
            /*
             * Kopfbereich über dem Inhalt
             */
            #app header {
                background-color: var(--header-normal-background-color);
                color: var(--header-normal-font-color);
            }

            #app header > *,
            #app header input,
            #app header .item {
                display: block;
                box-sizing: border-box;
                width: 100%;
            }

            #app header > .top {
                font-size: 80%;

                border: 0px solid var(--header-active-background-color);
                border-bottom-width: 1px;
            }

            #app header > .top .item,
            #app header > .top input {
                padding: 0.5rem;
            }

            #app header > .bottom {
                border: 0px solid var(--header-active-background-color);
                border-bottom-width: 1px;
            }

            #app header > .bottom .item,
            #app header > .bottom input {
                padding: 1rem 0.5rem 1rem 0.5rem;
            }

            #app header .active,
            #app header .item:not(.inactive):hover {
                background-color: var(--header-active-background-color);
                color: var(--header-active-font-color);
            }

            #app header .item:not(.inactive) {
                cursor: pointer;
            }

            #app header a,
            #app header a:visited {
                color: var(--header-normal-font-color);
                text-decoration: none;
            }

            #app header a:hover {
                color: var(--header-active-font-color);
                text-decoration: underline;
            }

            #app header input {
                background: none;
                color: var(--header-normal-font-color);
                border: 0;
            }
        </code>
    </pre>

    <p>
        Dann wieder etwas temporärer Inhalt, um das Baustellenbild beim Aufruf
        der App anzuzeigen 🚧 und einen kleinen Hinwestext in der Mitte zu
        platzieren:
    </p>
    <pre data-gobble>
        <code class="css" data-gobble>
            /*
             * Hauptinhalt
             */
            #app main {
                /*
                 * Temporärer Inhalt, solange es noch keinen richtigen Inhalt gibt
                 * Bild: https://pixabay.com/de/handwerker-baustelle-arbeiter-3094035/
                 */
                background-image: url(construction.jpg);2
                background-size: 100% auto;
                background-position: bottom center;
                background-repeat: no-repeat;

                color: rgb(255, 246, 23);
                text-shadow: 1px 1px 2px black;
                font-size: 300%;
                font-weight: bold;
                text-align: center;
            }
        </code>
    </pre>
    <p>
        Und zum Schluß wie immer die Anpassung an große Bildschirme. Die Angabe
        <span class="cmd">(min-width: 80em)</span> in der fünften Zeile muss
        exakt mit dem Media Query in der <span class="fn">src/index.css</span>
        stehen, damit die Darstellung in jedem Fall passt:
    </p>
    <pre data-gobble>
        <code class="css" data-gobble>
            /*
             * Anpassung an große Bildschirme, sobald in der index.css das große
             * Hintergrundbild eingeschaltet wird
             */
            @media screen and (min-width: 80em) {
                /* Rahmen um den Hauptbereich zeichnen */
                #app {
                    max-width: 80em;
                    margin-top: 2em;
                    margin-bottom: 2em;

                    border: 1px solid rgba(32,32,32, 0.2);
                    box-shadow: 1px 1px 3px rgba(0,0,0, 0.1);
                }

                /* Topbar- und Toolbar-Inhalte nebeneinander */
                #app header {
                    display: grid;
                    grid-template-columns: auto 20em;
                }

                #app header .top {
                    grid-row: 1;
                }

                #app header .bottom {
                    grid-row: 2;
                }

                #app header .left {
                    grid-column: 1;

                    display: flex;
                    justify-content: flex-start;
                }

                #app header .right{
                    grid-column: 2;

                    display: flex;
                    justify-content: flex-start;

                    background-color: var(--header-active-background-color);
                    color: var(--header-active-font-color);
                }

                #app header .item {
                    width: auto;
                }

                /* Nur den Bereich unterhalb der Toolbar scrollen */
                #app {
                    display: flex;
                    flex-direction: column;
                }

                #app > main {
                    flex: 1;
                    overflow: auto;
                }
            }
        </code>
    </pre>
    <p>
        Und das war es dann auch schon. Zugegeben war das jetzt zwar extrem viel Copy &amp; Paste.
        Auf dieser Grundlage können wir der App im nächsten Schritt nun aber ein wenig Leben einhauchen.
    </p>
</section>

<!-- –––––––––––––––––––––––––––– -->
<!-- Navigation innerhalb der App -->
<!-- –––––––––––––––––––––––––––– -->
<section data-title="Navigation innerhalb der App">
    <p class="git-commit">
        Git Commit:
        <a href="https://github.com/DennisSchulmeister/dhbwka-wwi-webprog-my-songbook/tree/1451b1db51fce4657c253f3d3b1fe733139edcd7" target="_blank">1451b1d</a>
    </p>

    <p>
        Rein visuell sieht unsere Seite jetzt schon viel mehr wie eine App aus. Man kann aber noch
        nichts anklicken, weshalb es sich im Grunde genommen immer noch um eine statische HTML-Seite
        handelt. An dieser Stelle wollen wir daher das Grundgerüst etwas erweitern und eine einfache
        Navigation ermöglichen. Dadurch soll es möglich sein, zwischen der Übersichtsseite (die wir
        an dieser Stelle immer noch nicht mit Inhalt füllen werden) und der späteren Detailseite
        umzuschalten, so dass wir dann endgültig von einer echten Browser App sprechen können. Denn
        im Gegensatz zu einer serverseitigen Webanwendung soll das hin und her Schalten zwischen den
        Seiten komplett im Browser geschehen, ohne hierfür eine neue Seite vom Server anzufordern.
    </p>

    <h3>Umstrukturierung des HTML-Codes</h3>
    <p>
        Im ersten Schritt müssen wir die Datei <span class="fn">src/index.html</span> so umbauen,
        dass jeder Bereich der App eine eigene <span class="cmd">&lt;section&gt;</span> bekommt,
        die wir über eine eindeutige Id adressieren können. Allerdings sollen diese neuen Bereiche
        nicht sichtbar sein, da wir sonst ja nicht zwischen den einzelnen Bereichen umherschalten
        könnten. Die CSS-Klasse <span class="cmd">hidden</span> stellt deshalb sicher, dass wirklich
        nur die erste <span class="cmd">&lt;section id="app"&gt;</span> mit dem Anwendungsrahmen
        und sonst nichts angezeigt wird.
    </p>
    <pre data-gobble>
        <code class="html" data-gobble>
            &lt;!DOCTYPE html&gt;
            &lt;html&gt;
                &lt;head&gt;
                    &lt;meta charset="utf-8" /&gt;
                    &lt;title>My Songbook&lt;/title&gt;
                    &lt;link rel="shortcut icon" href="favicon.svg"&gt;

                    &lt;script src="index.js"&gt;&lt;/script&gt;
                &lt;/head&gt;
                &lt;body&gt;
                    &lt;!-- ========================= --&gt;
                    &lt;!-- Grundgerüst der Anwendung --&gt;
                    &lt;!-- ========================= --&gt;
                    &lt;section id="app"&gt;
                        …
                    &lt;/section&gt;

                    &lt;!-- ====================== --&gt;
                    &lt;!-- View: Vorhandene Songs --&gt;
                    &lt;!-- ====================== --&gt;
                    &lt;section id="song-overview" class="hidden"&gt;
                        …
                    &lt;/section&gt;

                    &lt;!-- ================================== --&gt;
                    &lt;!-- View: Song anzeigen und bearbeiten --&gt;
                    &lt;!-- ================================== --&gt;
                    &lt;section id="song-display-edit" class="hidden"&gt;
                        …
                    &lt;/section&gt;
                &lt;/body&gt;
            &lt;/html&gt;
        </code>
    </pre>
    <p>
        Anschließend können wir den Dummy-Inhalt aus dem Grundgerüst wieder entfernen, so dass
        davon nur folgende Zeile übrig bleiben. Den festen Inhalt der Topbar, der wirklich immer zu
        sehen sein woll, behalten wir hier natürlich bei.
    </p>
    <pre data-gobble>
        <code class="html" data-gobble>
            &lt;!-- ========================= --&gt;
            &lt;!-- Grundgerüst der Anwendung --&gt;
            &lt;!-- ========================= --&gt;
            &lt;section id="app"&gt;
                &lt;!-- Topbar --&gt;
                &lt;header&gt;
                    &lt;!-- Obere Zeile (fester Inhalt) --&gt;
                    &lt;div class="top left"&gt;
                        &lt;div class="item inactive"&gt;
                            &lt;b&gt;
                                Beispiel einer Browser App: My Songbook
                            &lt;/b&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                    &lt;div class="top right"&gt;
                        &lt;div class="item"&gt;
                            &lt;a href="https://github.com/DennisSchulmeister/dhbwka-wwi-webprog-my-songbook" target="_blank"&gt;GitHub&lt;/a&gt;
                        &lt;/div&gt;
                        &lt;div class="item"&gt;
                            &lt;a href="https://www.wpvs.de/browser-app/" target="_blank"&gt;Programmieranleitung&lt;/a&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;

                    &lt;!-- Untere Zeile (dynamisch je nach View) --&gt;
                &lt;/header&gt;

                &lt;!-- Hauptbereich (dynamisch je nach View) --&gt;
                &lt;main&gt;
                &lt;/main&gt;
            &lt;/section&gt;
        </code>
    </pre>
    <p>
        Den eben entfernten HTML-Code bauen wir stattdessen weiter unten in die <span class="cmd">&lt;section&gt;</span>
        für die Übersichtsseite wieder ein.¹
    </p>
    <pre data-gobble>
        <code class="html" data-gobble>
            &lt;!-- ====================== --&gt;
            &lt;!-- View: Vorhandene Songs --&gt;
            &lt;!-- ====================== --&gt;
            &lt;section id="song-overview" class="hidden"&gt;
                &lt;!-- Topbar --&gt;
                &lt;header&gt;
                    &lt;div class="left"&gt;
                        &lt;div class="item new-song"&gt;
                            Song hinzufügen
                        &lt;/div&gt;
                        &lt;div class="item"&gt;
                            Sortierung nach Titel
                        &lt;/div&gt;
                    &lt;/div&gt;
                    &lt;div class="right"&gt;
                        &lt;input placeholder="Suchen" /&gt;
                    &lt;/div&gt;
                &lt;/header&gt;

                &lt;!-- Hauptbereich --&gt;
                &lt;main&gt;
                    &lt;div class="padding"&gt;
                        Übersicht
                    &lt;/div&gt;
                &lt;/main&gt;
            &lt;/section&gt;
        </code>
    </pre>
    <p>
        ¹
        <small>
            Die CSS-Klasse <span class="cmd">bottom</span> für die beiden <span class="cmd">&lt;div&gt;</span>
            in der Topbar haben wir hier absicshtlich weggelassen. Doch dazu später mehr.
        </small>
    </p>
    <p>
        Und auch die Detailseite gestalten wir ähnlich, da sie zur diesem Zeitpunkt natürlich auch noch keinen
        wirklichen Inhalt besitzt. Immerhin bekommt sie in der Topbar jedoch bereits einen Eintrag, mit dem der
        Anwender zurück auf die Übersichtsseite gelangen soll.
    </p>
    <pre data-gobble>
        <code class="html" data-gobble>
            &lt;!-- ================================== --&gt;
            &lt;!-- View: Song anzeigen und bearbeiten --&gt;
            &lt;!-- ================================== --&gt;
            &lt;section id="song-display-edit" class="hidden"&gt;
                &lt;!-- Topbar --&gt;
                &lt;header&gt;
                    &lt;div class="left"&gt;
                        &lt;!-- Leer --&gt;
                    &lt;/div&gt;
                    &lt;div class="right"&gt;
                        &lt;div class="item overview"&gt;
                            Zurück zur Übersicht
                        &lt;/div&gt;
                    &lt;/div&gt;
                &lt;/header&gt;

                &lt;!-- Hauptbereich --&gt;
                &lt;main&gt;
                    &lt;div class="padding"&gt;
                        Song anzeigen/bearbeiten
                    &lt;/div&gt;
                &lt;/main&gt;
            &lt;/section&gt;
        </code>
    </pre>

    <h3>Austausch der sichtbaren Inhalte mit JavaScript</h3>
    <p>
        Mit diesen Änderungen nun an Ort und Stelle können wir uns an die Ausprogrammierung der
        <span class="cmd">App</span>-Klasse innerhalb der Datei <span class="fn">src/app.js</span>
        machen. Denn sie soll für die Navigation innerhalb der App zuständig sein und zwischen den
        verschiedenen Ansichten umschalten. Die eigentliche Arbeit macht dabei die folgende, neue
        Methode, wobei der Unterstrich am Anfang des Namens ausdrückt, dass sie nur innerhalb der
        Klasse selbst aufgerufen werden sollte. Erzwungen wird das von JavaScript allerdings nicht.
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            /**
             * Auswechseln des sichtbaren Inhalts der App. Hierfür muss der Methode
             * ein Objekt mit folgendem Aufbau übergeben werden:
             *
             *   {
                    className: "CSS-Klassenname",
             *      topbar: [DOM Element, DOM Element, DOM Element, ...],
             *      main: [DOM Element, DOM Element, DOM Element, ...],
             *   }
             *
             * Beide Attribute (topbar und main) sind optional, was dazu führt, dass
             * im jeweiligen Bereich einfach nichts angezeigt wird. Werden sie jedoch
             * mitgegeben, müssen sie mit forEach(element =&gt; { … }) iteriert werden
             * können, um ihren Inhalt in den DOM-Baum zu integrieren.
             *
             * Wichtig ist, dass die übergebenen Elemente noch an keiner Stelle im
             * DOM vorhanden sein dürfen. Werden die Elemente in der index.html
             * als Vorlage definiert, muss hier deshalb eine Kopie anstelle der
             * Elemente selbst übergeben werden!
             *
             * @param {Object} content Objekt mit den anzuzeigenden DOM-Elementen
             */
            _switchVisibleContent(content) {
                // &lt;header&gt; und &lt;main&gt; des HTML-Grundgerüsts ermitteln
                let app = document.querySelector("#app");
                let header = document.querySelector("#app &gt; header");
                let main = document.querySelector("#app &gt; main");

                // Zuvor angezeigte Inhalte entfernen
                // Bei der Topbar nur die untere Zeile, im Hauptbereich alles!
                app.className = "";
                header.querySelectorAll(".bottom").forEach(e =&gt; e.parentNode.removeChild(e));
                main.innerHTML = "";

                // CSS-Klasse übernehmen, um die viewspezifischen CSS-Regeln zu aktivieren
                if (content && content.className) {
                    app.className = content.className;
                }

                // Neue Inhalte der Topbar einfügen
                if (content && content.topbar) {
                    content.topbar.forEach(element =&gt; {
                        element.classList.add("bottom");
                        header.appendChild(element);
                    });
                }

                // Neue Inhalte des Hauptbereichs einfügen
                if (content && content.main) {
                    content.main.forEach(element =&gt; {
                        main.appendChild(element);
                    });
                }
            }
        </code>
    </pre>
    <p>
        Der Quellcode ist im Grunde genommen nicht sehr kompliziert. Dennoch sollten wir ihn an dieser
        Stelle kurz durchgehen, um sicherzustellen, dass du ihn wirklich verstehst:
    </p>
    <ol>
        <li>
            Zunächst greift die Methode auf das DOM zu, um sich die
            <span class="cmd">&lt;section id="app"&gt;</span> sowie die darin enthaltenen
            <span class="cmd">&lt;header&gt;</span>- und
            <span class="cmd">&lt;main&gt;</span>-Elemente zu besorgen.
        </li>
        <li>
            Anschließend werden die zuvor sichtbaren Inhalte verworfen. Im Falle der
            Topbar mit einer <span class="cmd">forEach()</span>-Schleife, die nur
            die Elemente der unteren Zeile erwischt. Und im Hauptbereich durch
            Überschreiben des <spann class="cmd">innerHTML</spann>-Attributs,
            was de facto seinen kompletten Inhalt löscht.
        </li>
        <li>
            Dann wird mit einer <span class="cmd">if</span>-Abfrage gebprüft, ob
            ob das <span class="cmd">content</span>-Objekt ein Attribut mit dem
            Namen <span class="cmd">classList</span> enthält. Falls ja wird die
            CSS-Klasse des <span class="cmd">&lt;section id="app"&gt;</span>
            entsprechend abgeändert, damit etwaige CSS-Regeln, die sich auf
            diese Klasse beziehen, wirksam werden können.
        </li>
        <li>
            Danach wird geprüft, ob ein neuer Inhalt für die Topbar übergeben wurde.
            Falls ja, wird in einer Schleife über die neuen Topbar-Elemente jedem
            Element die CSS-Klasse <span class="cmd">bottom</span> hinzugefügt
            und die Elemente an den <span class="code">&lt;header&gt;</span>
            angehängt.
        </li>
        <li>
            Dann erfolgt mit einer ähnlichen Abfrage eine Prüfung für den Hauptbereich
            der App, nur dass den Elementen hier keine zusätzliche CSS-Klasse mitgegeben
            werden muss.
        </li>
    </ol>

    <p>
        Auf diese Weise können wir nun den angezeigten Inhalt der App variieren. Wirklich
        anwenderfreundlich ist die neue Methode aber noch nicht, da wir ihr, um eine neue
        Seite anzuzeigen, genau die hierfür notwendigen DOM-Elemente mitgegeben müssen.
        Besser wäre es jedoch, wenn wir eine bestimmte Seite einfach aufrufen könnten,
        ohne genau zu wissen, wie die Seite eigentlich aufgebaut ist. Wir benötigen daher
        für jede Seite eine weitere Methode, die genau diesen Zweck erfüllt. Doch hierfür
        müssen wir uns erst noch überlegen, wie wir den Quellcode der App weiter strukturieren
        wollen.
    </p>

    <h3>Eine Klasse je Bildschirmseite</h3>
    <p>
        Natürlich könnten wir die komplette Anwendungslogik einfach in der Datei <span class="fn">src/app.js</span>
        oder sogar nur in der Klasse <span class="fn">App</span> ausprogrammieren. Dem Computer wäre das
        ziemlich gleich. Allerdings wissen wir, dass die beiden Seiten mit der Übersicht und zur Anzeige
        eines Songtextes nicht wirklich viel gemeinsam haben. Alles in eine Klasse zu packen wäre daher
        ziemlich unübersichtlich. Das alte Sprichwort „teile und herrsche” liefert stattdessen viel bessere
        Ergebnisse, da es uns an die
        <a href="https://t3n.de/news/prinzipien-software-entwicklung-solid-615556/" target="_blank">SOLID-Kriterien</a>
        und hier insbesondere an das Single-Responsibility-Prinzip erinnert. Es liegt deshalb nahe, für
        jede Bildschirmseite eine eigene Klasse vorzusehen. Und für jede Klasse dementsprechend eine
        eigene JavaScript-Datei und ein eigenes Stylesheet, die wir um die Übersichtlichkeit noch
        weiter zu erhöhen, jeweils in ein eigenes Verzeichnis packen.
    </p>
    <p>
        Bevor wir also weiter programmieren, lege zunächst folgende Dateistruktur an. Die Dateien
        können dabei an dieser Stelle noch leer bleiben:
    </p>
    <ul>
        <li>
            <span class="fn">src/song-overview/song-overview.js:</span> Klasse <span class="cmd">SongOverview</span> für die Übersichtsseite
        </li>
        <li>
            <span class="fn">src/song-overview/song-overview.css:</span> Stylesheet für die Übersichtsseite
        </li>
        <li>
            <span class="fn">src/song-display-edit/song-display-edit.js:</span> Klasse <span class="cmd">SongDisplayEdit</span> für die Detailseite
        </li>
        <li>
            <span class="fn">src/song-display-edit/song-display-edit.css:</span> Stylesheet für die Detailseite
        </li>
    </ul>
    <p>
        Das Ergebnis sollte dementsprechend so aussehen:
    </p>
    <figure>
        <img src="02/navigation/neue-dateien.png" />
        <figcaption>Erweiterte Verzeichnisstruktur für die Übersichts- und die Detailseite</figcaption>
    </figure>
    <p>
        Die beiden Stylesheets sind am einfachsten. Hier wollen wir zunächst nur etwas Dummy-Inhalt
        einbauen, damit wir später sehen, ob sie auch wirklich ausgewertet werden. Füge daher in die
        Datei <span class="fn">src/song-overview/song-overview.css</span> folgende Zeile ein:
    </p>
    <pre data-gobble>
        <code class="css" data-gobble>
            /*
             * Dieses Stylesheet darf nur Selektoren beinhalten, die mit .song-overview
             * beginnen. Denn wir wollen nicht, dass hier Eigenschaften aus anderen Bereichen
             * der Anwendung überschrieben werden.
             */
            .song-overview main {
                color: orangered !important;
            }
        </code>
    </pre>
    <p>
        Und in die <span class="fn">src/song-display-edit/song-display-edit.css</span> folgende Zeilen:
    </p>
    <pre data-gobble>
        <code class="css" data-gobble>
            /*
             * Dieses Stylesheet darf nur Selektoren beinhalten, die mit .song-display-edit
             * beginnen. Denn wir wollen nicht, dass hier Eigenschaften aus anderen Bereichen
             * der Anwendung überschrieben werden.
             */
            .song-display-edit main {
                color: orchid !important;
            }
        </code>
    </pre>
    <p>
        Bei den beiden Klassen wird es hingegen schon interessanter, da wir uns noch gar
        keine Gedanken darüber gemacht haben, welche Methoden sie besitzen sollen und zu
        welchem sie aufgerufen werden. Letztlich gibt es auch gar keine universelle Lösung
        hierfür, in der Praxis hat sich aber ganz unabhängig von der Art der Anwendung oder
        der verwendeten UI-Technologie folgende, einfache Struktur bewährt:
    </p>
    <ol>
        <li>
            Jedes Mal, wenn eine Seite aufgerufen wird, wird ein neues Objekt der dazugehörigen
            Klasse erzeugt. Das Objekt bleibt dabei so lange aktiv, wie die Seite sichtbar ist.
        </li>
        <li>
            Wird von einer Seite auf dieselbe Seite nur mit anderen Daten gewechselt (zum Beispiel
            von der Detailseite eines Songs zur Detailseite eines anderen Songs), wird hierfür
            ebenfalls ein neues Objekt erzeugt.
        </li>
        <li>
            Denn dies ermöglicht es, die Klassen einfach zu halten und für die Anzeige benötigte
            Informationen wie die Song-ID einfach dem Konstruktor zu übergeben.
        </li>
        <li>
            Bevor eine neue Seite aufgerufen wird, wird die Methode <span class="cmd">onShow()</span>
            des jeweiligen Objekts aufgerufen.
        </li>
        <li>
            Davor wird jedoch erst die Methode <span class="cmd">onLeave()</span> der aktuell sichtbaren
            Seite aufgerufen, um ihr die Möglichkeit zu geben, Aufräumarbeiten durchzuführen oder den
            Seitenwechsel zu unterbinden.
        </li>
        <li>
            Eine Methode mit dem Namen <span class="cmd">getTitle()</span> gibt den Titel der aktuellen
            Seite zurück, um ihn in der Titelzeile des Browserfensters anzuzeigen.
        </li>
        <li>
            Sobald eine Seite verlassen wurde, kann das dazugehörige Objekt abgeräumt werden.
        </li>
    </ol>
    <p>
        Damit haben wir einen klaren Lebenszyklus definiert, der genau vorschreibt, zu welchem Zeitpunkt
        neue Objekte entstehen, welche Methoden dementsprechend aufgerufen werden und wann die Objekte
        wieder verschwinden. Außerdem haben wir eine Möglichkeit geschaffen, besondere Fälle wie das
        Vorliegen nicht gespeicherter Daten abzufangen, bei denen wir den Anwender erst fragen müssen,
        ob er seine Änderungen sichern will, oder wir den Aufruf der Folgeseite ganz einfach unterbinden.
    </p>
    <p>
        Die Datei <span class="fn">src/song-overview/song-overview.js</span> soll dementsprechend
        folgenden Inhalt besitzen.
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            "use strict";

            import stylesheet from "./song-overview.css";

            /**
             * View mit der Übersicht der vorhandenen Songs.
             */
            class SongOverview {
                /**
                 * Konstruktor.
                 * @param {Objekt} app Zentrales App-Objekt der Anwendung
                 */
                constructor(app) {
                    this._app = app;
                }

                /**
                 * Von der Klasse App aufgerufene Methode, um die Seite anzuzeigen. Die
                 * Methode gibt daher ein passendes Objekt zurück, das an die Methode
                 * _switchVisibleContent() der Klasse App übergeben werden kann, um ihr
                 * die darzustellenden DOM-Elemente mitzuteilen.
                 *
                 * @return {Object} Darzustellende DOM-Elemente gemäß Beschreibung der
                 * Methode App._switchVisibleContent()
                 */
                onShow() {
                    // Machen wir gleich
                }

                /**
                 * Von der Klasse App aufgerufene Methode, um festzustellen, ob der Wechsel
                 * auf eine neue Seite erlaubt ist. Wird hier true zurückgegeben, wird der
                 * Seitenwechsel ausgeführt.
                 *
                 * @param  {Function} goon Callback, um den Seitenwechsel zu einem späteren
                 * Zeitpunkt fortzuführen, falls wir hier false zurückgeben
                 * @return {Boolean} true, wenn der Seitenwechsel erlaubt ist, sonst false
                 */
                onLeave(goon) {
                    return true;
                }

                /**
                 * @return {String} Titel für die Titelzeile des Browsers
                 */
                get title() {
                    return "Übersicht";
                }
            }

            export default SongOverview;
        </code>
    </pre>
    <p>
        Die Datei <span class="fn">src/song-display-edit/song-display-edit.js</span> soll hingegen
        folgenden Inhalt besitzen:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            "use strict";

            import stylesheet from "./song-display-edit.css";

            /**
             * View zur Anzeige oder zum Bearbeiten eines Songs.
             */
            class SongDisplayEdit {
                /**
                 * Konstruktor.
                 *
                 * @param {Objekt} app Zentrales App-Objekt der Anwendung
                 * @param {String} id   ID des darzustellenden Songs
                 * @param {String} mode "new", "display" oder "edit"
                 */
                constructor(app, id, mode) {
                    this._app = app;
                    this._id = id;
                    this._mode = mode;
                }

                /**
                 * Von der Klasse App aufgerufene Methode, um die Seite anzuzeigen. Die
                 * Methode gibt daher ein passendes Objekt zurück, das an die Methode
                 * _switchVisibleContent() der Klasse App übergeben werden kann, um ihr
                 * die darzustellenden DOM-Elemente mitzuteilen.
                 *
                 * @return {Object} Darzustellende DOM-Elemente gemäß Beschreibung der
                 * Methode App._switchVisibleContent()
                 */
                onShow() {
                    // Machen wir gleich
                }

                /**
                 * Von der Klasse App aufgerufene Methode, um festzustellen, ob der Wechsel
                 * auf eine neue Seite erlaubt ist. Wird hier true zurückgegeben, wird der
                 * Seitenwechsel ausgeführt.
                 *
                 * @param  {Function} goon Callback, um den Seitenwechsel zu einem späteren
                 * Zeitpunkt fortzuführen, falls wir hier false zurückgeben
                 * @return {Boolean} true, wenn der Seitenwechsel erlaubt ist, sonst false
                 */
                onLeave(goon) {
                    return true;
                }

                /**
                 * @return {String} Titel für die Titelzeile des Browsers
                 */
                get title() {
                    switch (this._mode) {
                        case "new":
                            return "Song hinzufügen";
                        case "edit":
                            return "Song bearbeiten";
                        default:
                            return "Song anzeigen";
                    }
                }
            }

            export default SongDisplayEdit;
        </code>
    </pre>

    <h3>Weitere Methoden für die Klasse App</h3>
    <p>
        Da der Vertrag mit dem View-Klassen nun klar ist, besitzen wir alle Informationen, um die
        Klasse <span class="cmd">App</span> nun zu Ende zu programmieren. Füge deshalb über der
        Methode <span class="cmd">_switchVisibleContent()</span> eine neue Methode mit dem Namen
        <span class="cmd">_switchVisibleView()</span> ein, die sie aufruft und hierfür ein
        View-Objekt entgegen nimmt:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            /**
             * Hilfsklasse zum Umschalten auf eine neue Seite. Sie ruft zunächst die
             * Methode onLeave() der gerade sichtbaren View auf und prüft damit, ob
             * die View verlassen werden kann. Falls ja ruft sie die Methode onShow()
             * der neuen View auf und übergibt das Ergebnis an die eigene Methode
             * _switchVisibleContent(), um den sichtbaren Inhalt der Seite auszutauschen.
             *
             * @param  {Object} view View-Objekt mit einer onShow()-Methode
             * @return {Boolean} Flag, ob die neue Seite aufgerufen werden konnte
             */
            _switchVisibleView(view) {
                // Callback, mit dem die noch sichtbare View den Seitenwechsel zu einem
                // späteren Zeitpunkt fortführen kann, wenn sie in der Methode onLeave()
                // false zurückliefert. Dadurch erhält sie die Möglichkeit, den Anwender
                // zum Beispiel zu fragen, ob er ungesicherte Daten speichern will,
                // bevor er die Seite verlässt.
                let goon = () =&gt; this._switchVisibleView(view);

                // Aktuelle View fragen, ob eine neue View aufgerufen werden darf
                if (this._currentView && !this._currentView.onLeave(goon)) {
                    return false;
                }

                // Alles klar, aktuelle View nun wechseln
                document.title = `${this._title} – ${view.title}`;

                this._currentView = view;
                this._switchVisibleContent(view.onShow());
                return true;
            }

            /**
             * …
             */
            _switchVisibleContent(content) {
                …
            }
        </code>
    </pre>
    <p>
        Die zwei Instanzattribute <span class="cmd">this._currentView</span> und
        <span class="cmd">this._title</span> müssen hierfür im Konstruktor definiert
        werden:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            /**
             * Konstruktor.
             */
            constructor() {
                this._title = "My Songbook";
                this._currentView = null;
            }
        </code>
    </pre>
    <p>
        Und damit das Ganze einfach zu verwenden ist, legen wir nun für jede Seite eine
        eigene, für die öffentliche Verwendung freigebene Methode an, mit der sie überall
        in der App aufgerufen werden kann. Die Methode <span class="cmd">start()</span>
        passen bei der Gelegenheit dann auch gleich noch an, damit beim Aufruf der App
        immer die Überssichtsseite geladen wird:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            …
            import SongDisplayEdit from "./song-display-edit/song-display-edit.js";
            import SongOverview from "./song-overview/song-overview.js";

            /**
             * …
             */
            class App {
                …

                /**
                 * Ab hier beginnt die Anwendung zu laufen.
                 */
                start() {
                    this.showSongOverview();
                }

                /**
                 * Aufruf der Übersichtsseite der vorhandenen Songs.
                 * @return {Boolean} Flag, ob die neue Seite aufgerufen werden konnte
                 */
                showSongOverview() {
                    let view = new SongOverview(this);
                    this._switchVisibleView(view);
                }

                /**
                 * Aufruf der Detailseite zur Anzeige oder zum Bearbeiten eines Songs.
                 *
                 * @param  {String} id Song-ID
                 * @param  {String} mode "new", "display" oder "edit"
                 * @return {Boolean} Flag, ob die neue Seite aufgerufen werden konnte
                 */
                showSongDisplayEdit(id, mode) {
                    let view = new SongDisplayEdit(this, id, mode);
                    this._switchVisibleView(view);
                }

                /**
                 * …
                 */
                _switchVisibleView(view) {
                    …
                }
            }
        </code>
    </pre>

    <h3>Ausprogrammieren der onShow()-Methoden</h3>
    <p>
        Damit das Ganze nun auch wirklich funktioniert, müssen wir noch die Methode
        <span class="cmd">onShow()</span> unserer beiden View-Klassen ausprogrammieren.
        Denn noch übergeben wir dem <span class="cmd">App</span>-Objekt keine DOM-Elemente
        zum Anzeigen und wir registrieren auch noch keine Event Handler, mit denen der
        Anwender zwischen den Seiten umherschalten könnte.
    </p>
    <p>
        Öffne daher noch einmal die Datei <span class="fn">src/song-overview/song-overview.js</span>
        und ersetze die <span class="cmd">onShow()</span>-Methode durch die nun folgende Version:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            onShow() {
                // Anzuzeigende HTML-Elemente ermitteln
                let section = document.querySelector("#song-overview").cloneNode(true);

                let content = {
                    className: "song-overview",
                    topbar: section.querySelectorAll("header &gt; *"),
                    main: section.querySelectorAll("main &gt; *"),
                };

                // Event Handler registrieren
                let newSongItem = section.querySelector("header .item.new-song");

                newSongItem.addEventListener("click", () =&gt; {
                    this._app.showSongDisplayEdit("", "new");
                })

                // Ergebnis zurückliefern
                return content;
            }
        </code>
    </pre>
    <p>
        In der Datei <span class="fn">src/song-display-edit/song-display-edit.js</span> ersetze
        die <span class="cmd">onShow()</span>-Methode durch folgende Version:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            onShow() {
                // Anzuzeigende HTML-Elemente ermitteln
                let section = document.querySelector("#song-display-edit").cloneNode(true);

                let content = {
                    className: "song-display-edit",
                    topbar: section.querySelectorAll("header &gt; *"),
                    main: section.querySelectorAll("main &gt; *"),
                };

                // Event Handler registrieren
                let overviewItem = section.querySelector("header .item.overview");

                overviewItem.addEventListener("click", () =&gt; {
                    this._app.showSongOverview();
                })

                // Ergebnis zurückliefern
                return content;
            }
        </code>
    </pre>
    <p>
        Beide Methoden sind prinzipiell gleich aufgebaut. Um sie zu verstehen müssen wir allerdings
        erst einen Bogen zurück zum Anfang des Kapitels machen. Dort haben wir nämlich den HTML-Code
        der Datei <span class="fn">src/index.html</span> etwas umgeräumt und zwei
        <span class="cmd">&lt;section&gt;</span>-Elemente für die beiden Unterseiten angelegt.
        Auf diese Elemente greifen wir nun zu, um die anzuzeigenden HTML-Elemente aus dem Document
        Object Model auszulesen. Allerdings erzeugen wir durch Aufruf der Methode
        <span class="fn">cloneNode(true)</span> eine tiefe Kopie der ausgelesenen Elemente, da der
        Kommentar vor der Methode <span class="fn">App._switchVisibleContent()</span> eindeutig
        besagt, dass ihr keine Elemente übergeben werden dürfen, die sich bereits im DOM-Baum der
        HTML-Seite befinden.
    </p>
    <p>
        Mit diesen Elementen bauen wir dann das <span class="fn">content</span>-Objekt auf, welches
        die Methode <span class="fn">App._switchVisibleContent()</span> von uns erwartet. Daraufhin
        suchen wir uns in der Topbar jeweils ein Element, mit dem der Anwender zwischen den Seiten
        umschalten kann und registrieren einen Click Event Handler darauf. In der entsprechenden
        Handler-Funktion rufen wir daher die jeweils richtige <span class="cmd">show…()</span>-Methode
        des <span class="fn">App</span>-Objekts auf, um die Seite tatsächlich zu wechseln.
    </p>
    <p>
        Und am Ende geben wir die <span class="fn">content</span>-Struktur zurück, damit die Methode
        <span class="fn">App._switchVisibleView()</span>, von der wir aufgerufen werden, sie an die
        Methode <span class="fn">App._switchVisibleContent()</span> übergeben kann.
    </p>
    <p>
        Wenn du alles richtig gemacht hast, solltest du daher nun zwischen den beiden Seiten umherschalten
        können. Dabei sollte dann auch aufgrund der unterschiedlichen Stylesheets die Schriftfarbe von
        orange auf lila wechseln, wie in der folgenden Animation dargestellt.
    </p>
    <figure>
        <img src="02/navigation/seiten-wechseln.gif" class="border"/>
        <figcaption>All der Mühen Lohn: Eine funktionierende Navigation innerhalb der App</figcaption>
    </figure>
</section>

<!-- ––––––––––––––––––––––––––––––––––– -->
<!-- Integration des Single Page Routers -->
<!-- ––––––––––––––––––––––––––––––––––– -->
<section data-title="Integration des Single Page Routers">
    <p class="git-commit">
        Git Commit:
        <a href="https://github.com/DennisSchulmeister/dhbwka-wwi-webprog-my-songbook/tree/afd89090abf9e432dc6fd9d80b48a8205de387be" target="_blank">afd8909</a>
    </p>

    <p>
        Zugegeben, das war schon eine ganze Menge Code, der da eben zusammenpassen musste, bevor wir
        wirklich zwischen den beiden Seiten hin und her schalten konnten. Doch damit hast du nun eine
        vollständige Grundstruktur zur Verfügung, die im Grunde genommen auf jede Art von Anwendung
        ausgerollt werden kann. Du musst nur die beiden Klassen für die Songübersicht und die Details
        zu einem Song durch eigene Klassen ersetzen. Ein paar Nachteile hat die bisherige Lösung aber
        noch, weshalb wir sie an dieser Stelle noch etwas verfeinern wollen:
    </p>
    <ul>
        <li>
            Die Views unserer App besitzen keine eindeutigen URLs und können daher nur per JavaScript
            aufgerufen werden. Dadurch kann eine View (zum Beispiel für einen bestimmten Song) nicht
            durch Eingabe der richtigen Adresse im Browser direkt aufgerufen werden.
        </li>
        <li>
            Auch können wir keine einfachen <span class="cmd">&lt;a&gt;</span>-Elemente innerhalb des
            HTML-Codes verwenden, um einen Link auf eine andere View zu platzieren. Wir müssen immer
            zusätzliche Event Handler schreiben und den Seitenwechsel mit JavaScript durchführen.
        </li>
        <li>
            Der Zurück-Button des Browsers sowie ganz allgemein ein Aufruf über den Browserverlauf
            wird nicht unterstützt.
        </li>
    </ul>
    <p>
        Die Lösung all dieser Probleme hört auf den Namen
        <a href="https://css-tricks.com/using-the-html5-history-api/" target="_blank">HTML5 History API</a>.
        Doch anstatt jetzt uns jetzt selbst damit herumzuschalgen (die Details richtig hinzubekommen ist
        tatsächlich nicht ganz einfach), wollen wir auf eine Library zurückgreifen, die das alles viel
        besser kann. Wir wollen einen „Single Page Router” verwenden, der es uns ganz einfach ermöglicht,
        eine URL-Struktur für unsere App zu definieren und dabei festzulegen, was beim Aufruf welcher URL
        passieren soll. Den Grundstock dafür haben wir bereits im letzten Teilkapitel gelegt. Jetzt geht
        es nur noch darum, die ganze Sache ein wenig zu optimieren.
    </p>

    <h3>Installation von Navigo</h3>
    <p>
        Die Library, die wir hier verwenden wollen, heißt <a href="https://github.com/krasimir/navigo" target="_blank">navigo</a>.
        Sie implementiert einen einfachen Single Page Router, der im Gegensatz zu vielen ähnlichen
        Bibliotheken ganz ohne fremde Abhängigkeiten auskommt und daher in nahezu jede beliebige
        Webanwendung integriert werden kann. Und wie das
        <a href="https://github.com/krasimir/navigo/blob/master/README.md" target="_blank">README auf GitHub</a>
        andeutet, scheint sie relativ einfach nutzbar zu sein. Grund genug also mal wieder das gute alte
        Terminal anzuschmeißen, mit <span class="cmd">cd</span> in unser Projektverzeichnis zu wechseln
        die Library mit folgendem Befehl zu installieren:
    </p>
    <p class="cmd">
        npm add --save-dev navigo
    </p>
    <p>
        Die installation sollte dabei in gewohnter node.js-Manier schnell und geräuschlos über die Bühne gehen.
    </p>
    <figure>
        <img src="02/spa-router/installation-navigo.jpg" />
        <figcaption>Installation des <span class="scr">navigo</span> Single Page Routers</figcaption>
    </figure>

    <h3>Anpassungen an der App-Klasse</h3>
    <p>
        Um den Single Page Router zu initialisieren müssen wir ein paar kleinere Umbauten der
        <span class="cmd">App</span>-Klasse vornehmen. Allerdings nichts allzu dramatisches.
        Zunächst müssen wir die Klasse <span class="fn">Navigo</span> aus dem Modul
        <span class="fn">navigo/lib/navigo.js</span> importieren, was wir dank Parcel einfach
        tun können, ohne hierfür auch nur eine Datei umkopieren zu müssen:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            …
            import Navigo from "navigo/lib/navigo.js";
            import SongDisplayEdit from "./song-display-edit/song-display-edit.js";
            import SongOverview from "./song-overview/song-overview.js";
            …

            class App { … }
        </code>
    </pre>
    <p>
        Danach können wir den Konstruktor von <span class="cmd">App</span> wie folgt erweitern:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            constructor() {
                this._title = "My Songbook";
                this._currentView = null;

                // Single Page Router aufsetzen
                this._router = new Navigo();
                this._currentUrl = "";
                this._navAborted = false;

                this._router.on({
                    "*":                       () =&gt; this.showSongOverview(),
                    "/song/new/":              () =&gt; this.showSongDisplayEdit("", "new"),
                    "/song/display/:id/":  params =&gt; this.showSongDisplayEdit(params.id, "display"),
                    "/song/edit/:id":      params =&gt; this.showSongDisplayEdit(params.id, "edit"),
                });

                this._router.hooks({
                    after: (params) =&gt; {
                        if (!this._navAborted) {
                            // Navigation durchführen, daher die neue URL merken
                            this._currentUrl = this._router.lastRouteResolved().url;
                        } else {
                            // Navigation abbrechen, daher die URL in der Adresszeile
                            // auf den alten Wert der bisherigen View zurücksetzen
                            this._router.pause(true);
                            this._router.navigate(this._currentUrl);
                            this._router.pause(false);

                            this._navAborted = false;
                        }
                    }
                });
            }
        </code>
    </pre>
    <p>
        Das sieht jetzt erst einmal sehr komplex aus. Wichtig aber nur der Aufruf von
        <span class="cmd">this._router.on({…})</span> als Herzstück dieser Anpassung.
        Alle anderen Zeilen, bis auf die Erzeugung des Router-Objekts selbst könnte man
        auch weglassen. Sie werden nur benötigt, weil wir die Navigation in bestimmten
        Fällen unterbrechen wollen und den Navigo hierfür ein wenig zum Mitspielen
        überreden müssen.
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            this._router.on({
                "*":                       () =&gt; this.showSongOverview(),
                "/song/new/":              () =&gt; this.showSongDisplayEdit("", "new"),
                "/song/display/:id/":  params =&gt; this.showSongDisplayEdit(params.id, "display"),
                "/song/edit/:id":      params =&gt; this.showSongDisplayEdit(params.id, "edit"),
            });
        </code>
    </pre>
    <p>
        Hier wird die URL-Struktur der Seite definiert, wobei jedes URL-Pattern mit einer
        anonymen Lambda-Funktion (zu erkennen an <span class="cmd">() => &gt; …</span>)
        verknüpft ist. Es liegt nahe, dass der Router die entsprechende Lambda-Funktionen
        aufruft, wenn eine URL erkannt wurde, um dadurch den sichtbaren Inhalt zu wechseln.
        Praktischerweise können wir hier unsere Methoden von vorhin direkt weiterverwenden.
    </p>
    <p>
        In der <span class="cmd">start()</span>-Methode müssen wir nun nicht mehr explizit
        die Übersichtsseite aufrufen. Stattdessen sagen wir dem Router hier, dass er die
        URL, mit der die gesamte App gestartet wurde, auswerten und die anzuzeigende View
        automatisch erkennen soll:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            start() {
                this._router.resolve();
            }
        </code>
    </pre>
    <p>
        Das sind eigentlich schon alle Änderungen an der Klasse <span class="cmd">App</span>.
        Damit aber das Unterbrechen der Navigation richtig funktioniert, müssen wir die
        Methode <span class="cmd">_switchVisibleView()</span> noch ein klein wenig modifizieren.
        Die neue Version lautet wie folgt:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            _switchVisibleView(view) {
                // Callback, mit dem die noch sichtbare View den Seitenwechsel zu einem
                // späteren Zeitpunkt fortführen kann, wenn sie in der Methode onLeave()
                // false zurückliefert. Dadurch erhält sie die Möglichkeit, den Anwender
                // zum Beispiel zu fragen, ob er ungesicherte Daten speichern will,
                // bevor er die Seite verlässt.
                let newUrl = this._router.lastRouteResolved().url;
                let goon = () =&gt; {
                    // ?goon an die URL hängen, weil der Router sonst nicht weiternavigiert
                    this._router.navigate(newUrl + "?goon");
                }

                // Aktuelle View fragen, ob eine neue View aufgerufen werden darf
                if (this._currentView && !this._currentView.onLeave(goon)) {
                    this._navAborted = true;
                    return false;
                }

                // Alles klar, aktuelle View nun wechseln
                document.title = `${this._title} – ${view.title}`;

                this._currentView = view;
        </code>
    </pre>
    <p>
        Im Vergleich zur alten Version setzen wir hier noch ein Kennzeichen, wenn die
        Navigation durch die aktuell sichtbare View unterbunden wird, damit wir im weiter
        oben definieren „After Hook” von Navigo die Adresszeile des Browsers wieder auf
        die alte URL setzen könne. Außerdem müssen wir hier die URL der nächsten Seite
        innerhalb des <span class="cmd">goon</span>-Callbacks etwas anders ermitteln.
    </p>

    <h3>Vereinfachung der restlichen Quellcodes</h3>
    <p>
        Undank sei der Welten Lohn, sagt man. Nicht jedoch an dieser Stelle. Zwar ist
        die Klasse durch die neuerlichen Änderungen nochmal ein klein wenig komplizierter
        geworden, dafür vereinfachen sich aber alle anderen Quellcodes. Und wir haben eine
        ordentliche URL-Struktur, mit der wir jede View der App über eine eigene URL direkt
        aufrufen oder als Lesezeichen im Browser speichern können. Und der Zurück-Button
        des Browsers tut nun auch das, was er soll.
    </p>
    <p>
        Zunächst einmal wollen wir die <span class="cmd">onShow()</span>-Methoden der beiden
        View-Klassen etwas aufräumen. Hier fallen die Event Handler komplett weg, so dass die
        Methoden nun nur noch so aussehen:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            // src/song-overview/song-overview.js:
            onShow() {
                let section = document.querySelector("#song-overview").cloneNode(true);

                return content = {
                    className: "song-overview",
                    topbar: section.querySelectorAll("header > *"),
                    main: section.querySelectorAll("main > *"),
                };
            }
        </code>
    </pre>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            // src/song-display-edit/song-display-edit.js:
            onShow() {
                let section = document.querySelector("#song-display-edit").cloneNode(true);

                return {
                    className: "song-display-edit",
                    topbar: section.querySelectorAll("header > *"),
                    main: section.querySelectorAll("main > *"),
                };
            }
        </code>
    </pre>
    <p>
        Wir konnten tatsächlich die Hälfte des Quellcodes einfach wegschmeißen. Und da wir zum
        Umschalten zwischen den Views nun kein explizites JavaScript mehr benötigen, können wir
        die <span class="fn">src/index.html</span> nun so anpassen, dass hierfür einfache Links
        verwendet werden. Die Definitionen innerhalb der Topbar ändern sich dadurch wie folgt:
    </p>
    <pre data-gobble>
        <code class="html" data-gobble>
            &lt;div class="item"&gt;
                &lt;a href="/song/new/" data-navigo&gt;
                    Song hinzufügen
                &lt;/a&gt;
            &lt;/div&gt;

            …

            &lt;div class="item"&gt;
                &lt;a href="/" data-navigo&gt;
                    Zurück zur Übersicht
                &lt;/a&gt;
            &lt;/div&gt;
        </code>
    </pre>
    <p>
        Wenn es gut läuft, sollte das Ergebnis nun wie folgt aussehen. Beachte dabei, wie sic
        die URL in der Adresszeile des Browsers beim Wechseln der Seite ebenfalls ändert:
    </p>
    <figure>
        <img src="02/spa-router/seiten-wechseln.gif" class="border"/>
        <figcaption>Navigation innerhalb der App mit Hilfe des Single Page Routers</figcaption>
    </figure>

    <h3>Hinweis zum Parcel-Entwicklungsserver</h3>
    <p>
        Leider verträgt sich das Prinzip eines Single Page Routers nicht immer 100%ig mit dem
        Hot Module Replacement (automatisches Nachladen der Seite bei einer Quellcodeänderung)
        des Parcel-Entwicklungsservers. Deshalb kann es nach einer Änderung am Quellcode passieren,
        dass die Seite zwar neulädt, in der Adresszeile des Browsers aber noch eine alte URL steht.
        In diesem Fall entferne am Besten alle Bestandteile nach der Port-Nummer der URL und lade
        die Seite erneut. Dadurch kannst du Navigo und Parcel wieder in Einklang bringen. In der
        Produktivversion der App kann das nicht passieren, da es hier das automatische Neuladen
        der Seite ja nicht gibt.
    </p>
</section>

<!-- –––––––––––––––––––––––––––– -->
<!-- Die Übersichtsseite entsteht -->
<!-- –––––––––––––––––––––––––––– -->
<section data-title="Die Übersichtsseite entsteht">
    <p class="git-commit">
        Git Commit:
        <a href="https://github.com/DennisSchulmeister/dhbwka-wwi-webprog-my-songbook/tree/XXX" target="_blank">XXX</a>
    </p>

    <!--
    Ausprogrammieren der Übersichtsseite mit Dummy-Daten im HTML
    -->
</section>

<!-- –––––––––––––––––––––––––––––– -->
<!-- Lokale Datenhaltung im Browser -->
<!-- –––––––––––––––––––––––––––––– -->
<section data-title="Lokale Datenhaltung im Browser">
    <p class="git-commit">
        Git Commit:
        <a href="https://github.com/DennisSchulmeister/dhbwka-wwi-webprog-my-songbook/tree/XXX" target="_blank">XXX</a>
    </p>

    <!--
    Installation von PouchDB
    Grundlagen der Nutzung (aus API-Dokumentation)
    Definition einer Datenbank-Fassaden-Klasse
    Vorläufige Dummy-Daten erzeugen, wenn die DB leer ist
    Anpassung der Übersichtsseite (direkte DOM-Manipulation)
    -->
</section>

<!-- –––––––––––––––––– -->
<!-- Songtexte anzeigen -->
<!-- –––––––––––––––––– -->
<section data-title="Songtexte anzeigen">
    <p class="git-commit">
        Git Commit:
        <a href="https://github.com/DennisSchulmeister/dhbwka-wwi-webprog-my-songbook/tree/XXX" target="_blank">XXX</a>
    </p>

    <!--
    Ausprogrammieren der Detailseite zu einem Songtext
    Bis hierhin nur im Anzeigemodus
    Buttons zum Löschen und Bearbeiten bereits vorsehen
    Bei Klick auf "Löschen" direkt löschen und zurück zur Übersicht
    Navigation zurück zur Übersicht (wenn nicht bereits geklärt)
    -->
</section>

<!-- ––––––––––––––––––––––––––––– -->
<!-- Modales Popup vor dem Löschen -->
<!-- ––––––––––––––––––––––––––––– -->
<section data-title="Modales Popup vor dem Löschen">
    <p class="git-commit">
        Git Commit:
        <a href="https://github.com/DennisSchulmeister/dhbwka-wwi-webprog-my-songbook/tree/XXX" target="_blank">XXX</a>
    </p>

    <!--
    CSS/JS-Code für einen modalen Dialog
    Eigene Komponente <popup-ask-delete>
    Aufruf des Dialogs an der richtigen Stelle
    -->
</section>

<!-- ––––––––––––––––––––––––– -->
<!-- Ein Editor für alle Fälle -->
<!-- ––––––––––––––––––––––––– -->
<section data-title="Ein Editor für alle Fälle">
    <p class="git-commit">
        Git Commit:
        <a href="https://github.com/DennisSchulmeister/dhbwka-wwi-webprog-my-songbook/tree/XXX" target="_blank">XXX</a>
    </p>

    <!--
    Wechsel in den Änderungsmodus der Detailseite
    contenteditable-Attribut für Titel und Interpret
    Event Handler um ENTER abzufangen (keine neue Zeile bzw. <div> bei ENTER, dafür ins nächste Feld springen, event.preventDefaul())
    <textarea> zum Bearbeiten des HTML-Codes des Textes
    Installation von Qilk
    WYSIWIG-Bearbeiten des Textes mit Quilk
    Änderungen sichern bei Okay, Seite neuladen bei Abbrechen
    -->
</section>

<!-- –––––––––––––––––––––––––––––––––– -->
<!-- Onlinesuche und Anlage eines Songs -->
<!-- –––––––––––––––––––––––––––––––––– -->
<section data-title="Onlinesuche und Anlage eines Songs">
    <p class="git-commit">
        Git Commit:
        <a href="https://github.com/DennisSchulmeister/dhbwka-wwi-webprog-my-songbook/tree/XXX" target="_blank">XXX</a>
    </p>

    <!--
    Neue <popup-create-song>-Komponente ausprogrammieren (viel Copy & Paste)
    Installation von lyric-get
    Abruf eines Songs mit lyric-get
    Bessere Alternative: Fetch API mit await
    Abruf des Songs mit der Fetch API, Auswerten des JSON-Strings
    Aufruf der Detailseite im Neuanlagemodus
    Hierfür notwendige Anpassungen an der Detailseite
    -->
</section>
