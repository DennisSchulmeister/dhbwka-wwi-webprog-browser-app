<!-- =========================== -->
<!-- VERSION MIT STATISCHEM HTML -->
<!-- =========================== -->
<section data-chapter data-title="Version mit statischem HTML"></section>

<!-- –––––––––––––––––––––––– -->
<!-- Das Grundgerüst entsteht -->
<!-- –––––––––––––––––––––––– -->
<section data-title="Das Grundgerüst entsteht">
    <p class="git-commit">
        Git Commit:
        <a href="https://github.com/DennisSchulmeister/dhbwka-wwi-webprog-my-songbook/tree/5b40260b1c7855ec8ec12d97666b4837f004927d" target="_blank">5b40260</a>
    </p>

    <p>
        Bis hierhin sieht unsere App irgendwie noch so gar nicht wie eine App
        aus. Sondern mehr wie eine normale Webseite. Schlimmer noch: Wie ein
        ganz banales „Hallo, Welt!”. An dieser Stelle wollen wir daher das
        Grundlayout der App erstellen, so dass das wir hinterher folgendes
        Ergebnis sehen:
    </p>
    <figure>
        <img src="02/grundstruktur/layout-fertig.jpg" class="border" />
        <figcaption>Das Layout der App, wenn wir hier fertig sind</figcaption>
    </figure>
    <p>
        Der angezeigte Inhalt ist natürlich nur ein Platzhalter und wird überhaupt
        noch nicht in irgend einer Weise dynamisch erzeugt. Wir können ihn deshalb
        einfach direkt in die HTML-Seite schreiben, damit wir beim Erstellen der
        Stylesheets schon etwas sehen.
        Entferne nun also das <span class="cmd">&lt;h1&gt;</span> aus der
        <span class="fn">src/index.html</span> und ersetze es durch folgenden
        Code. Alle anderen Zeilen bleiben unverändert.
    </p>
    <pre data-gobble>
        <code class="html" data-gobble>
            &lt;!-- ========================= --&gt;
            &lt;!-- Grundgerüst der Anwendung --&gt;
            &lt;!-- ========================= --&gt;
            &lt;section id="app"&gt;
                &lt;!-- Topbar --&gt;
                &lt;header&gt;
                    &lt;!-- Obere Zeile (fester Inhalt) --&gt;
                    &lt;div class="top left"&gt;
                        &lt;div class="item inactive"&gt;
                            &lt;b&gt;
                                Beispiel einer Browser App: My Songbook
                            &lt;/b&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                    &lt;div class="top right"&gt;
                        &lt;div class="item"&gt;
                            &lt;a href="https://github.com/DennisSchulmeister/dhbwka-wwi-webprog-my-songbook" target="_blank"&gt;GitHub&lt;/a&gt;
                        &lt;/div&gt;
                        &lt;div class="item"&gt;
                            &lt;a href="https://www.wpvs.de/browser-app/" target="_blank"&gt;Programmieranleitung&lt;/a&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;

                    &lt;!-- Untere Zeile (dynamisch je nach View) --&gt;
                    &lt;div class="bottom left"&gt;
                        &lt;div class="item"&gt;
                            Song hinzufügen
                        &lt;/div&gt;
                        &lt;div class="item"&gt;
                            Sortierung nach Titel
                        &lt;/div&gt;
                    &lt;/div&gt;
                    &lt;div class="bottom right"&gt;
                        &lt;input placeholder="Suchen" /&gt;
                    &lt;/div&gt;
                &lt;/header&gt;

                &lt;!-- Hauptbereich (dynamisch je nach View) --&gt;
                &lt;main&gt;
                    &lt;div class="padding"&gt;
                        Under Construction
                    &lt;/div&gt;
                &lt;/main&gt;
            &lt;/section&gt;
        </code>
    </pre>
    <p>
        Denkt man sich den Dummy-Inhalt weg, lässt sich daran auch schon folgender Aufbau
        der Seite erkennen:
    </p>
    <pre data-gobble>
        <code class="html" data-gobble>
            &lt;section id="app"&gt;
                &lt;header&gt;
                    &lt;!-- Obere Zeile (fester Inhalt) --&gt;
                    &lt;div class="top left"&gt;
                        … Inhalt in allen Views identisch …
                    &lt;/div&gt;
                    &lt;div class="top right"&gt;
                        … Inhalt in allen Views identisch …
                    &lt;/div&gt;

                    &lt;!-- Untere Zeile (dynamisch je nach View) --&gt;
                    &lt;div class="bottom left"&gt;
                        … Inhalt je nach View …
                    &lt;/div&gt;
                    &lt;div class="bottom right"&gt;
                        … Inhalt je nach View …
                    &lt;/div&gt;
                &lt;/header&gt;

                &lt;!-- Hauptbereich (dynamisch je nach View) --&gt;
                &lt;main&gt;
                    … Inhalt je nach View …
                &lt;/main&gt;
            &lt;/section&gt;
        </code>
    </pre>
    <p>
        Diese Inhalte müssen wir nun mit den zuvor angelegten Stylesheets in Form bringen,
        da die eingebauten Layoutregeln des Browsers natürlich nicht wie von Geisterhand
        das obige Bild herbeizaubern werden. Doch zuvor musst du dir von GitHub folgende
        drei Bilder herunterladen:
    </p>
    <ul>
        <li>
            <a href="https://raw.githubusercontent.com/DennisSchulmeister/dhbwka-wwi-webprog-my-songbook/master/src/favicon.svg" target="_blank">src/favicon.svg</a>: Icon der App
        </li>
        <li>
            <a href="https://raw.githubusercontent.com/DennisSchulmeister/dhbwka-wwi-webprog-my-songbook/master/src/background.jpg" target="_blank">src/background.jpg</a>: Hintergrundbild auf großen Bildschirmen
        </li>
        <li>
            <a href="https://raw.githubusercontent.com/DennisSchulmeister/dhbwka-wwi-webprog-my-songbook/master/src/construction.jpg" target="_blank">src/construction.jpg</a>: Platzhalter im Hauptbereich der App
        </li>
    </ul>
    <p>
        Anschließend lege eine neue Datei namens <span class="fn">src/theme.css</span> und
        folgendem Inhalt an. Sie enthält häufig benötigte
        <a href="https://www.w3schools.com/css/css3_variables.asp" target="_blank">CSS-Variablen</a>,
        die wir an anderer Stelle immer wieder benötigen werden:
    </p>
    <pre data-gobble>
        <code class="css" data-gobble>
            html {
                --font-color:                     black;
                --highlight-background-color:     rgba(235, 235, 235, 1.0);

                --header-normal-background-color: rgba(017,111,159, 1.0);
                --header-normal-font-color:       rgba(255,255,255, 0.8);
                --header-active-background-color: rgba(255,255,255, 0.2);
                --header-active-font-color:       rgba(255,255,255, 0.9);
            }
        </code>
    </pre>
    <p>
        Damit haben wir erst einmal alle Dateien beisammen. Die Verzeichnisstruktur sollte jetzt
        wie in der nächsten Abbildung aussehen:
    </p>
    <figure>
        <img src="02/grundstruktur/alle-dateien.png" />
        <figcaption>Verzeichnisstruktur der Webanwendung an dieser Stelle</figcaption>
    </figure>
    <p>
        Damit das neue Stylesheet wirksam wird, muss es erst noch importiert werden.
        Ändere deshalb den Import des alten Stylesheets in der <span class="fn">src/index.js</span>
        zu folgenden zwei Zeilen ab. Achte dabei aber darauf, wirklich erst die Datei
        <span class="fn">./index.css</span> und dann die Datei <span class="fn">./theme.css</span>
        zu importieren:
    </p>
    <pre data-gobble>
        <code class="js" data-gobble>
            import stylesheet from "./index.css";
            import theme from "./theme.css";
        </code>
    </pre>
    <p>
        Der Inhalt der Datei <span class="fn">src/index.css</span> ändert sich nun komplett
        zu folgenden Zeilen. Zunächst ein paar allgemeine Definitionen:
    </p>
    <pre data-gobble>
        <code class="css" data-gobble>
            /*
             * Dieses Stylesheet enthält nur allgemeine Anweisungen, die sich auf die
             * gesamte App auswirken. Hier dürfen keine Änderungen vorgenommen werden,
             * die sich nur auf bestimmte Bereiche der Anwendung auswirken sollen.
             *
             * Damit @import funktioniert, muss die Anweisung vor allen anderen
             * CSS-Anweisungen stehen. Dieses Stylesheet muss daher auch vor allen
             * anderen importiert werden.
             */
            @import url('https://fonts.googleapis.com/css?family=Roboto');

            html, body {
                padding: 0;
                margin: 0;
                height: 100%;
            }

            body {
                font-family: 'Roboto', sans-serif;
                font-size: 11pt;
                line-height: 1.6;
                color: var(--font-color);
            }
        </code>
    </pre>

    <p>
        Dann ein paar Anpassungen der Schriftgröße je nach Bildschirmauflösung:
    </p>
    <pre data-gobble>
        <code class="css" data-gobble>
            /*
             * Größere Schrift auf größeren Bildschirmen
             * Vgl. https://getbootstrap.com/docs/4.0/layout/overview/#responsive-breakpoints
             */
            @media screen and (min-width: 768px) {
                body,
                input {
                    font-size: 12pt;
                }
            }

            @media screen and (min-width: 992px) {
                body,
                input {
                    font-size: 13pt;
                }
            }

            @media screen and (min-width: 1200px) {
                body,
                input {
                    font-size: 14pt;
                }
            }
        </code>
    </pre>

    <p>
        Und zum Schluss wie immer ein Media Query, um auf großen Bildschirmen
        die Darstellung zu optimieren, sowie ein paar nützliche Helferlein:
    </p>
    <pre data-gobble>
        <code class="css" data-gobble>
            /*
             * Flächendeckender Seitenhintergrund auf großen Bildschirmen
             */
            @media (min-width: 85em) {
                /* Hintergrundbild hinter dem Hauptbereich der App */
                html {
                    /* https://pixabay.com/de/computer-notebook-kaffee-820281/ */
                    background-image: url(background.jpg);
                    background-attachment: fixed;
                    background-size: cover;
                    background-position: center;
                }

                /* Hauptbereich der App vergrößern */
                body {
                    display: flex;
                    align-items: stretch;
                    justify-content: center;
                }

                body &gt; * {
                    flex: 1;
                }
            }

            /*
             * Häufig benötigte Hilfsklassen
             */
            .hidden {
                display: none;
            }

            .padding {
                padding: 0.5rem;
            }
        </code>
    </pre>

    <p>
        Wie du (hoffentlich) siehst, werden hier wirklich nur ganz allgemeine Dinge
        geregelt, die sich auf die gesamte App auswirken. Spezifische Anpassungen
        für einen einzelnen Bereich werden stattdessen in getrennten Stylesheets
        vorgenommen, wobei es im Grunde genommen je JavaScript-Datei eine gleichnamige
        CSS-Datei gibt. Die Datei
        <span class="fn">src/app.css</span> beginnt daher wie immer mit ein paar
        allgemeinen Definitionen:
    </p>
    <pre data-gobble>
        <code class="css" data-gobble>
            /*
             * Dieses Stylesheet darf nur Selektoren beinhalten, die mit #app beginnen.
             * Denn wir wollen nicht, dass hier Eigenschaften aus anderen Bereichen der
             * Anwendung überschrieben werden.
             */
            #app {
                background-color: white;
                flex: 1;
            }
        </code>
    </pre>
    <p>
        Darauf folgt eine große Zahl an Regeln zur Gestaltung des Kopfbereichs.
        Auch sie fangen alle mit <span class="cmd">#app</span> an, um ihre Gültigkeit
        zu begrenzen:
    </p>
    <pre data-gobble>
        <code class="css" data-gobble>
            /*
             * Kopfbereich über dem Inhalt
             */
            #app header {
                background-color: var(--header-normal-background-color);
                color: var(--header-normal-font-color);
            }

            #app header &gt; *,
            #app header input,
            #app header .item {
                display: block;
                box-sizing: border-box;
                width: 100%;
            }

            #app header &gt; .top {
                font-size: 80%;

                border: 0px solid var(--header-active-background-color);
                border-bottom-width: 1px;
            }

            #app header &gt; .top .item,
            #app header &gt; .top input {
                padding: 0.5rem;
            }

            #app header &gt; .bottom {
                border: 0px solid var(--header-active-background-color);
                border-bottom-width: 1px;
            }

            #app header &gt; .bottom .item,
            #app header &gt; .bottom input {
                padding: 1rem 0.5rem 1rem 0.5rem;
            }

            #app header .active,
            #app header .item:not(.inactive):hover {
                background-color: var(--header-active-background-color);
                color: var(--header-active-font-color);
            }

            #app header .item:not(.inactive) {
                cursor: pointer;
            }

            #app header a,
            #app header a:visited {
                color: var(--header-normal-font-color);
                text-decoration: none;
            }

            #app header a:hover {
                color: var(--header-active-font-color);
                text-decoration: underline;
            }

            #app header input {
                background: none;
                color: var(--header-normal-font-color);
                border: 0;
            }
        </code>
    </pre>

    <p>
        Dann wieder etwas temporärer Inhalt, um das Baustellenbild beim Aufruf
        der App anzuzeigen 🚧 und einen kleinen Hinwestext in der Mitte zu
        platzieren:
    </p>
    <pre data-gobble>
        <code class="css" data-gobble>
            /*
             * Hauptinhalt
             */
            #app main {
                /*
                 * Temporärer Inhalt, solange es noch keinen richtigen Inhalt gibt
                 * Bild: https://pixabay.com/de/handwerker-baustelle-arbeiter-3094035/
                 */
                background-image: url(construction.jpg);
                background-size: 100% auto;
                background-position: bottom center;
                background-repeat: no-repeat;

                color: rgb(255, 246, 23);
                text-shadow: 1px 1px 2px black;
                font-size: 300%;
                font-weight: bold;
                text-align: center;
            }
        </code>
    </pre>
    <p>
        Und zum Schluß wie immer die Anpassung an große Bildschirme. Die Angabe
        <span class="cmd">(min-width: 85em)</span> in der fünften Zeile muss
        dabei in Einklang mit dem Media Query in der <span class="fn">src/index.css</span>
        stehen, damit die Darstellung passt:
    </p>
    <pre data-gobble>
        <code class="css" data-gobble>
            /*
             * Anpassung an große Bildschirme, sobald in der index.css das große
             * Hintergrundbild eingeschaltet wird
             */
            @media screen and (min-width: 85em) {
                /* Rahmen um den Hauptbereich zeichnen */
                #app {
                    max-width: 80em;
                    margin-top: 2em;
                    margin-bottom: 2em;

                    border: 1px solid rgba(32,32,32, 0.2);
                    box-shadow: 1px 1px 3px rgba(0,0,0, 0.1);
                }

                /* Topbar- und Toolbar-Inhalte nebeneinander */
                #app header {
                    display: grid;
                    grid-template-columns: auto 20em;
                }

                #app header .top {
                    grid-row: 1;
                }

                #app header .bottom {
                    grid-row: 2;
                }

                #app header .left {
                    grid-column: 1;

                    display: flex;
                    justify-content: flex-start;
                }

                #app header .right{
                    grid-column: 2;

                    display: flex;
                    justify-content: flex-start;

                    background-color: var(--header-active-background-color);
                    color: var(--header-active-font-color);
                }

                #app header .item {
                    width: auto;
                }

                /* Nur den Bereich unterhalb der Toolbar scrollen */
                #app {
                    display: flex;
                    flex-direction: column;
                }

                #app &gt; main {
                    flex: 1;
                    overflow: auto;
                }
            }
        </code>
    </pre>
    <p>
        Und das war es dann auch schon. Zugegeben war das jetzt zwar viel Copy &amp; Paste.
        Auf dieser Grundlage können wir der App im nächsten Schritt nun aber ein wenig Leben einhauchen.
    </p>
</section>

<!-- –––––––––––––––––––––––––––– -->
<!-- Navigation innerhalb der App -->
<!-- –––––––––––––––––––––––––––– -->
<section data-title="Navigation innerhalb der App">
    <p class="git-commit">
        Git Commit:
        <a href="https://github.com/DennisSchulmeister/dhbwka-wwi-webprog-my-songbook/tree/11f39e316a354d0be004929e2db621a68fe69527" target="_blank">11f39e3</a>
    </p>

    <p>
        Rein visuell sieht unsere Seite jetzt schon viel mehr wie eine App aus. Man kann aber noch
        nichts anklicken, weshalb es sich im Grunde genommen immer noch um eine statische HTML-Seite
        handelt. An dieser Stelle wollen wir daher das Grundgerüst etwas erweitern und eine einfache
        Navigation ermöglichen. Dadurch soll es möglich sein, zwischen der Übersichtsseite (die wir
        an dieser Stelle immer noch nicht mit Inhalt füllen werden) und der späteren Detailseite
        umzuschalten, so dass wir dann endgültig von einer echten Browser App sprechen können. Denn
        im Gegensatz zu einer serverseitigen Webanwendung soll das hin und her Schalten zwischen den
        Seiten komplett im Browser geschehen, ohne hierfür eine neue Seite vom Server anzufordern.
    </p>

    <h3>Umstrukturierung des HTML-Codes</h3>
    <p>
        Im ersten Schritt müssen wir die Datei <span class="fn">src/index.html</span> so umbauen,
        dass jeder Bereich der App eine eigene <span class="cmd">&lt;section&gt;</span> bekommt,
        die wir über eine eindeutige Id adressieren können. Allerdings sollen diese neuen Bereiche
        nicht sichtbar sein. Die CSS-Klasse <span class="cmd">hidden</span> stellt deshalb sicher,
        dass wirklich nur die erste <span class="cmd">&lt;section id="app"&gt;</span> mit dem
        Anwendungsrahmen und sonst nichts angezeigt wird.
    </p>
    <pre data-gobble>
        <code class="html" data-gobble>
            &lt;!DOCTYPE html&gt;
            &lt;html&gt;
                &lt;head&gt;
                    &lt;meta charset="utf-8" /&gt;
                    &lt;title&gt;My Songbook&lt;/title&gt;
                    &lt;link rel="shortcut icon" href="favicon.svg"&gt;

                    &lt;script src="index.js"&gt;&lt;/script&gt;
                &lt;/head&gt;
                &lt;body&gt;
                    &lt;!-- ========================= --&gt;
                    &lt;!-- Grundgerüst der Anwendung --&gt;
                    &lt;!-- ========================= --&gt;
                    &lt;section id="app"&gt;
                        …
                    &lt;/section&gt;

                    &lt;!-- ====================== --&gt;
                    &lt;!-- View: Vorhandene Songs --&gt;
                    &lt;!-- ====================== --&gt;
                    &lt;section id="song-overview" class="hidden"&gt;
                        …
                    &lt;/section&gt;

                    &lt;!-- ================================== --&gt;
                    &lt;!-- View: Song anzeigen und bearbeiten --&gt;
                    &lt;!-- ================================== --&gt;
                    &lt;section id="song-display-edit" class="hidden"&gt;
                        …
                    &lt;/section&gt;
                &lt;/body&gt;
            &lt;/html&gt;
        </code>
    </pre>
    <p>
        Anschließend können wir den Dummy-Inhalt aus dem Grundgerüst wieder entfernen, so dass
        davon nur folgende Zeilen übrig bleiben. Den festen Inhalt der Topbar, der wirklich immer zu
        sehen sein soll, behalten wir hier natürlich bei. Ebenso alle anderen Zeilen der HTML-Datei.
    </p>
    <pre data-gobble>
        <code class="html" data-gobble>
            &lt;!-- ========================= --&gt;
            &lt;!-- Grundgerüst der Anwendung --&gt;
            &lt;!-- ========================= --&gt;
            &lt;section id="app"&gt;
                &lt;!-- Topbar --&gt;
                &lt;header&gt;
                    &lt;!-- Obere Zeile (fester Inhalt) --&gt;
                    &lt;div class="top left"&gt;
                        &lt;div class="item inactive"&gt;
                            &lt;b&gt;
                                Beispiel einer Browser App: My Songbook
                            &lt;/b&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                    &lt;div class="top right"&gt;
                        &lt;div class="item"&gt;
                            &lt;a href="https://github.com/DennisSchulmeister/dhbwka-wwi-webprog-my-songbook" target="_blank"&gt;GitHub&lt;/a&gt;
                        &lt;/div&gt;
                        &lt;div class="item"&gt;
                            &lt;a href="https://www.wpvs.de/browser-app/" target="_blank"&gt;Programmieranleitung&lt;/a&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;

                    &lt;!-- Untere Zeile (dynamisch je nach View) --&gt;
                &lt;/header&gt;

                &lt;!-- Hauptbereich (dynamisch je nach View) --&gt;
                &lt;main&gt;
                &lt;/main&gt;
            &lt;/section&gt;
        </code>
    </pre>
    <p>
        Den eben entfernten HTML-Code bauen wir stattdessen weiter unten in die <span class="cmd">&lt;section&gt;</span>
        für die Übersichtsseite wieder ein.¹
    </p>
    <pre data-gobble>
        <code class="html" data-gobble>
            &lt;!-- ====================== --&gt;
            &lt;!-- View: Vorhandene Songs --&gt;
            &lt;!-- ====================== --&gt;
            &lt;section id="song-overview" class="hidden"&gt;
                &lt;!-- Topbar --&gt;
                &lt;header&gt;
                    &lt;div class="left"&gt;
                        &lt;div class="item new-song"&gt;
                            Song hinzufügen
                        &lt;/div&gt;
                        &lt;div class="item"&gt;
                            Sortierung nach Titel
                        &lt;/div&gt;
                    &lt;/div&gt;
                    &lt;div class="right"&gt;
                        &lt;input placeholder="Suchen" /&gt;
                    &lt;/div&gt;
                &lt;/header&gt;

                &lt;!-- Hauptbereich --&gt;
                &lt;main&gt;
                    &lt;div class="padding"&gt;
                        Übersicht
                    &lt;/div&gt;
                &lt;/main&gt;
            &lt;/section&gt;
        </code>
    </pre>
    <p>
        ¹
        <small>
            Die CSS-Klasse <span class="cmd">bottom</span> für die beiden <span class="cmd">&lt;div&gt;</span>
            in der Topbar haben wir hier absicshtlich weggelassen. Doch dazu später mehr.
        </small>
    </p>
    <p>
        Und auch die Detailseite gestalten wir ähnlich, da sie zu diesem Zeitpunkt natürlich auch noch keinen
        wirklichen Inhalt besitzt. Immerhin bekommt sie in der Topbar jedoch bereits einen Eintrag, mit dem der
        Anwender zurück auf die Übersichtsseite gelangen soll.
    </p>
    <pre data-gobble>
        <code class="html" data-gobble>
            &lt;!-- ================================== --&gt;
            &lt;!-- View: Song anzeigen und bearbeiten --&gt;
            &lt;!-- ================================== --&gt;
            &lt;section id="song-display-edit" class="hidden"&gt;
                &lt;!-- Topbar --&gt;
                &lt;header&gt;
                    &lt;div class="left"&gt;
                        &lt;!-- Leer --&gt;
                    &lt;/div&gt;
                    &lt;div class="right"&gt;
                        &lt;div class="item overview"&gt;
                            Zurück zur Übersicht
                        &lt;/div&gt;
                    &lt;/div&gt;
                &lt;/header&gt;

                &lt;!-- Hauptbereich --&gt;
                &lt;main&gt;
                    &lt;div class="padding"&gt;
                        Song anzeigen/bearbeiten
                    &lt;/div&gt;
                &lt;/main&gt;
            &lt;/section&gt;
        </code>
    </pre>

    <h3>Austausch der sichtbaren Inhalte mit JavaScript</h3>
    <p>
        Mit diesen Änderungen nun an Ort und Stelle können wir uns an die Ausprogrammierung der
        <span class="cmd">App</span>-Klasse innerhalb der Datei <span class="fn">src/app.js</span>
        machen. Denn sie soll für die Navigation innerhalb der App zuständig sein und zwischen den
        verschiedenen Ansichten umschalten. Die eigentliche Arbeit macht dabei die folgende, neue
        Methode, wobei der Unterstrich am Anfang des Namens ausdrückt, dass sie nur innerhalb der
        Klasse selbst aufgerufen werden sollte. Erzwungen wird das von JavaScript allerdings nicht.
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            /**
             * Auswechseln des sichtbaren Inhalts der App. Hierfür muss der Methode
             * ein Objekt mit folgendem Aufbau übergeben werden:
             *
             *   {
                    className: "CSS-Klassenname",
             *      topbar: [DOM Element, DOM Element, DOM Element, ...],
             *      main: [DOM Element, DOM Element, DOM Element, ...],
             *   }
             *
             * Beide Attribute (topbar und main) sind optional, was dazu führt, dass
             * im jeweiligen Bereich einfach nichts angezeigt wird. Werden sie jedoch
             * mitgegeben, müssen sie mit forEach(element =&gt; { … }) iteriert werden
             * können, um ihren Inhalt in den DOM-Baum zu integrieren.
             *
             * Wichtig ist, dass die übergebenen Elemente noch an keiner Stelle im
             * DOM vorhanden sein dürfen. Werden die Elemente in der index.html
             * als Vorlage definiert, muss hier deshalb eine Kopie anstelle der
             * Elemente selbst übergeben werden!
             *
             * @param {Object} content Objekt mit den anzuzeigenden DOM-Elementen
             */
            _switchVisibleContent(content) {
                // &lt;header&gt; und &lt;main&gt; des HTML-Grundgerüsts ermitteln
                let app = document.querySelector("#app");
                let header = document.querySelector("#app &gt; header");
                let main = document.querySelector("#app &gt; main");

                // Zuvor angezeigte Inhalte entfernen
                // Bei der Topbar nur die untere Zeile, im Hauptbereich alles!
                app.className = "";
                header.querySelectorAll(".bottom").forEach(e =&gt; e.parentNode.removeChild(e));
                main.innerHTML = "";

                // CSS-Klasse übernehmen, um die viewspezifischen CSS-Regeln zu aktivieren
                if (content && content.className) {
                    app.className = content.className;
                }

                // Neue Inhalte der Topbar einfügen
                if (content && content.topbar) {
                    content.topbar.forEach(element =&gt; {
                        element.classList.add("bottom");
                        header.appendChild(element);
                    });
                }

                // Neue Inhalte des Hauptbereichs einfügen
                if (content && content.main) {
                    content.main.forEach(element =&gt; {
                        main.appendChild(element);
                    });
                }
            }
        </code>
    </pre>
    <p>
        Der Quellcode ist im Grunde genommen nicht sehr kompliziert. Dennoch gehen wir ihn an dieser
        Stelle kurz durch, um sicherzustellen, dass du ihn auch wirklich verstehst:
    </p>
    <ol>
        <li>
            Zunächst greift die Methode auf das DOM zu, um sich die
            <span class="cmd">&lt;section id="app"&gt;</span> sowie die darin enthaltenen
            <span class="cmd">&lt;header&gt;</span>- und
            <span class="cmd">&lt;main&gt;</span>-Elemente zu besorgen.
        </li>
        <li>
            Anschließend werden die zuvor sichtbaren Inhalte verworfen. Im Falle der
            Topbar mit einer <span class="cmd">forEach()</span>-Schleife, die nur
            die Elemente der unteren Zeile erwischt. Im Hauptbereich wird stattdessen
            das <span class="cmd">innerHTML</span>-Attribut überschrieben, was
            seinen kompletten Inhalt löscht.
        </li>
        <li>
            Dann wird mit einer <span class="cmd">if</span>-Abfrage gebprüft, ob
            ob das <span class="cmd">content</span>-Objekt ein Attribut mit dem
            Namen <span class="cmd">classList</span> enthält. Falls ja wird die
            CSS-Klasse des <span class="cmd">&lt;section id="app"&gt;</span>
            entsprechend abgeändert, damit etwaige CSS-Regeln, die sich auf
            diese Klasse beziehen, wirksam werden können.
        </li>
        <li>
            Danach wird geprüft, ob ein neuer Inhalt für die Topbar übergeben wurde.
            Falls ja, wird in einer Schleife jedem dieser Elemente die CSS-Klasse
            <span class="cmd">bottom</span> hinzugefügt, um sie in der untere Zeile
            der Topbar zu verankern. Gleichzeitig werden sie an den
            <span class="cmd">&lt;header&gt;</span> innerhalb von
            <span class="cmd">&lt;section id="app"&gt;</span> angehängt.
        </li>
        <li>
            Dann erfolgt mit einer ähnlichen Abfrage eine Prüfung für den Hauptbereich
            der App, nur dass den Elementen hier keine zusätzliche CSS-Klasse mitgegeben
            werden muss.
        </li>
    </ol>

    <p>
        Mit dieser Methode können wir nun den angezeigten Inhalt der App variieren. Wirklich
        anwenderfreundlich ist sie aber noch nicht, da wir ihr, um eine neue View anzuzeigen,
        genau die hierfür notwendigen DOM-Elemente mitgegeben müssen. Besser wäre es jedoch,
        wenn wir eine bestimmte View einfach aufrufen könnten, ohne genau zu wissen, wie sie
        letztlich aufgebaut ist. Wir benötigen daher für jede View eine weitere Methode, die
        genau diesen Zweck erfüllt. Doch hierfür müssen wir uns erst noch überlegen, wie wir
        den restlichen Quellcode der App weiter strukturieren sollen.
    </p>

    <h3>Eine Klasse je Bildschirmseite</h3>
    <p>
        Natürlich könnten wir die komplette Anwendungslogik einfach in der Datei <span class="fn">src/app.js</span>
        und der Klasse <span class="cmd">App</span> ausprogrammieren. Dem Computer wäre das ziemlich gleich.
        Allerdings wissen wir, dass die beiden Views mit der Übersicht und zur Anzeige eines Songtexts nicht
        wirklich viel gemeinsam haben. Alles in eine Klasse zu packen wäre daher ziemlich unübersichtlich.
        Das alte Sprichwort „teile und herrsche” liefert stattdessen viel bessere Ergebnisse, da es uns an die
        <a href="https://t3n.de/news/prinzipien-software-entwicklung-solid-615556/" target="_blank">SOLID-Kriterien</a>
        und hier insbesondere an das Single-Responsibility-Prinzip erinnert. Es liegt deshalb nahe, für
        jede Bildschirmseite eine eigene Klasse vorzusehen. Und für jede Klasse dementsprechend eine
        eigene JavaScript-Datei und ein eigenes Stylesheet, die wir, um die Übersichtlichkeit noch
        weiter zu erhöhen, jeweils in ein eigenes Verzeichnis packen.
    </p>
    <p>
        Bevor wir also weiter programmieren, lege zunächst folgende Dateistruktur an. Die Dateien
        können dabei zunächst noch leer bleiben:
    </p>
    <ul>
        <li>
            <span class="fn">src/song-overview/song-overview.js:</span> Klasse <span class="cmd">SongOverview</span> für die Übersichtsseite
        </li>
        <li>
            <span class="fn">src/song-overview/song-overview.css:</span> Stylesheet für die Übersichtsseite
        </li>
        <li>
            <span class="fn">src/song-display-edit/song-display-edit.js:</span> Klasse <span class="cmd">SongDisplayEdit</span> für die Detailseite
        </li>
        <li>
            <span class="fn">src/song-display-edit/song-display-edit.css:</span> Stylesheet für die Detailseite
        </li>
    </ul>
    <p>
        Das Ergebnis sollte dann so aussehen:
    </p>
    <figure>
        <img src="02/navigation/neue-dateien.png" />
        <figcaption>Erweiterte Verzeichnisstruktur für die Übersichts- und die Detailseite</figcaption>
    </figure>
    <p>
        Die beiden Stylesheets sind am einfachsten. Hier wollen wir zunächst nur etwas Dummy-Inhalt
        einbauen, damit wir später sehen, ob sie auch wirklich ausgewertet werden. Füge daher in die
        Datei <span class="fn">src/song-overview/song-overview.css</span> folgende Zeile ein:
    </p>
    <pre data-gobble>
        <code class="css" data-gobble>
            /*
             * Dieses Stylesheet darf nur Selektoren beinhalten, die mit .song-overview
             * beginnen. Denn wir wollen nicht, dass hier Eigenschaften aus anderen Bereichen
             * der Anwendung überschrieben werden.
             */
            .song-overview main {
                color: orangered !important;
            }
        </code>
    </pre>
    <p>
        In die <span class="fn">src/song-display-edit/song-display-edit.css</span> füge folgende Zeilen:
    </p>
    <pre data-gobble>
        <code class="css" data-gobble>
            /*
             * Dieses Stylesheet darf nur Selektoren beinhalten, die mit .song-display-edit
             * beginnen. Denn wir wollen nicht, dass hier Eigenschaften aus anderen Bereichen
             * der Anwendung überschrieben werden.
             */
            .song-display-edit main {
                color: orchid !important;
            }
        </code>
    </pre>
    <p>
        Bei den beiden Klassen wird es hingegen schon interessanter, da wir uns noch gar
        keine Gedanken darüber gemacht haben, welche Methoden sie besitzen sollen und
        wann diesie aufgerufen werden. Letztlich gibt es auch gar keine universelle Lösung
        dafür, in der Praxis hat sich aber ganz unabhängig von der Art der Anwendung oder
        der verwendeten UI-Technologie folgende, grundlegende Struktur bewährt:
    </p>
    <ol>
        <li>
            Jedes Mal, wenn eine View aufgerufen wird, wird ein neues Objekt der dazugehörigen
            Klasse erzeugt. Das Objekt bleibt dabei so lange aktiv, wie die View sichtbar ist.
        </li>
        <li>
            Wird von einer View auf dieselbe View nur mit anderen Daten gewechselt (zum Beispiel
            von der Detailseite eines Songs zur Detailseite eines anderen Songs), wird hierfür
            ebenfalls ein neues Objekt erzeugt.
        </li>
        <li>
            Denn dies ermöglicht es, die Klassen einfach zu halten und die für die Ermittlung der
            anzuzeigenden Daten benötigten Informationen wie die Song-ID einfach dem Konstruktor
            zu übergeben.
        </li>
        <li>
            Bevor eine neue View aufgerufen wird, wird die Methode <span class="cmd">onShow()</span>
            des jeweiligen Objekts aufgerufen.
        </li>
        <li>
            Davor wird jedoch erst die Methode <span class="cmd">onLeave()</span> der aktuell sichtbaren
            View aufgerufen, um ihr die Möglichkeit zu geben, Aufräumarbeiten durchzuführen oder den
            Seitenwechsel zu unterbinden.
        </li>
        <li>
            Eine Methode mit dem Namen <span class="cmd">getTitle()</span> gibt den Titel der aktuellen
            View zurück, um ihn in der Titelzeile des Browserfensters anzuzeigen.
        </li>
        <li>
            Sobald eine View verlassen wurde, kann das dazugehörige Objekt abgeräumt werden.
        </li>
    </ol>
    <p>
        Damit haben wir einen klaren Lebenszyklus definiert, der genau vorschreibt, zu welchem Zeitpunkt
        neue Objekte entstehen, welche Methoden dementsprechend aufgerufen werden und wann die Objekte
        wieder verschwinden. Außerdem haben wir eine Möglichkeit geschaffen, besondere Fälle wie das
        Vorliegen nicht gespeicherter Daten abzufangen, bei denen wir den Anwender erst fragen müssen,
        ob er seine Änderungen sichern will, oder wir den Aufruf der Folgeseite ganz einfach unterbinden.
    </p>
    <p>
        Die Datei <span class="fn">src/song-overview/song-overview.js</span> soll somit folgenden Inhalt besitzen:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            "use strict";

            import stylesheet from "./song-overview.css";

            /**
             * View mit der Übersicht der vorhandenen Songs.
             */
            class SongOverview {
                /**
                 * Konstruktor.
                 * @param {Objekt} app Zentrales App-Objekt der Anwendung
                 */
                constructor(app) {
                    this._app = app;
                }

                /**
                 * Von der Klasse App aufgerufene Methode, um die Seite anzuzeigen. Die
                 * Methode gibt daher ein passendes Objekt zurück, das an die Methode
                 * _switchVisibleContent() der Klasse App übergeben werden kann, um ihr
                 * die darzustellenden DOM-Elemente mitzuteilen.
                 *
                 * @return {Object} Darzustellende DOM-Elemente gemäß Beschreibung der
                 * Methode App._switchVisibleContent()
                 */
                onShow() {
                    // Machen wir gleich
                }

                /**
                 * Von der Klasse App aufgerufene Methode, um festzustellen, ob der Wechsel
                 * auf eine neue Seite erlaubt ist. Wird hier true zurückgegeben, wird der
                 * Seitenwechsel ausgeführt.
                 *
                 * @param  {Function} goon Callback, um den Seitenwechsel zu einem späteren
                 * Zeitpunkt fortzuführen, falls wir hier false zurückgeben
                 * @return {Boolean} true, wenn der Seitenwechsel erlaubt ist, sonst false
                 */
                onLeave(goon) {
                    return true;
                }

                /**
                 * @return {String} Titel für die Titelzeile des Browsers
                 */
                get title() {
                    return "Übersicht";
                }
            }

            export default SongOverview;
        </code>
    </pre>
    <p>
        Die Datei <span class="fn">src/song-display-edit/song-display-edit.js</span> soll hingegen
        folgenden Inhalt besitzen:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            "use strict";

            import stylesheet from "./song-display-edit.css";

            /**
             * View zur Anzeige oder zum Bearbeiten eines Songs.
             */
            class SongDisplayEdit {
                /**
                 * Konstruktor.
                 *
                 * @param {Objekt} app  Zentrales App-Objekt der Anwendung
                 * @param {String} id   ID des darzustellenden Songs
                 * @param {String} mode "new", "display" oder "edit"
                 */
                constructor(app, id, mode) {
                    this._app = app;
                    this._id = id;
                    this._mode = mode;
                }

                /**
                 * Von der Klasse App aufgerufene Methode, um die Seite anzuzeigen. Die
                 * Methode gibt daher ein passendes Objekt zurück, das an die Methode
                 * _switchVisibleContent() der Klasse App übergeben werden kann, um ihr
                 * die darzustellenden DOM-Elemente mitzuteilen.
                 *
                 * @return {Object} Darzustellende DOM-Elemente gemäß Beschreibung der
                 * Methode App._switchVisibleContent()
                 */
                onShow() {
                    // Machen wir gleich
                }

                /**
                 * Von der Klasse App aufgerufene Methode, um festzustellen, ob der Wechsel
                 * auf eine neue Seite erlaubt ist. Wird hier true zurückgegeben, wird der
                 * Seitenwechsel ausgeführt.
                 *
                 * @param  {Function} goon Callback, um den Seitenwechsel zu einem späteren
                 * Zeitpunkt fortzuführen, falls wir hier false zurückgeben
                 * @return {Boolean} true, wenn der Seitenwechsel erlaubt ist, sonst false
                 */
                onLeave(goon) {
                    return true;
                }

                /**
                 * @return {String} Titel für die Titelzeile des Browsers
                 */
                get title() {
                    switch (this._mode) {
                        case "new":
                            return "Song hinzufügen";
                        case "edit":
                            return "Song bearbeiten";
                        default:
                            return "Song anzeigen";
                    }
                }
            }

            export default SongDisplayEdit;
        </code>
    </pre>

    <h3>Weitere Methoden für die Klasse App</h3>
    <p>
        Da der Vertrag mit dem View-Klassen nun klar ist, besitzen wir alle Informationen, um die
        Klasse <span class="cmd">App</span> zu Ende zu programmieren. Füge deshalb über der Methode
        <span class="cmd">_switchVisibleContent()</span> eine neue Methode mit dem Namen
        <span class="cmd">_switchVisibleView()</span> ein, die sie aufruft und hierfür ein
        View-Objekt entgegen nimmt:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            /**
             * Hilfsklasse zum Umschalten auf eine neue Seite. Sie ruft zunächst die
             * Methode onLeave() der gerade sichtbaren View auf und prüft damit, ob
             * die View verlassen werden kann. Falls ja ruft sie die Methode onShow()
             * der neuen View auf und übergibt das Ergebnis an die eigene Methode
             * _switchVisibleContent(), um den sichtbaren Inhalt der Seite auszutauschen.
             *
             * @param  {Object} view View-Objekt mit einer onShow()-Methode
             * @return {Boolean} Flag, ob die neue Seite aufgerufen werden konnte
             */
            _switchVisibleView(view) {
                // Callback, mit dem die noch sichtbare View den Seitenwechsel zu einem
                // späteren Zeitpunkt fortführen kann, wenn sie in der Methode onLeave()
                // false zurückliefert. Dadurch erhält sie die Möglichkeit, den Anwender
                // zum Beispiel zu fragen, ob er ungesicherte Daten speichern will,
                // bevor er die Seite verlässt.
                let goon = () =&gt; this._switchVisibleView(view);

                // Aktuelle View fragen, ob eine neue View aufgerufen werden darf
                if (this._currentView && !this._currentView.onLeave(goon)) {
                    return false;
                }

                // Alles klar, aktuelle View nun wechseln
                document.title = `${this._title} – ${view.title}`;

                this._currentView = view;
                this._switchVisibleContent(view.onShow());
                return true;
            }

            /**
             * …
             */
            _switchVisibleContent(content) {
                …
            }
        </code>
    </pre>
    <p>
        Die zwei Instanzattribute <span class="cmd">this._currentView</span> und
        <span class="cmd">this._title</span> müssen hierfür noch im Konstruktor
        definiert werden:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            /**
             * Konstruktor.
             */
            constructor() {
                this._title = "My Songbook";
                this._currentView = null;
            }
        </code>
    </pre>
    <p>
        Und damit das Ganze einfach zu verwenden ist, legen wir nun für jede View eine
        eigene, für die öffentliche Verwendung freigebene Methode an, mit der sie überall
        in der App aufgerufen werden kann. Die Methode <span class="cmd">start()</span>
        passen wir bei der Gelegenheit dann auch gleich noch an, damit beim Aufruf der App
        immer die Überssichtsseite geladen wird:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            …
            import SongDisplayEdit from "./song-display-edit/song-display-edit.js";
            import SongOverview from "./song-overview/song-overview.js";

            /**
             * …
             */
            class App {
                …

                /**
                 * Ab hier beginnt die Anwendung zu laufen.
                 */
                start() {
                    this.showSongOverview();
                }

                /**
                 * Aufruf der Übersichtsseite der vorhandenen Songs.
                 * @return {Boolean} Flag, ob die neue Seite aufgerufen werden konnte
                 */
                showSongOverview() {
                    let view = new SongOverview(this);
                    this._switchVisibleView(view);
                }

                /**
                 * Aufruf der Detailseite zur Anzeige oder zum Bearbeiten eines Songs.
                 *
                 * @param  {String} id Song-ID
                 * @param  {String} mode "new", "display" oder "edit"
                 * @return {Boolean} Flag, ob die neue Seite aufgerufen werden konnte
                 */
                showSongDisplayEdit(id, mode) {
                    let view = new SongDisplayEdit(this, id, mode);
                    this._switchVisibleView(view);
                }

                /**
                 * …
                 */
                _switchVisibleView(view) {
                    …
                }
            }
        </code>
    </pre>

    <h3>Ausprogrammieren der onShow()-Methoden</h3>
    <p>
        Eine winzige Kleinigkeit fehlt jetzt aber noch, bevor das Ganze auch wirklich funktioniert:
        Wir müssen noch die Methode <span class="cmd">onShow()</span> unserer beiden View-Klassen
        ausprogrammieren. Denn noch übergeben wir dem <span class="cmd">App</span>-Objekt keine
        DOM-Elemente zum Anzeigen und wir registrieren auch noch keine Event Handler, mit denen
        der Anwender zwischen den Seiten umherschalten könnte.
    </p>
    <p>
        Öffne daher noch einmal die Datei <span class="fn">src/song-overview/song-overview.js</span>
        und ersetze die <span class="cmd">onShow()</span>-Methode durch die nun folgende Version:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            onShow() {
                // Anzuzeigende HTML-Elemente ermitteln
                let section = document.querySelector("#song-overview").cloneNode(true);

                let content = {
                    className: "song-overview",
                    topbar: section.querySelectorAll("header &gt; *"),
                    main: section.querySelectorAll("main &gt; *"),
                };

                // Event Handler registrieren
                let newSongItem = section.querySelector("header .item.new-song");

                newSongItem.addEventListener("click", () =&gt; {
                    this._app.showSongDisplayEdit("", "new");
                })

                // Ergebnis zurückliefern
                return content;
            }
        </code>
    </pre>
    <p>
        In der Datei <span class="fn">src/song-display-edit/song-display-edit.js</span> ersetze
        die <span class="cmd">onShow()</span>-Methode durch folgende Version:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            onShow() {
                // Anzuzeigende HTML-Elemente ermitteln
                let section = document.querySelector("#song-display-edit").cloneNode(true);

                let content = {
                    className: "song-display-edit",
                    topbar: section.querySelectorAll("header &gt; *"),
                    main: section.querySelectorAll("main &gt; *"),
                };

                // Event Handler registrieren
                let overviewItem = section.querySelector("header .item.overview");

                overviewItem.addEventListener("click", () =&gt; {
                    this._app.showSongOverview();
                })

                // Ergebnis zurückliefern
                return content;
            }
        </code>
    </pre>
    <p>
        Beide Methoden sind prinzipiell gleich aufgebaut. Um sie zu verstehen müssen wir allerdings
        erst einen Bogen zurück zum Anfang machen. Dort haben wir nämlich den HTML-Code der Datei
        <span class="fn">src/index.html</span> etwas umgeräumt und zwei
        <span class="cmd">&lt;section&gt;</span>-Elemente für die beiden Unterseiten angelegt.
        Auf diese Elemente greifen wir nun zu, um die anzuzeigenden HTML-Elemente aus dem Document
        Object Model auszulesen. Allerdings erzeugen wir durch Aufruf der Methode
        <span class="cmd">cloneNode(true)</span> eine tiefe Kopie der ausgelesenen Elemente, da der
        Kommentar vor der Methode <span class="cmd">App._switchVisibleContent()</span> eindeutig
        besagt, dass ihr keine Elemente übergeben werden dürfen, die sich bereits im DOM-Baum der
        HTML-Seite befinden.
    </p>
    <p>
        Mit diesen Elementen bauen wir dann das <span class="cmd">content</span>-Objekt auf, welches
        die Methode <span class="cmd">App._switchVisibleContent()</span> von uns erwartet. Daraufhin
        suchen wir uns in der Topbar jeweils ein Element, mit dem der Anwender zwischen den Seiten
        umschalten kann und registrieren einen Click-Event-Handler darauf. In der entsprechenden
        Handler-Funktion rufen wir daher die jeweils richtige <span class="cmd">show…()</span>-Methode
        des <span class="cmd">App</span>-Objekts auf, um die Seite tatsächlich zu wechseln.
    </p>
    <p>
        Und am Ende geben wir die <span class="cmd">content</span>-Struktur zurück, damit die Methode
        <span class="cmd">App._switchVisibleView()</span>, von der wir aufgerufen werden, sie an die
        Methode <span class="cmd">App._switchVisibleContent()</span> übergeben kann.
    </p>
    <p>
        Wenn du alles richtig gemacht hast, solltest du nun zwischen den beiden Seiten umherschalten
        können. Dabei sollte dann auch aufgrund der unterschiedlichen Stylesheets die Schriftfarbe von
        orange auf lila wechseln, wie in der folgenden Animation dargestellt.
    </p>
    <figure>
        <img src="02/navigation/seiten-wechseln.gif" class="border"/>
        <figcaption>All der Mühen Lohn: Eine funktionierende Navigation innerhalb der App</figcaption>
    </figure>
</section>

<!-- ––––––––––––––––––––––––––––––––––– -->
<!-- Integration des Single Page Routers -->
<!-- ––––––––––––––––––––––––––––––––––– -->
<section data-title="Integration des Single Page Routers">
    <p class="git-commit">
        Git Commit:
        <a href="https://github.com/DennisSchulmeister/dhbwka-wwi-webprog-my-songbook/tree/f3c23b477cbe7bed0c182bbcc00526452f9a1f60" target="_blank">f3c23b4</a>
    </p>

    <p>
        Zugegeben, das war schon eine ganze Menge Code, der da eben zusammenpassen musste, bevor wir
        wirklich zwischen den beiden Seiten hin und her schalten konnten. Doch damit hast du nun eine
        vollständige Grundstruktur zur Verfügung, die im Grunde genommen auf jede Art von Anwendung
        ausgerollt werden kann. Du musst nur die beiden Klassen für die Songübersicht und die Songdetails
        durch eigene Klassen ersetzen. Ein paar Nachteile hat die bisherige Lösung aber noch, weshalb
        wir sie an dieser Stelle noch etwas verfeinern wollen:
    </p>
    <ul>
        <li>
            Die Views unserer App besitzen keine eindeutigen URLs und können daher nur per JavaScript
            aufgerufen werden. Dadurch kann eine View (zum Beispiel für einen bestimmten Song) nicht
            durch Eingabe der richtigen Adresse im Browser direkt aufgerufen werden.
        </li>
        <li>
            Auch können wir keine einfachen <span class="cmd">&lt;a&gt;</span>-Elemente innerhalb des
            HTML-Codes verwenden, um einen Link auf eine andere View zu platzieren. Wir müssen immer
            Event-Handler-Funktionen schreiben und den Seitenwechsel mit JavaScript durchführen.
        </li>
        <li>
            Der Zurück-Button des Browsers sowie ganz allgemein die Nutzung des Browserverlaufs
            wird nicht unterstützt.
        </li>
    </ul>
    <p>
        Die Lösung all dieser Probleme hört auf den Namen
        <a href="https://css-tricks.com/using-the-html5-history-api/" target="_blank">HTML5 History API</a>.
        Doch anstatt jetzt uns jetzt selbst damit herumzuschlagen (die Details richtig hinzubekommen ist
        tatsächlich nicht ganz einfach), wollen wir auf eine Library zurückgreifen, die das alles viel
        besser kann. Wir wollen einen „Single Page Router” verwenden, der es uns ganz einfach ermöglicht,
        eine URL-Struktur für unsere App zu definieren und dabei festzulegen, was beim Aufruf welcher URL
        passieren soll. Den Grundstock dafür haben wir bereits im letzten Teilkapitel gelegt. Jetzt geht
        es nur noch darum, die ganze Sache ein wenig zu optimieren.
    </p>

    <h3>Installation von Navigo</h3>
    <p>
        Die Library, die wir hier verwenden wollen, heißt <a href="https://github.com/krasimir/navigo" target="_blank">Navigo</a>.
        Sie implementiert einen einfachen Single Page Router, der im Gegensatz zu vielen ähnlichen
        Bibliotheken ganz ohne fremde Abhängigkeiten auskommt und daher in nahezu jede beliebige
        Webanwendung integriert werden kann. Und wie das
        <a href="https://github.com/krasimir/navigo/blob/master/README.md" target="_blank">README auf GitHub</a>
        andeutet, scheint sie relativ einfach nutzbar zu sein. Grund genug also mal wieder das gute alte
        Terminal anzuschmeißen, mit einem beherzten <span class="cmd">cd "Verzeichnisname"</span> in unser
        Projektverzeichnis zu wechseln und die Library mit folgendem Befehl zu installieren:
    </p>
    <p class="cmd">
        npm add --save-dev navigo
    </p>
    <p>
        Die installation sollte dabei in gewohnter node.js-Manier schnell und geräuschlos über die Bühne gehen.
    </p>
    <figure>
        <img src="02/spa-router/installation-navigo.jpg" />
        <figcaption>Installation des <span class="scr">navigo</span> Single Page Routers</figcaption>
    </figure>

    <h3>Anpassungen an der App-Klasse</h3>
    <p>
        Um den Single Page Router zu initialisieren müssen wir ein paar kleinere Umbauten der
        <span class="cmd">App</span>-Klasse vornehmen. Allerdings nichts allzu dramatisches.
        Zunächst müssen wir die Klasse <span class="cmd">Navigo</span> aus dem Modul
        <span class="fn">navigo/lib/navigo.js</span> importieren, was wir dank Parcel einfach
        tun können, ohne hierfür auch nur eine Datei umkopieren zu müssen. Beachte, dass der
        Pfad in der <span class="cmd">import</span>-Anweisung hierfür <u>nicht</u> mit
        <span class="cmd">./</span> anfangen darf.
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            …
            import Navigo from "navigo/lib/navigo.js";
            import SongDisplayEdit from "./song-display-edit/song-display-edit.js";
            import SongOverview from "./song-overview/song-overview.js";
            …

            class App { … }
        </code>
    </pre>
    <p>
        Danach können wir den Konstruktor von <span class="cmd">App</span> wie folgt erweitern:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            constructor() {
                this._title = "My Songbook";
                this._currentView = null;

                // Single Page Router aufsetzen
                this._router = new Navigo();
                this._currentUrl = "";
                this._navAborted = false;

                this._router.on({
                    "*":                       () =&gt; this.showSongOverview(),
                    "/song/new/":              () =&gt; this.showSongDisplayEdit("", "new"),
                    "/song/display/:id/":  params =&gt; this.showSongDisplayEdit(params.id, "display"),
                    "/song/edit/:id/":     params =&gt; this.showSongDisplayEdit(params.id, "edit"),
                });

                this._router.hooks({
                    after: (params) =&gt; {
                        if (!this._navAborted) {
                            // Navigation durchführen, daher die neue URL merken
                            this._currentUrl = this._router.lastRouteResolved().url;
                        } else {
                            // Navigation abbrechen, daher die URL in der Adresszeile
                            // auf den alten Wert der bisherigen View zurücksetzen
                            this._router.pause(true);
                            this._router.navigate(this._currentUrl);
                            this._router.pause(false);

                            this._navAborted = false;
                        }
                    }
                });
            }
        </code>
    </pre>
    <p>
        Das sieht jetzt erst einmal sehr komplex aus. Wichtig ist aber nur der Aufruf von
        <span class="cmd">this._router.on({…})</span>, der das Herzstück dieser Anpassung
        darstellt. Alle anderen Zeilen, bis auf die Erzeugung des Router-Objekts selbst
        könnte man auch weglassen. Sie werden nur benötigt, weil wir die Navigation in
        bestimmten Fällen unterbrechen wollen und wie Navigo hierfür ein wenig zum Mitspielen
        überreden müssen.
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            this._router.on({
                "*":                       () =&gt; this.showSongOverview(),
                "/song/new/":              () =&gt; this.showSongDisplayEdit("", "new"),
                "/song/display/:id/":  params =&gt; this.showSongDisplayEdit(params.id, "display"),
                "/song/edit/:id/":     params =&gt; this.showSongDisplayEdit(params.id, "edit"),
            });
        </code>
    </pre>
    <p>
        Diese Zeilen definieren die URL-Struktur der App, wobei jedes URL-Pattern mit einer
        anonymen Lambda-Funktion (zu erkennen am Doppelpfeil <span class="cmd">=&gt;</span>)
        verknüpft ist. Es liegt nahe, dass der Router die entsprechende Lambda-Funktionen
        aufruft, wenn eine URL erkannt wurde, um dadurch den sichtbaren Inhalt zu wechseln.
        Praktischerweise können wir hier unsere Methoden von vorhin direkt weiterverwenden.
    </p>
    <p>
        In der <span class="cmd">start()</span>-Methode müssen wir nun nicht mehr explizit
        die Übersichtsseite aufrufen. Stattdessen sagen wir dem Router, dass er nun dafür
        verantwortlich ist, die URL, mit der die gesamte App gestartet wurde, auszuwerten,
        um die erste View zu ermitteln:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            start() {
                this._router.resolve();
            }
        </code>
    </pre>
    <p>
        Das sind eigentlich schon alle Änderungen an der Klasse <span class="cmd">App</span>.
        Damit aber das Unterbrechen der Navigation richtig funktioniert, müssen wir die
        Methode <span class="cmd">_switchVisibleView()</span> noch ein klein wenig modifizieren.
        Die neue Version lautet wie folgt:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            _switchVisibleView(view) {
                // Callback, mit dem die noch sichtbare View den Seitenwechsel zu einem
                // späteren Zeitpunkt fortführen kann, wenn sie in der Methode onLeave()
                // false zurückliefert. Dadurch erhält sie die Möglichkeit, den Anwender
                // zum Beispiel zu fragen, ob er ungesicherte Daten speichern will,
                // bevor er die Seite verlässt.
                let newUrl = this._router.lastRouteResolved().url;
                let goon = () =&gt; {
                    // ?goon an die URL hängen, weil der Router sonst nicht weiternavigiert
                    this._router.navigate(newUrl + "?goon");
                }

                // Aktuelle View fragen, ob eine neue View aufgerufen werden darf
                if (this._currentView && !this._currentView.onLeave(goon)) {
                    this._navAborted = true;
                    return false;
                }

                // Alles klar, aktuelle View nun wechseln
                document.title = `${this._title} – ${view.title}`;

                this._currentView = view;
        </code>
    </pre>
    <p>
        Im Vergleich zur alten Version setzen wir hier noch ein Kennzeichen, wenn die
        Navigation durch die aktuell sichtbare View unterbunden wird, damit wir im weiter
        oben definieren „After Hook” von Navigo die Adresszeile des Browsers wieder auf
        die alte URL zurücksetzen können. Außerdem müssen wir die Callbackfunktion
        <span class="cmd">goon()</span> ein wenig anders implementieren.
    </p>
    <p>
        Zu guter Letzt kommen noch zwei weitere Zeilen ganz am Ende der
        <span class="cmd">_switchVisibleContent</span>-Methode hinzu, um
        die in einer View enthaltenen Links auf andere App-Seiten zu aktiveren.
        Die Links werden hierfür am zusätzlichen HTML-Attribut <span class="cmd">data-navigo</span>
        erkannt (siehe weiter unten in der <span class="fn">src/index.html</span>):
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            _switchVisibleContent(content) {
                …
                // Navigo an die Links in der View binden
                this._router.updatePageLinks();
            }
        </code>
    </pre>

    <h3>Vereinfachung der restlichen Quellcodes</h3>
    <p>
        Undank sei der Welten Lohn, sagt man. Nicht jedoch an dieser Stelle. Zwar ist
        die Klasse <span class="cmd">App</span> durch die neuerlichen Änderungen nochmal
        ein klein wenig komplexer geworden, dafür vereinfachen sich aber alle anderen
        Quellcodes. Und wir haben eine ordentliche URL-Struktur, mit der wir jede View der
        App über eine eigene URL direkt aufrufen oder als Lesezeichen im Browser speichern
        können (sofern der Webserver richtig konfiguriert wurde). Und der Zurück-Button des
        Browsers tut nun auch das, was er soll.
    </p>
    <p>
        Zunächst einmal wollen wir die <span class="cmd">onShow()</span>-Methode der beiden
        View-Klassen etwas aufräumen. Hier fallen die Event Handler komplett weg, so dass die
        Methoden nun nur noch so aussehen:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            // src/song-overview/song-overview.js:
            onShow() {
                let section = document.querySelector("#song-overview").cloneNode(true);

                return {
                    className: "song-overview",
                    topbar: section.querySelectorAll("header &gt; *"),
                    main: section.querySelectorAll("main &gt; *"),
                };
            }
        </code>
    </pre>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            // src/song-display-edit/song-display-edit.js:
            onShow() {
                let section = document.querySelector("#song-display-edit").cloneNode(true);

                return {
                    className: "song-display-edit",
                    topbar: section.querySelectorAll("header &gt; *"),
                    main: section.querySelectorAll("main &gt; *"),
                };
            }
        </code>
    </pre>
    <p>
        Wir können tatsächlich die Hälfte des Quellcodes einfach wegschmeißen! Und da wir zum
        Umschalten zwischen den Views nun kein explizites JavaScript mehr benötigen, können wir
        die <span class="fn">src/index.html</span> jetzt auch so anpassen, dass hierfür einfache
        Links verwendet werden. Die Definitionen innerhalb der Topbar ändern sich dadurch wie folgt:
    </p>
    <pre data-gobble>
        <code class="html" data-gobble>
            &lt;div class="item"&gt;
                &lt;a href="/song/new/" data-navigo&gt;
                    Song hinzufügen
                &lt;/a&gt;
            &lt;/div&gt;

            …

            &lt;div class="item"&gt;
                &lt;a href="/" data-navigo&gt;
                    Zurück zur Übersicht
                &lt;/a&gt;
            &lt;/div&gt;
        </code>
    </pre>
    <p>
        Wenn es gut läuft, sollte das Ergebnis nun wie folgt aussehen. Beachte dabei, wie sich
        die URL in der Adresszeile des Browsers automatisch ändert:
    </p>
    <figure>
        <img src="02/spa-router/seiten-wechseln.gif" class="border"/>
        <figcaption>Navigation innerhalb der App mit Hilfe des Single Page Routers</figcaption>
    </figure>

    <h3>Hinweis zum Parcel-Entwicklungsserver</h3>
    <p>
        Leider verträgt sich das Prinzip eines Single Page Routers nicht immer 100%ig mit dem
        Hot Module Replacement (automatisches Nachladen der Seite bei einer Quellcodeänderung)
        des Parcel-Entwicklungsservers. Deshalb kann es nach einer Änderung am Quellcode passieren,
        dass die Seite zwar neulädt, in der Adresszeile des Browsers aber noch eine alte URL steht.
        In diesem Fall entferne am Besten alle Bestandteile nach der Port-Nummer der URL und lade
        die Seite erneut. Dadurch kannst du Navigo und Parcel wieder in Einklang bringen. In der
        Produktivversion der App kann das nicht passieren, da es hier ein automatisches Neuladen
        der Seite ja nicht gibt. Allerdings muss der Webserver dort so konfiguriert werden, dass
        er immer den Inhalt der Datei <span class="fn">index.html</span> zurückliefert, wenn auf
        einen unbekannten Pfad zugegriffen wird.
    </p>
</section>

<!-- ––––––––––––––––––––––––––– -->
<!-- Definition des Datenmodells -->
<!-- ––––––––––––––––––––––––––– -->
<section data-title="Definition des Datenmodells">
    <p class="git-commit">
        Git Commit:
        <a href="https://github.com/DennisSchulmeister/dhbwka-wwi-webprog-my-songbook/tree/50d6ceb20b42415f71e8461bf2d59b8681792969" target="_blank">50d6ceb</a>
    </p>

    <h3>Welche Möglichkeiten kommen in Frage?</h3>
    <p>
        Würden wir eine serverseitige Webanwendung anstelle einer Browser App schreiben, wäre die
        Frage, wie die Daten der Anwendung gespeichert werden sollen, ganz einfach zu beantworten.
        Sehr wahrscheinlich könnten wir die Daten einfach in einer relationalen Datenbank ablegen,
        deren Integration das Webframework unserer Wahl für uns regelt. Oder wir könnten auf eine
        der vielen NoSQL-Datenbanken zugreifen, die als Alternative zu den klassischen SQL-Datenbanken
        angeboten werden. Innerhalb einer reinen Browser App ohne Backend-Sever haben wir diese
        Möglichkeiten nicht. Doch auch hier müssen wir auf eine komfortable Datenhaltung nicht
        verzichten, sondern können zwischen den folgenden Alternativen wählen:
    </p>
    <ul>
        <li>
            Wir könnten eine Cloud-Datenbank wie
            <a href="https://firebase.google.com/" target="_blank">Google Firebase</a> nutzen.
        </li>
        <li>
            Wir könnten einen Datenbankserver mit HTTP-Schnittstelle wie
            <a href="http://couchdb.apache.org/" target="_blank">Apache CouchDB</a>
            via AJAX aufrufen.
        </li>
        <li>
            Wir könnten mit der
            <a href="https://www.tutorialspoint.com/html5/html5_indexeddb.htm" target="_blank">IndexDB API</a>
            von HTML5 die Daten im Browser speichern.
        </li>
        <li>
            Wir könnten eine Bibliothek wie <a href="http://dexie.org" target="_blank">Dexie</a> nutzen,
            die einfacher als IndexDB funktioniert.
        </li>
    </ul>
    <p>
        Man kann hier nicht sagen, welche Lösung besser als die andere ist, da sie alle für
        bestimmte Anwendungen sinnvoll sein können. IndexDB ist dabei jedoch die aufwändigste
        Lösung, da die API sehr umfangreich und im Vergleich auch umständlicher zu nutzen ist.
        Die anderen Alternativen sind einfacher zu durchschauen und deshalb auch mit weniger
        Aufwand verbunden.
    </p>
    <p>
        In unserer Beispielanwendung haben wir uns aufgrund folgender Vorteile für
        Dexie entschieden:
    </p>
    <ul>
        <li>
            Die Bibliothek kann rein browserseitig ohne einen Datenbankserver im Hintergrund
            genutzt werden.
        </li>
        <li>
            Die API ist einfach aufgebaut und auf der Projektwebseite gut dokumentiert.
        </li>
        <li>
            Die API bietet nahezu alle Funktionen, die man von einer SQL-Datenbank
            gewohnt ist.
        </li>
        <li>
            Das Datenmodell kann versioniert werden, so dass es in späteren Anwendungsversionen
            ohne Datenverlust weiterentwickelt werden kann.
        </li>
    </ul>

    <h3>Installation von Dexie</h3>
    <p>
        Wie immer lässt sich Dexie mit <span class="cmd">npm</span> ganz einfach installieren.
        Allerdings müssen wir dieses Mal noch ein weiteres Paket installieren:
    </p>
    <p class="cmd">
        cd "Projektverzeichnis" <br />
        npm add --save-dev dexie <br />
        npm add --save-dev babel-plugin-transform-runtime
    </p>
    <figure>
        <img src="02/db/dexie-installation.png" />
        <figcaption>
            Installation von <span class="scr">dexie</span>
        </figcaption>
    </figure>
    <p>
        Anschließend musst du im Projektverzeichnis der App eine Datei mit dem Namen
        <span class="fn">.babelrc</span> anlegen. Sie muss folgenden Inhalt besitzen,
        damit die von Dexie zurückgelieferten, asynchronen
        <a href="https://scotch.io/tutorials/javascript-promises-for-dummies" target="_blank">Promise-Objekte</a>
        auch mit Parcel funktionieren:¹
    </p>
    <pre data-gobble>
        <code class="json" data-gobble>
            {
                "presets": [
                    ["env", {
                        "targets": {
                            "browsers": ["last 1 Chrome version"]
                        }
                    }]
                ]
            }
        </code>
    </pre>
    <p>
        ¹
        <small>
            Wir arbeiten dadurch um eine Art Bug in Parcel herum. Dafür wird auch das Paket
            <span class="scr">babel-plugin-transform-runtime </span> benötigt.
        </small>
    </p>
    <p>
        Dadurch stehen dir dann folgende Möglichkeiten in JavaScript zur Verfügung:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            // Dexie-Klasse importieren
            import Dexie from "dexie/dist/dexie.js";

            // Neue Datenbank mit zwei Tabellen definieren
            // ++id definiert ein automatisch hochgezähltes Schlüsselfeld.
            // Es müssen nur Felder angegeben werden, für die ein Index benötigt wird.
            let database = new Dexie("My-Songbook");

            database.version(1).stores({
                users: "++id, username",
                songtexts: "++id, artist, title",
            });

            // Neuen Datensatz anlegen
            database.songtexts.add({
                artist: "Queen",
                title:  "I Want To Break Free",
                format: "html",
                data:   "… HTML-String …",
            });

            // Vorhandenen Datensatz aktualisieren
            database.songtexts.put({
                id:     4711,
                artist: "Joe Cocker",
                title:  "I Come In Peace",
                format: "html",
                data:   "… HTML-String …",
            });

            // Vorhandenen Datensatz einlesen
            let song = await database.songtexts.get(815);

            // Vorhandenen Datensatz löschen
            database.songtexts.delete(721);

            // Alle vorhandenen Datensätze löschen
            database.songtexts.clear();

            // Vorhandene Einträge anhand einer Filter-Funktion durchsuchen
            // (als Alternative zu den eingebauten WHERE-Bedinungen von Dexie)
            // und das Ergebnis als Array zurückliefern
            let songs = await database.songtexts
                .filter(entry =&gt; entry.artist.toLowerCase().search("queen") &gt;= 0)
                .toArray();
        </code>
    </pre>
    <p>
        Darüber hinaus bietet Dexie noch einiges mehr, was wir in der Besipielanwendung
        allerdings nicht benötigen. Weitere Informationen bietet die
        <a href="http://dexie.org/docs/API-Reference">API-Beschreibung</a> auf der Webseite.
    </p>

    <h3>Kapselung der der Datenbankzugriffe</h3>
    <p>
        Aus Gründen der Übersichtlichkeit wollen wir auch hier das Single-Responsibility-Prinzip
        anwenden und alle Datenbankzugriffe in einer eigenen Klasse kapseln, anstatt sie über den
        gesamten Quellcode zu verteilen. Zwar ist die Dexie-API an und für sich bereits relativ
        einfach, wir können dadurch den Quellcode aber noch übersichtlicher machen und uns auch
        ein Stück weit von der API abschirmen, so dass wir sie im Zweifellsfall später relativ
        einfach ersetzen könnten. Lege daher eine neue Datei mit dem Namen
        <span class="fn">src/database.js</span> und folgendem Inhalt an:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
        "use strict";

        import Dexie from "dexie/dist/dexie.js";

        // Datenbankdefinition:
        //
        //   * ++id = Automatisch Hochgezählter Datenbankschlüssel
        //   * artist, title = Indexfelder für WHERE-Abfragen und die Sortierung
        //   * Alle anderen Felder müssen nicht deklariert werden!
        //   * Vgl. http://dexie.org/docs/API-Reference
        let database = new Dexie("My-Songbook");

        database.version(1).stores({
            songtexts: "++id, artist, title",
        });

        /**
         * Datenbankzugriffsklasse für Songtexte. Diese Klasse bietet verschiedene
         * Methoden, um Songtexte zu speichern und wieder auszulesen. Im Hintergrund
         * wird hierfür Dexie zur lokalen Speicherung im Browser genutzt.
         */
        class Songtexts {
        }

        export default
            database,
            Songtexts,
        };
        </code>
    </pre>
    <p>
        Diese Klasse wollen wir nun nach und nach um alle benötigten Methoden erweitern.
        Zunächst um eine Funktion zum Speichern neuer Songtexte:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            /**
             * Einen neuen Songtext speichern oder einen vorhandenen Songtext
             * aktualisieren. Das Songtext-Objekt sollte hierfür folgenden Aufbau
             * besitzen:
             *
             * {
             *     artist: "Name des Künstlers",
             *     title: "Name des Songs",
             *     format: "html",
             *     data: "HTML-String",
             * }
             *
             * @param  {Object}  songtext Zu speichernder Songtext
             * @return {Promise} Asynchrones Promise-Objekt
             */
            async saveNew(songtext) {
                return database.songtexts.add(songtext);
            }
        </code>
    </pre>
    <p>
        Dann um eine Funktion zum erneuten Speichern eines vorhandenen Songtexts:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            /**
             * Bereits vorhandenen Songtext aktualisieren.
             * @param  {Object}  songtext Zu speichernder Songtext
             * @return {Promise} Asynchrones Promise-Objekt
             */
            async update(songtext) {
                return database.songtexts.put(songtext);
            }
        </code>
    </pre>
    <p>
        Dann um zwei Funktionen zum Löschen von Songtexten:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            /**
             * Vorhandenen Songtext anhand seiner ID löschen.
             * @param  {String}  id ID des zu löschenden Songtexts
             * @return {Promise} Asynchrones Promise-Objekt
             */
            async delete(id) {
                return database.songtexts.delete(id);
            }

            /**
             * Löscht alle Songtexte!
             * @return {Promise} Asynchrones Promise-Objekt
             */
            async clear() {
                return database.songtexts.clear();
            }
        </code>
    </pre>
    <p>
        Sowie eine Funktion, um einen Songtext direkt auszulesen:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            /**
             * Vorhandenen Songtext anhand seiner ID auslesen.
             * @param  {String}  id ID des zu lesenden Songtexts
             * @return {Promise} Asynchrones Promise-Objekt mit dem Songtext
             */
            async getById(id) {
                return database.songtexts.get(id);
            }
        </code>
    </pre>
    <p>
        Und eine Funktion, die uns entweder alle Songtexte oder alle Texte
        anhand eines bestimmten Suchbegriffs zurückliefert:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            /**
             * Gibt eine Liste mit allen Songtexten zurück, deren Titel oder Künstler
             * den gesuchten Wert enthalten.
             *
             * @param  {String}  query Gesuchter Titel oder Künstler
             * @return {Promise} Asynchrones Promise-Objekt mit dem Suchergebnis
             */
            async search(query) {
                if (!query) query = "";
                query = query.toUpperCase();

                let result = database.songtexts.filter(songtext =&gt; {
                    let artist = songtext.artist.toUpperCase();
                    let title  = songtext.title.toUpperCase();
                    return artist.search(query) &gt; -1 || title.search(query) &gt; -1;
                });

                return result.toArray();
            }
        </code>
    </pre>
    <p>
        Die fertige Klasse sollte danach ungefähr so aussehen:
    </p>
    <figure>
        <img src="02/db/database-code.png" />
        <figcaption>
            Quellcode der fertigen <span class="cmd">Songtexts</span>-Klasse
        </figcaption>
    </figure>

    <h3>Ein kleiner Test vorab</h3>
    <p>
        Um die Funktionsweise der neuen Klasse zu testen, wollen wir etwas Testcode in die
        App einbauen, der beim Aufruf der Übersichtsseite ausgeführt wird. Hierfür müssen wir
        die Datei <span class="fn">src/song-overview/song-overview.js</span> zunächst um
        folgenden Import erweitern:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
        import Database from "../database.js";
        </code>
    </pre>
    <p>
        Den Testcode können wir dann einfach in den Konstruktor einbauen. Dabei wollen wir
        nicht alle Methoden konsequent durchtesten. Wir wollen nur ein paar Testdaten anlegen
        und in der Konsole beobachten, was dabei passiert. Ändere die Konstruktor daher wie
        folgt ab. Später werden wir den Testcode wieder entfernen.
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            constructor(app) {
                this._app = app;

                // Test der Datenbankklasse für Songtexte
                let test = async () =&gt; {
                    let songtexts = new Database.Songtexts();
                    await songtexts.clear();

                    let songs = await songtexts.search();
                    console.log("Alle Songs:", songs);

                    if (songs.length === 0) {
                        console.log("Bisher noch keine Songs vorhanden, lege deshalb Testdaten an");

                        await Promise.all([
                            songtexts.saveNew({
                                artist: "Queen",
                                title: "I Want To Break Free",
                                format: "html",
                                data: "HTML-Code für &lt;b&gt;I Want To Break Free&lt;/b&gt; von &lt;b&gt;Queen&lt;/b&gt;",
                            }),
                            songtexts.saveNew({
                                artist: "Queen",
                                title: "Radio Ga Ga",
                                format: "html",
                                data: "HTML-Code für &lt;b&gt;Radio Ga Ga&lt;/b&gt; von &lt;b&gt;Queen&lt;/b&gt;",
                            }),
                            songtexts.saveNew({
                                artist: "Michael Jackson",
                                title: "Billie Jean",
                                format: "html",
                                data: "HTML-Code für &lt;b&gt;Billie Jean&lt;/b&gt; von 6lt;b&gt;Michael Jackson&lt;/b&gt;",
                            }),
                        ]);

                        let songs = await songtexts.search();
                        console.log("Gespeicherte Songs:", songs);
                    }

                    songs = await songtexts.search("queen");
                    console.log('Suche nach dem Begriff "queen":', songs);
                }

                test();
                // Ende des Testcodes
            }
        </code>
    </pre>
    <p>
        Beim Start der Anwendung sollte dann folgendes Ergebnis in der Browserkonsole protokolliert werden:
    </p>
    <figure>
        <img src="02/db/testcode-konsole.png" class="border" />
        <figcaption>Protokollausgabe des Testcodes. Man sieht schön, wie die gespeicherten Objekte aufgebaut sind.</figcaption>
    </figure>
    <p>
        Wie du anhand des Quellcodes erkennen kannst, kannst du mit <span class="cmd">await</span>
        das Ergebnis einer asynchronen Methode abwarten. Das wird an dieser Stelle benötigt, da
        die Aufrufe von Dexie den Aufrufer nicht blockieren sondern nur dazu führen, dass die
        gewünschte Datenbankänderung im Hintergrund ausgeführt wird. Das funktioniert allerdings
        nur, wenn die rufende Methode mit <span class="cmd">async</span> gekennzeichnet wurde,
        da JavaScript den Programmfluss sonst nicht unterbrechen kann, um ohne den Browser zu
        blockieren auf die Antwort zu warten. Dabei führt jedes <span class="cmd">await</span>
        zu einer Unterbrechung, bis das gewünschte Ergebnis zur Verfügung steht. Soll allerdings
        nicht auf jedes Ergebnis nacheinander sondern gleichzeitig gewartet werden (das Programm
        soll dann erst weiterlaufen, wenn alle Ergebnisse vorliegen, unabhängig von der Reihenfolge),
        kann das mit <span class="cmd">await Promise.all([ ... ])</span> erreicht werden.
    </p>
</section>

<!-- –––––––––––––––––––––––––––––––––– -->
<!-- async/await während der Navigation -->
<!-- –––––––––––––––––––––––––––––––––– -->
<section data-title="async/await während der Navigation">
    <p class="git-commit">
        Git Commit:
        <a href="https://github.com/DennisSchulmeister/dhbwka-wwi-webprog-my-songbook/tree/58d30597f334b2963a227f4f0b5597e09c30b4cc" target="_blank">58d3059</a>
    </p>

    <h3>Nebenläufigkeit in JavaScript: Teil 1</h3>
    <p>
        An dieser Stelle ist noch etwas mehr Hintergrundwissen erforderlich, was es mit den
        asynchronen Methoden von Dexie und unserer Datenbankklasse auf sich hat. Dazu musst
        du wissen, dass es in JavaScript keine Threads wie in anderen Programmiersprachen
        gibt, mit denen nebenläufige Programmflüsse realisiert werden können. Stattdessen gibt
        es (stark vereinfacht gesagt) nur einen Hauptthread, in dem zu verschiedenen Zeitpunkten
        wirklich alles passiert, was der Browser macht:¹
    </p>
    <ul>
        <li>
            Das Einlesen und Auswerten des HTML-Codes
        </li>
        <li>
            Das Nachladen von Stylesheets, Bildern und JavaScript-Dateien
        </li>
        <li>
            Die Ausführung des JavaScript-Codes
        </li>
        <li>
            Die Darstellung der Webseite auf dem Bildschirm
        </li>
    </ul>
    <p>
        ¹
        <small>
            Theoretisch kann es zwar vorkommen, dass ein bestimmter Browser die genannten Aktionen
            in mehreren Threads nebenläufig ausführt. Dies ist dann aber ein Implementierungsdetail
            des jeweiligen Browsers und kann mit JavaScript nicht beeinflusst werden. Die Sprache
            JavaScript kennt das Konzept von Threads nicht.
        </small>
    </p>
    <p>
        Als Folge daraus kann lang laufender JavaScript-Code die gesamte Browser-Performance
        verschlechtern oder den Browser gar komplett einfrieren. Da JavaScript anfangs aber nur
        für kleine Codeschnippsel in ansonsten völlig statischen HTML-Dateien gedacht war, wurde
        bei der Definition der Sprache zunächst kein Wert auf Performance oder Nebenläufigkeit
        gelegt. Erst in jüngerer Zeit hat sich dies verändert, sodass JavaScript inzwischen
        zwar immer noch keine Threads, dafür aber folgende Konzepte der nebenläufigen Programmierung
        kennt:
    </p>
    <ul>
        <li>
            <a href="https://de.wikipedia.org/wiki/Web_Worker" target="_blank">Web Worker:</a>
            Funktionieren ähnlich wie Threads, indem sie es erlauben, eine Quelldatei mit Javascript-Code
            nachzuladen, der im Hintergrund unabhängig vom Hauptthread ausgeführt wird.
        </li>
        <li>
            <a href="https://de.wikipedia.org/wiki/Future_(Programmierung)" target="_blank">Promises:</a>
            Erlauben es, eine einzelne Funktion im Hintergrund auszuführen, ohne dass hierfür eine eigene Codedatei
            vom Server abgerufen werden muss. Ähnlich zu einem Event Handler kann eine Callback-Funktion registriert
            werden, die nach Abschluss der Hintergrundaktion im Hauptthread ausgeführt wird.
        </li>
        <li>
            <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" target="_blank">Asynchrone Funktionen:</a>
            Stellen eine syntaktische Vereinfachung dar, um einen Quellcode, in dem viel mit Promises gearbeitet wird,
            einfacher zu strukturieren. Eine asynchrone Funktion wird immer im Hintergrund ausgeführt, ohne dass hierfür
            explizit ein Promise-Objekt erzeugt werden muss.
        </li>
    </ul>
    <p>
        Web Worker werden für die Arbeit mit Dexie nicht benötigt. Promises und asynchrone Methoden jedoch schon,
        weshalb wir sie uns hier ein wenig genauer anschauen wollen. Zunächst einmal wollen wir dabei zeigen,
        wie (ohne Verwendung asyonchroner Funktionen) ein Promise-Objekt erzeugt werden kann, um eine Aktion
        im Hintergrund auszuführen:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            let promise = new Promise((resolve, reject) =&gt; {
                // Hier musst du dir eine lange Berechnung denken, die möglicherweise
                // den Browser einfrieren könnte. Sie liefert als Ergebnis die Zahl 42.
                // Manchmal läuft sie aber auch auf einen Fehler. Zur Sicherheit läuft
                // sie im Hintergrund.
                if (new Date().getSeconds() % 2) {
                    resolve(42);
                } else {
                    reject("Fehler: Aufruf in ungeraden Sekunden nicht erlaubt!");
                }
            });
        </code>
    </pre>
    <p>
        Wie du siehst, muss einfach nur ein <span class="cmd">Promise</span>-Objekt erzeugt und
        diesem die im Hintergrund auszuführende Funktion übergeben werden. Die Funktion kann dabei
        bis zu zwei Parameter besitzen, über die ein Ergebnis oder eine Fehlermeldung an den
        Hauptthread zurückgegeben werden kann. Hierfür kann der Hauptthread mehrere Callbacks
        registrieren, die nach Abschluss der Hintergrundaktion ausgeführt werden:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            promise.then(ergebnis =&gt; {
                // Diese Funktion wird im Hauptthread ausgeführt und bekommt
                // den Wert aus der obigen resolve()-Zeile übergeben.
                alert(`Das Ergebnis lautet ${ergebnis}.`);
            }).catch(fehler =&gt; {
                // Diese Funktion wird auch im Hauptthread ausgeführt. Sie
                // bekommt den Wert aus der obigen reject()-Zeile übergeben.
                alert(fehler);
            });
        </code>
    </pre>
    <p>
        Je nach aktueller Sekunde zeigt der obige Code die Zahl 42 oder einen Fehler.
    </p>
    <figure>
        <img src="02/async/promise-resolved.png" class="border" />
        <figcaption>Karlsruhe, 23:36:00: Die Frisur hält!</figcaption>
    </figure>
    <figure>
        <img src="02/async/promise-rejected.png" class="border" />
        <figcaption>Mannheim, eine Sekunde später: Der Code läuft auf einen Fehler.</figcaption>
    </figure>

    <h3>Nebenläufigkeit in JavaScript: Teil 2</h3>
    <p>
        Im Grunde genommen lassen sich auf die eben gezeigte Weise beliebige, langläufige
        Aktionen, wie das Speichern von Daten in einer Datenbank, in den Hintergrund verlagern,
        ohne dabei die Performance des Browsers herunterzuziehen. Auch lässt sich auf diese
        Weise ganz einfach der Zeitpunkt abfangen, an dem Dexie eine Änderung in der Datenbank
        auch wirklich ausgeführt hat, da Dexie (und auch unsere <span class="cmd">Database</span>-Klasse)
        immer ein <span class="cmd">Promise</span>-Objekt zurückliefern. Zum Beispiel so:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            let songtexts = new Database.Songtexts();
            let promise = songtexts.search();

            promise.then(songs =&gt; {
                // Die gesuchten Songs stehen nun zur Verfügung und können
                // via DOM-Manipulation angezeigt werden
                songs.forEach(song => {
                    <b>… Songs anzeigen …</b>
                });
            }).catch(error => {
                <b>… Fehlerbehandlung …</b>
            });

            // ACHTUNG! Während der Code ab dieser Zeile ausgeführt wird,
            // läuft der Datenbankzugriff durch Dexie noch. An dieser Stelle
            // können wir noch nicht auf das Ergebnis zugreifen. Nur die
            // obige Rückruffunktion des Promise-Objekts, die allerdings
            // erst irgendwann später aufgerufen wird, bekommt das gewünschte
            // Ergebnis übergeben
            <b>… Sonstiger Quellcode …</b>
        </code>
    </pre>
    <p>
        Gerade, wenn man viele Datenbankzugriffe hintereinander ausführen will, kann das
        schnell unübersichtlich werden. Mit Hilfe des Schlüsselworts <span class="cmd">await</span>
        lässt sich der Code jedoch ganz einfach schreiben:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            async function searchAndDisplaySongs() {
                try {
                    let songtexts = new Database.Songtexts();
                    let songs = await songtexts.search();

                    songs.forEach(song => {
                        <b>… Songs anzeigen …</b>
                    });
                } catch (error) {
                    <b>… Fehlerbehandlung …</b>
                }
            }

            searchAndDisplaySongs();
        </code>
    </pre>
    <p>
        Dieser Code bewirkt exakt das Gleiche, kommt aber völlig ohne Callbacks aus!
        Stattdessen wird der Code bei der <span class="cmd">await</span>-Anweisung
        einfach so lange unterbrochen, bis das von <span class="cmd">songtexts.search()</span>
        zurückgegebene <span class="cmd">Promise</span>-Objekt entweder ein Ergebnis
        oder einen Fehler liefert.
    </p>
    <p>
        Einen kleinen Nachteil hat das Schlüsselwort <span class="cmd">await</span> allerdings,
        weshalb es nicht in jeder Situation genutzt werden kann. Es darf nur innerhalb einer
        Funktion verwendet werden, die mit <span class="cmd">async</span> als asynchrone Funktion
        gekennzeichnet wurde, weshalb der Aufruf oben in die Funktion
        <span class="cmd">searchAndDisplaySongs()</span> verschoben wurde. Außerhalb einer solchen
        Funktion führt <span class="cmd">await</span> zu einem Syntaxfehler und damit zu einem
        kompletten Abbruch des JavaScript-Codes!
    </p>
    <p>
        Der Grund dafür liegt, wie so oft, in der Abwärtskompatibilität von JavaScript. Früher
        gab es das Schlüsselwort <span class="cmd">await</span> nicht, so dass es eine große
        Anzahl von produktivem JavaScript-Code gibt, der sich möglicherweise falsch verhält,
        wenn er für eine nicht genau vorhersagbare Zeit unterbrochen und erst später wieder
        fortgeführt wird. Also musste man sich eine neue Syntax einfallen lassen, die ganz klar
        kennzeichnet, wenn eine Funktion prinzipiell unterbrechbar ist. Ein viel wichtiger Grund
        ist jedoch, wie <span class="cmd">async</span> und <span class="cmd">await</span> technisch
        realisiert wurden:
    </p>
    <ul>
        <li>
            <span class="cmd">async:</span> Sorgt dafür, dass der gesamte Code der hiermit
            gekennzeichneten Funktion <b>immer</b> im Hintergrund ausgeführt wird und die Funktion
            deshalb ein <span class="cmd">Promise</span>-Objekt zurückliefert.
        </li>
        <li>
            <span class="cmd">await:</span> Unterbricht die aktuelle Hintergrundfunktion, um auf
            das Ende einer anderen Hintergrundfunktion zu warten.
        </li>
    </ul>
    <p>
        Unser Einführungsbeispiel von ganz oben lässt sich deshalb mit <span class="cmd">async</span>
        wie folgt vereinfachen, bewirkt aber exakt dasselbe wie in der alten Version:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            let beispiel = async () =&gt; {
                // Hier musst du dir eine lange Berechnung denken, die möglicherweise
                // den Browser einfrieren könnte. Sie liefert als Ergebnis die Zahl 42.
                // Manchmal läuft sie aber auch auf einen Fehler. Zur Sicherheit läuft
                // sie im Hintergrund.
                if (new Date().getSeconds() % 2) {
                    return 42;
                } else {
                    throw "Fehler: Aufruf in ungeraden Sekunden nicht erlaubt!";
                }
            };
         </code>
    </pre>
    <p>
        Diese Funktion liefert implizit immer ein <span class="cmd">Promise</span> als
        Ergebnis zurück, weshalb das zweite Beispiel im Grunde genommen unverändert
        weiter funktioniert:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            let promise = beispiel();

            promise.then(ergebnis =&gt; {
                // Diese Funktion wird im Hauptthread ausgeführt und bekommt
                // den Wert aus der obigen resolve()-Zeile übergeben.
                alert(`Das Ergebnis lautet ${ergebnis}.`);
            }).catch(fehler =&gt; {
                // Diese Funktion wird auch im Hauptthread ausgeführt. Sie
                // bekommt den Wert aus der obigen reject()-Zeile übergeben.
                alert(fehler);
            });
        </code>
    </pre>
    <p>
        Mit <span class="cmd">await</span> lässt sich aber auch dies vereinfachen, wie
        wir ja schon gesehen haben:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            let aufruf_von_beispiel = async () =&gt; {
                try {
                    let ergebnis = await beispiel();
                    alert(`Das Ergebnis lautet ${ergebnis}.`);
                } catch (fehler) {
                    alert(fehler);
                }
            };

            aufruf_von_beispiel();
        </code>
    </pre>
    <figure>
        <img src="02/async/await-resolved.png" class="border" />
        <figcaption>Auch hier bekommen wir mal ein Ergebnis …</figcaption>
    </figure>
    <figure>
        <img src="02/async/await-rejected.png" class="border" />
        <figcaption>… und mal die Fehlermeldung.</figcaption>
    </figure>

    <h3>Ausbauen des Testcodes</h3>
    <p>
        Mit soviel theoretischem Hintergrundwissen im Hinterkopf wird es nun Zeit, unseren
        Testcode aus der Klasse <span class="cmd">SongOverview</span> wieder auszubauen.
        Wenn er wenigstens einmal ausgeführt wurde, brauchen wir ihn ab jetzt nicht mehr.
        Öffne daher die Datei <span class="fn">src/song-overview/song-overview.js</span>
        und ersetze den Konstruktor wieder durch seine alte Version:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            constructor(app) {
                this._app = app;
            }
        </code>
    </pre>
    <p>
        Bevor du den Code entfernst, schaue ihn dir aber nochmal ganz genau an. Du solltest
        jetzt in der Lage sein zu verstehen, wofür die ganzen <span class="cmd">async</span>,
        <span class="cmd">await</span> und <span class="cmd">Promise.all()</span> benötigt werden.
    </p>

    <h3>Asynchrone Methodenaufrufe während der Navigation erlauben</h3>
    <p>
        Wenn wir nun gleich die Übersichtsseite ausprogrammieren wollen, um dort alle in der
        Datenbank gespeicherten Songs anzuzeigen, müssen wir in der Lage sein, innerhalb der
        <span class="cmd">onShow()</span>-Methode der Klasse <span class="cmd">SongOverview</span>
        unsere asynchronen Datenbankmethoden aufzurufen und dabei auf das Ergebnis der
        Datenbankanfrage zu warten, bevor wir es zur Anzeige bringen. Dank unserem neuen Wissen
        über Promises kein Problem, schöner wäre es jedoch, wenn wir auch hier das Schlüsselwort
        <span class="cmd">await</span> verwenden könnte, um den Quellcode zu vereinfachen.
    </p>
    <p>
        Zunächst müssen wir die Methoden <span class="cmd">onShow()</span> und <span class="cmd">onLeave()</span>
        daher zu asynchronen Methoden machen, indem wir ihnen das Schlüsselwort <span class="cmd">await</span>
        vorne anstellen. Rufe daher die beiden Dateien <span class="fn">src/song-overview/song-overview.js</span>
        und <span class="fn">src/song-display-edit/song-display-edit.js</span> auf und ändere die beiden Methoden
        entsprechend ab:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            // src/song-overview/song-overview.js
            class SongOverview {
                …
                <b>async</b> onShow() {
                    …
                }

                <b>async</b> onLeave() {
                    …
                }
                …
            }
        </code>
    </pre>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            // src/song-display-edit/song-display-edit.js
            class SongDisplayEdit {
                …
                <b>async</b> onShow() {
                    …
                }

                <b>async</b> onLeave() {
                    …
                }
                …
            }
        </code>
    </pre>
    <p>
        Dadurch wird dann eine Anpassung an der Klasse <span class="cmd">App</span>
        in der Datei <span class="fn">src/app.js</span> notwendig, in der wir die
        Methode <span class="cmd">_switchVisibleView()</span> austauschen müssen:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            <b>async</b> _switchVisibleView(view) {
                // Callback, mit dem die noch sichtbare View den Seitenwechsel zu einem
                // späteren Zeitpunkt fortführen kann, wenn sie in der Methode onLeave()
                // false zurückliefert. Dadurch erhält sie die Möglichkeit, den Anwender
                // zum Beispiel zu fragen, ob er ungesicherte Daten speichern will,
                // bevor er die Seite verlässt.
                let newUrl = this._router.lastRouteResolved().url;
                let goon = () =&gt; {
                    // ?goon an die URL hängen, weil der Router sonst nicht weiternavigiert
                    this._router.navigate(newUrl + "?goon");
                }

                // Aktuelle View fragen, ob eine neue View aufgerufen werden darf
                <b>if (this._currentView) {</b>
                    <b>let goonAllowed = await this._currentView.onLeave(goon);</b>

                    <b>if (!goonAllowed) {</b>
                        <b>this._navAborted = true;</b>
                        <b>return false;</b>
                    <b>}</b>
                <b>}</b>

                // Alles klar, aktuelle View nun wechseln
                document.title = `${this._title} – ${view.title}`;

                this._currentView = view;
                this._switchVisibleContent(<b>await</b> view.onShow());
                return true;
            }
        </code>
    </pre>
    <p>
        Dadurch sind dann alle Vorbereitungen abgeschlossen, damit wir die Übersichtsseite
        nun ausprogrammieren können. Auch wenn die Änderung selbst nur sehr klein war,
        verstehst du jetzt wenigstens, was sie bewirkt und warum wir sie benötigen.
    </p>
</section>

<!-- –––––––––––––––––––––––––––– -->
<!-- Die Übersichtsseite entsteht -->
<!-- –––––––––––––––––––––––––––– -->
<section data-title="Die Übersichtsseite entsteht">
    <p class="git-commit">
        Git Commit:
        <a href="https://github.com/DennisSchulmeister/dhbwka-wwi-webprog-my-songbook/tree/141d8b1ae7507464fce7fdc2622cd38e70a601a0" target="_blank">141d8b1</a>
    </p>

    <h3>Gestaltung der Übersichtsseite</h3>
    <p>
        An dieser Stelle wird es nun Zeit, den Dummy-Inhalt der App wieder zu entfernen und
        durch richtigen Inhalt zu ersetzen. Öffne daher die Datei <span class="fn">src/app.css</span>
        und entferne folgenden Bereich:
    </p>
    <pre data-gobble>
        <code class="css" data-gobble>
            /*
             * Hauptinhalt
             */
            #app main {
                /*
                 * Temporärer Inhalt, solange es noch keinen richtigen Inhalt gibt
                 * Bild: https://pixabay.com/de/handwerker-baustelle-arbeiter-3094035/
                 */
                background-image: url(construction.jpg);
                background-size: 100% auto;
                background-position: bottom center;
                background-repeat: no-repeat;

                color: rgb(255, 246, 23);
                text-shadow: 1px 1px 2px black;
                font-size: 300%;
                font-weight: bold;
                text-align: center;
            }
        </code>
    </pre>
    <p>
        Stattdessen bauen wir in die <span class="fn">src/index.html</span> folgenden
        neuen Inhalt an, damit wir uns an das Stylehsset für die Übersichtsseite machen
        können. Auch dieser Inhalt verschwindet gleich wieder, zunächst benötigen wir
        ihn aber, um die Stylesheets schreiben zu können.
    </p>
    <pre data-gobble>
        <code class="html" data-gobble>
            &lt;!-- ====================== --&gt;
            &lt;!-- View: Vorhandene Songs --&gt;
            &lt;!-- ====================== --&gt;
            &lt;section id="song-overview" class="hidden"&gt;
                &lt;!-- Topbar --&gt;
                &lt;header&gt;
                    <b>Diesen Inhalt nicht ändern!</b>
                &lt;/header&gt;

                &lt;!-- Hauptbereich --&gt;
                &lt;main&gt;
                    &lt;ul&gt;
                        &lt;li&gt;
                            &lt;div class="padding no-data"&gt;
                                Noch keine Texte vorhanden
                            &lt;/div&gt;
                        &lt;/li&gt;

                        &lt;li data-section-title="A"&gt;
                            &lt;div class="section-title"&gt;
                                A
                            &lt;/div&gt;
                        &lt;/li&gt;
                        &lt;li class="entry" data-song-title="Another Day In Paradise" data-song-artist="Phil Collins"&gt;
                            &lt;div class="song-title"&gt;
                                Another Day In Paradise
                            &lt;/div&gt;
                            &lt;div class="song-artist"&gt;
                                Phil Collins
                            &lt;/div&gt;
                        &lt;/li&gt;
                        &lt;li class="entry" data-song-title="Another One Bites The Dust" data-song-artist="Queen"&gt;
                            &lt;div class="song-title"&gt;
                                Another One Bites The Dust
                            &lt;/div&gt;
                            &lt;div class="song-artist"&gt;
                                Queen
                            &lt;/div&gt;
                        &lt;/li&gt;

                        &lt;li data-section-title="B"&gt;
                            &lt;div class="section-title"&gt;
                                B
                            &lt;/div&gt;
                        &lt;/li&gt;
                        &lt;li class="entry" data-song-title="Bennie And The Jets" data-song-artist="Elton John"&gt;
                            &lt;div class="song-title"&gt;
                                Bennie And The Jets
                            &lt;/div&gt;
                            &lt;div class="song-artist"&gt;
                                Elton John
                            &lt;/div&gt;
                        &lt;/li&gt;
                    &lt;/ul&gt;
                &lt;/main&gt;
            &lt;/section&gt;
        </code>
    </pre>
    <p>
        Anstelle des alten Inhalts zeigen wir nun eine Liste der vorhandenen Songtexte an.
        Wie du siehst, spielt sich alles in einem <span class="cmd">&lt;ul&gt;</span>-Element
        ab, wobei es verschiedene Listeneinträge gibt. Der Eintrag, wenn noch keine Songtexte
        vorhanden sind, sieht so aus:
    </p>
    <pre data-gobble>
        <code class="html" data-gobble>
            &lt;li&gt;
                &lt;div class="padding no-data"&gt;
                    Noch keine Texte vorhanden
                &lt;/div&gt;
            &lt;/li&gt;
        </code>
    </pre>
    <p>
        Zwischenüberschriften sehen so aus:
    </p>
    <pre data-gobble>
        <code class="html" data-gobble>
            &lt;li data-section-title="A"&gt;
                &lt;div class="section-title"&gt;
                    A
                &lt;/div&gt;
            &lt;/li&gt;
        </code>
    </pre>
    <p>
        Und die eigentlichen Songtexte sehen so aus:
    </p>
    <pre data-gobble>
        <code class="html" data-gobble>
            &lt;li class="entry" data-song-title="Another Day In Paradise" data-song-artist="Phil Collins"&gt;
                &lt;div class="song-title"&gt;
                    Another Day In Paradise
                &lt;/div&gt;
                &lt;div class="song-artist"&gt;
                    Phil Collins
                &lt;/div&gt;
            &lt;/li&gt;
        </code>
    </pre>
    <p>
        Auf diese Struktur können wir nun zugreifen, um das Stylesheet zu schreiben. Doch zuvor
        benötigen wir noch ein paar weitere Variablen in der Datei <span class="fn">src/theme.css</span>.
    </p>
    <pre data-gobble>
        <code class="css" data-gobble>
            html {
                <b>Bisherige Variablen bitte beibehalten …</b>

                --overview-heading-background-color: rgb(230,230,230);
                --overview-heading-font-color:       rgb(78,81,116);
                --overview-list-hover-color:         rgba(0,0,0, 0.05);
            }
        </code>
    </pre>
    <p>
        Damit können wir nun die Datei <span class="fn">src/song-overview/song-overview.css</span>
        durch folgende Version ersetzen.
    </p>
    <pre data-gobble>
        <code class="css" data-gobble>
            .song-overview ul {
                list-style: none;
                margin: 0;
                padding: 0;
                font-size: 130%;
            }

            .song-overview .no-data {
                color: var(--header-normal-background-color);
                text-shadow: 1px 1px 1px rgba(0,0,0, 0.25);
            }

            .song-overview li {
                border: 0px solid var(--overview-heading-background-color);
                border-bottom-width: 1px;
            }

            .song-overview .entry:hover {
                background-color: var(--overview-list-hover-color);
                cursor: pointer;
            }

            .song-overview li &gt; div {
                padding: 0 0.5rem 0 0.5rem;
            }

            .song-overview .section-title {
                background: var(--overview-heading-background-color);
                color: var(--overview-heading-font-color);
                font-weight: bold;
            }

            .song-overview .song-artist {
                font-size: 75%;
            }
        </code>
    </pre>
    <p>
        Das Ergebnis sollte dann so aussehen:
    </p>
    <figure>
        <img src="02/song-overview/statischer-inhalt.png" class="border" />
        <figcaption>Das fertige Layout der Übersichtsseite (hier noch mit statischem Inhalt)</figcaption>
    </figure>

    <h3>Einträge aus der Datenbank lesen und anzeigen</h3>
    <p>
        Das sieht ja schon ganz gut aus. Jetzt soll der Inhalt aber auch aus der Datenbank kommen.
        Der eben noch in die <span class="fn">src/index.html</span> eingefügte HTML-Code reduziert
        sich deshalb nun zu folgenden paar Zeilen. Es kommt alles weg bis auf die Liste selbst
        dargestellt durch das <span class="cmd">&lt;ul&gt;</span>-Element.
    </p>
    <pre data-gobble>
        <code class="html" data-gobble>
            &lt;!-- ====================== --&gt;
            &lt;!-- View: Vorhandene Songs --&gt;
            &lt;!-- ====================== --&gt;
            &lt;section id="song-overview" class="hidden"&gt;
                &lt;!-- Topbar --&gt;
                &lt;header&gt;
                    <b>Diesen Inhalt nicht ändern!</b>
                &lt;/header&gt;

                &lt;!-- Hauptbereich --&gt;
                &lt;main&gt;
                    &lt;ul&gt;&lt;/ul&gt;
                &lt;/main&gt;
            &lt;/section&gt;
        </code>
    </pre>
    <p>
        Weiter geht es in der Datei <span class="fn">src/song-overview/song-overview.js</span>,
        in der wir zwei neue Methoden zum Lesen der Songs aus der Datenbank und zur Anzeige
        der gefundenen Einträge benötigen. Die Methode zum Lesen der Songs sieht wie folgt aus.
        Sie ist im Grunde genommen ganz einfach, durch den umfangreichen Kommentar am Anfang
        und die Vergleichsfunktion zum Sortieren der Songs wirkt sie allerdings größer, als sie
        in Wirklichkeit ist.
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            /**
             * Diese Methode greift auf die Datenbank zu und sucht die gespeicherten
             * Songs. Optional kann ein Suchbegriff mitgegeben werden, der innerhalb
             * des Songtitels oder des Künstlernamens vorkommen muss. Ebenso kann
             * einer von folgenden Werten mitgegeben werden, um die Ergebnisliste zu
             * sortieren:
             *
             *   * "title": Sortierung nach Songtitel und Künstler
             *   * "artist": Sortierung nach Künstler und Songtitel
             *
             * Die Ergebnisliste hat folgendes Format:
             *
             * [
             *      {
             *          id: "Datenbank-ID",                 // Schlüsselwert der Datenbank
             *          artist: "Name des Künstlers",       // Name des Künstlers
             *          title: "Name des Songs",            // Name des Songs
             *          format: "html",                     // Bisher immer "html"
             *          data: "HTML-String",                // HTML-String mit Songinhalt
             *      }, {
             *        …
             *      }
             * ]
             *
             * @param  {String} query Suchbegriff (optional)
             * @param  {String} sort Sortierung (optional)
             * @return {Array} Liste der gefundenen Songs
             */
            async _searchSongs(query, sort) {
                // Songs suchen
                let songtexts = new Database.Songtexts();
                let songs = await songtexts.search(query);

                // Ergebnis sortieren
                songs.sort((lhs, rhs) =&gt; {
                    let resultArtist = lhs.artist.localeCompare(rhs.artist);
                    let resultTitle = lhs.title.localeCompare(rhs.title);

                    if (sort === "artist") {
                        // Sortierung nach Künstler und Songtitel
                        if (resultArtist != 0) {
                            return resultArtist;
                        } else {
                            return resultTitle;
                        }
                    } else {
                        // Sortierung nach Songtitel und Künstler
                        if (resultTitle != 0) {
                            return resultTitle;
                        } else {
                            return resultArtist;
                        }
                    }
                });

                return songs;
            }
        </code>
    </pre>
    <p>
        Die Methode zur Ausgabe der gefundenen Songs in der HTML-Oberfläche ist allerdings
        tatsächlich etwas länglich, weil wir hier relativ viele DOM-Objekte erzeugen und
        aufrufen müssen, um den dynamischen HTML-Code zu generieren. In den späteren Teilen
        der Anleitung werden wir diesen Code deshalb nochmal überarbeiten.
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            /**
             * Diese Methode nimmt die von searchSongs() generierte Liste mit Songtexten
             * entgegen und zeigt sie auf der Seite an. Hierfür muss der Methode über
             * den Parameter groupBy einer von folgenden beiden Strings mitgegeben
             * werden:
             *
             *   * "title": Gruppierung anhand erstem Buchstaben des Titels
             *   * "artist": Gruppierung anhand des Künstlers
             *
             * Im Parameter parentNode muss das &lt;ul&gt;-Element übergeben werden, in
             * welches die Listeneinträge eingefügt werden sollen.
             *
             * @param {Array} songs Liste der darzustellenden Songs
             * @param {String} groupBy Kriterium für die Zwischenüberschriften
             * @param {HTMLNode} parentNode &lt;ul&gt;-Element der Liste
             */
            _renderList(songs, groupBy, parentNode) {
                parentNode.innerHTML = "";

                if (songs.length &lt; 1) {
                    // Hinweistext, wenn noch keine Songs vorhanden sind
                    parentNode.innerHTML += `
                        &lt;li&gt;
                            &lt;div class="padding no-data"&gt;
                                Noch keine Texte vorhanden
                            &lt;/div&gt;
                        &lt;/li&gt;
                    `;
                } else {
                    // Zwischenüberschriften und Songtexte
                    let currentGroup = "";

                    songs.forEach(song =&gt; {
                        // Zwischenüberschrift zur Gruppierung der Songs
                        //
                        // &lt;li data-section-title="A"&gt;
                        //     &lt;div class="section-title"&gt;
                        //         A
                        //     &lt;/div&gt;
                        // &lt;/li&gt;
                        let songGroup1 = "";
                        let songGroup2 = "";

                        if (groupBy === "title") {
                            songGroup1 = song.title.trim()[0].toUpperCase();
                            songGroup2 = songGroup1;
                        } else {
                            songGroup1 = song.artist.trim();
                            songGroup2 = songGroup1.toUpperCase();
                        }

                        if (currentGroup != songGroup2) {
                            currentGroup = songGroup2;

                            let liGroup = document.createElement("li");
                            liGroup.dataset.sectionTitle = songGroup1;

                            let divGroup = document.createElement("div");
                            divGroup.classList.add("section-title");
                            divGroup.textContent = songGroup1;

                            parentNode.appendChild(liGroup);
                            liGroup.appendChild(divGroup);
                        }

                        // Der eigentliche Song
                        //
                        // &lt;li class="entry" data-song-title="Another Day In Paradise" data-song-artist="Phil Collins"&gt;
                        //     &lt;div class="song-title"&gt;
                        //         Another Day In Paradise
                        //     &lt;/div&gt;
                        //     &lt;div class="song-artist"&gt;
                        //         Phil Collins
                        //     &lt;/div&gt;
                        // &lt;/li&gt;
                        let liSong = document.createElement("li");
                        liSong.classList.add("entry");
                        liSong.dataset.songTitle = song.title.trim();
                        liSong.dataset.songArtist = song.artist.trim();

                        let divTitle = document.createElement("div");
                        divTitle.classList.add("song-title");
                        divTitle.textContent = song.title.trim();

                        let divArtist = document.createElement("div");
                        divArtist.classList.add("song-artist");
                        divArtist.textContent = song.artist.trim();

                        parentNode.appendChild(liSong);
                        liSong.appendChild(divTitle);
                        liSong.appendChild(divArtist);
                    });
                }
            }
        </code>
    </pre>
    <p>
        Jetzt müssen wir die beiden Methoden nur noch an der richtigen Stelle aufrufen,
        um etwas auf dem Bildschirm zu sehen. Die Methode <span class="cmd">onShow()</span>
        ist genau der richtige Ort dafür, da wir die Songliste beim Aufruf der Seite lesen
        und auf den Bildschirm bringen wollen. Ändere die <span class="cmd">onShow()</span>-Methode
        daher wie folgt ab:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            async onShow() {
                let section = document.querySelector("#song-overview").cloneNode(true);

                <b>let order = "title";</b>
                <b>let query = "";</b>

                <b>let songs = await this._searchSongs(query, order);</b>
                <b>this._renderList(songs, order, section.querySelector("main &gt; ul"));</b>

                return {
                    className: "song-overview",
                    topbar: section.querySelectorAll("header &gt; *"),
                    main: section.querySelectorAll("main &gt; *"),
                };
            }
        </code>
    </pre>
    <p>
        Und schon sollte sich dir folgendes Bild bieten. Vorausgesetzt natürlich, dass
        die Testeinträge noch in deiner lokalen Datenbank enthalten sind. Sollten keine
        Einträge zu sehen sein, baue nochmal den Testcode zu ihrer Erzeugung ein und
        stelle sicher, dass in der Browserkonsole keine Fehlermeldungen entstehen.
    </p>
    <figure>
        <img src="02/song-overview/dynamischer-inhalt.png" class="border" />
        <figcaption>Sieht fast gleich aus, die Einträge kommen jetzt aber aus der Datenbank.</figcaption>
    </figure>
</section>

<!-- ––––––––––––––––––––––––––––––––––– -->
<!-- Schlankheitskur für den Kopfbereich -->
<!-- ––––––––––––––––––––––––––––––––––– -->
<section data-title="Schlankheitskur für den Kopfbereich">
    <p class="git-commit">
        Git Commit:
        <a href="https://github.com/DennisSchulmeister/dhbwka-wwi-webprog-my-songbook/tree/c1ff138153d04bd9d91d405f5aa489f17343a343" target="_blank">c1ff138</a>
    </p>

    <p>
        Nachdem die Darstellung der Songliste nun funktioniert, wird es Zeit, die
        Sortier- und Suchfunktion auszuprogrammieren. Zuvor wollen wir uns aber noch
        einem kleinen Usability-Problem annehmen. Und zwar dem Kopfbereich, der in der
        mobilen Ansicht zwar gut zu bedienen ist, dafür aber viel zu viel Platz einnimmt.
        Im folgenden Screenshot sieht man, dass auf einem Smartphone fast die halbe
        Bildschirmhöhe verloren geht:
    </p>
    <figure style="max-width: 25em;">
        <img src="02/kopfzeile/mobile-vorher.png" class="border" />
        <figcaption>Der Kopfbereich belegt fast den halben Bildschirm</figcaption>
    </figure>
    <p>
        Die Lösung des Problems ist im Grunde genommen ganz einfach, erfordert an dieser
        Stelle aber ein wenig Programmierarbeit: Wir benötigen ein
        <a href="https://de.wikipedia.org/wiki/Hamburger-Men%C3%BC-Icon" target="_blank">Hamburger-Menü</a>.
        So soll die fertige Lösung daher aussehen:
    </p>
    <figure style="max-width: 25em;">
        <img src="02/kopfzeile/menue-zugeklappt.png" class="border" />
        <figcaption>Anfangs ist das Menü zugeklappt.</figcaption>
    </figure>
    <figure style="max-width: 25em;">
        <img src="02/kopfzeile/menue-aufgeklappt.png" class="border" />
        <figcaption>Bei Klick auf das Symbol erscheint die volle Auswahl.</figcaption>
    </figure>
    <p>
        Zunächst müssen wir das Hamburger-Icon im HTML-Code definieren, was mit folgender
        kleinen Anpassung in  <span class="fn">src/index.html</span> gelingt. Gleichzeitig
        fügen wir dem umgebenden <span class="cmd">&lt;div&gt;</span> noch zwei CSS-Klassen
        hinzu, auf die wir mit JavaScript gleich zugreifen werden.
    </p>
    <pre data-gobble>
        <code class="html" data-gobble>
            &lt;section id="app"&gt;
                …
                    &lt;div class="item <b>hamburger-menu menu-closed</b>"&gt;
                        &lt;b&gt;
                            <b>&lt;span class="menu-icon"&gt;≡&lt;/span&gt;</b>
                            Beispiel einer Browser App: My Songbook
                        &lt;/b&gt;
                    &lt;/div&gt;
                …
            &lt;/section&gt;
        </code>
    </pre>
    <p>
        Zusätzlich kennzeichnen wir die auf dem Smartphone zunächst auszublendenden Menüpunkte
        mit der CSS-Klasse <span class="cmd">menu-content</span>:
    </p>
    <pre data-gobble>
        <code class="html" data-gobble>
            &lt;section id="app"&gt;
                …
                &lt;div class="top right <b>menu-content</b>"&gt;
                    …
                &lt;/div&gt;
                …
            &lt;/section&gt;

            &lt;section id="song-overview" class="hidden"&gt;
                …
                &lt;div class="left <b>menu-content</b>"&gt;
                    …
                &lt;/div&gt;
                …
            &lt;/section&gt;

            &lt;section id="song-display-edit" class="hidden"&gt;
                …
                &lt;div class="left <b>menu-content</b>"&gt;
                    …
                &lt;/div&gt;
                …
            &lt;/section&gt;
        </code>
    </pre>
    <p>
        Damit ist der HTML-Code schon auf das neue Menü vorbereitet. Allerdings
        brauchen wir das Hamburger-Icon nur in der Smartphone-Ansicht, da auf
        großen Bildschirmen alles beim Alten bleiben soll. Folgende Zeilen in
        <span class="fn">src/app.css</span> reichen dafür schon aus:
    </p>
    <pre data-gobble>
        <code class="css" data-gobble>
            /*
             * Anpassung an große Bildschirme, sobald in der index.css das große
             * Hintergrundbild eingeschaltet wird
             */
            @media screen and (min-width: 85em) {
                …
                /* Menü-Icon ausblenden */
                #app header .menu-icon {
                    display: none;
                }
                …
            }
        </code>
    </pre>
    <p>
        Die einzelnen Menüpunkte werden wir zur Laufzeit durch Hinzufügen der CSS-Klasse
        <span class="cmd">hidden</span> ausblenden. Diese ist bereits im Stylesheet
        <span class="fn">src/index.css</span> definiert, muss aber noch um den Zusatz
        <span class="cmd">!important</span> ergänzt werden:
    </p>
    <pre data-gobble>
        <code class="css" data-gobble>
            .hidden {
                display: none !important;
            }
        </code>
    </pre>
    <p>
        Fehlt nur noch das dazugehörige JavaScript. Dieses fügen wir am Ende des
        Konstruktors der Klasse <span class="cmd">App</span>, also in der Datei
        <span class="fn">src/app.js</span> ein. Los geht's mit einem Event Handler,
        der das Menü bei Klick auf die Titelzeile auf- und zuklappt:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            class App {
                /**
                 * Konstruktor.
                 */
                constructor() {
                    …
                    // Hamburger-Menü für kleine Bildschirme ermöglichen
                    let menuButton = document.querySelector("header .hamburger-menu");

                    menuButton.addEventListener("click", () =&gt; {
                        // Nur auf kleinen Bildschirmen auf den Klick reagieren
                        if (menuButton.classList.contains("inactive")) return;

                        // Sichtbarkeit des Menüs umschalten
                        let menuState = "menu-open";
                        if (menuButton.classList.contains("menu-open")) menuState = "menu-closed";

                        menuButton.classList.remove("menu-open");
                        menuButton.classList.remove("menu-closed");
                        menuButton.classList.add(menuState);

                        // Menüeinträge ein-/ausblenden
                        document.querySelectorAll("header .menu-content").forEach(element =&gt; {
                            if (menuState === "menu-open") {
                                element.classList.remove("hidden");
                            } else {
                                element.classList.add("hidden");
                            }
                        });
                    });
                }
                …
            }
        </code>
    </pre>
    <p>
        In der ersten Zeile holen wir uns das <span class="cmd">&lt;div&gt;</span> mit dem Titel
        in des Hamburger-Icons. Für dieses wird dann ein Event Listener registriert, der bei jedem
        Mausklick (bzw. Touchdruck) auf das Event feuert. Innerhalb der Funktion passiert dann
        folgendes:
    </p>
    <ol>
        <li>
            Zunächst wird geprüft, ob die Titelzeile die CSS-Klasse <span class="cmd">inactive</span>
            besitzt. Sie ist bisher noch nicht gesetzt, wird später aber immer dann zugewiesen,
            wenn die Anwendung in der vollen Ansicht für große Bildschirme dargestellt wird. Ist dies
            der Fall, kann die Funktion direkt wieder verlassen werden.
        </li>
        <li>
            Anschließend wird geprüft, ob das <span class="cmd">&lt;div&gt;</span> die CSS-Klassen
            <span class="cmd">menu-open</span> oder <span class="cmd">menu-closed</span> besitzt,
            je nachdem, ob das Menü aktuell auf- oder zugeklappt ist. Der dabei gefundene Wert wird
            dann durch den jeweils anderen Wert ersetzt.
        </li>
        <li>
            Zum Schluss werden die einzelnen Menüpunkte in Abhängigkeit des eben ermittelten Wertes
            ein- oder ausgeblendet. Dies erfolgt durch Zuweisung der CSS-Klasse <span class="cmd">hidden</span>,
            die in der Datei <span class="fn">src/index.jss</span> definiert ist.
        </li>
    </ol>
    <p>
        Jetzt muss nur noch der Hovereffekt für die Titelzeile auf großen Bildschirmen
        unterbinden und sichergestellt werden, dass das Menü in der Smartphone-Ansicht
        zunächst immer ausgeblendet ist. Außerdem wollen wir das Menü automatisch
        automatisch aktivieren, wenn sich die Größe des Browserfensters ändert und die
        gesamte Ansicht auf den Smartphone-Modus wechselt. Direkt nach dem oben gezeigten
        JavaScript-Code (immer noch im Konstruktor der Klasse <span class="cmd">App</span>)
        muss daher folgender Code eingefügt werden. Der Quellcode sollte an dieser Stelle
        ziemlich selbsterklärend sein:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            class App {
                /**
                 * Konstruktor.
                 */
                constructor() {
                    <b>… Code von eben …</b>

                    let _initHamburgerMenu = () =&gt; {
                        // Menübutton auf großen Bildschirmen inaktiv schalten
                        // Klasse .inactive für das Element mit .hamburger-menu setzen
                        let menuIcon = document.querySelector("header .menu-icon");
                        let largeScreen = true;

                        if (getComputedStyle(menuIcon).display === "none") {
                            menuButton.classList.add("inactive");
                        } else {
                            menuButton.classList.remove("inactive");
                            largeScreen = false;
                        }

                        //  Menüeinträge auf kleinen Bildschirmen anfangs ausblenden
                        // und auf großen Bildschirmen immer anzeigen
                        document.querySelectorAll("header .menu-content").forEach(element =&gt; {
                            if (largeScreen) {
                                element.classList.remove("hidden");
                            } else {
                                element.classList.add("hidden");
                            }
                        });
                    };

                    window.addEventListener("resize", () =&gt; {
                        _initHamburgerMenu();
                    });

                    _initHamburgerMenu();
                }
                …
            }
        </code>
    </pre>
</section>

<!-- –––––––––––––––––––– -->
<!-- Sortierung und Suche -->
<!-- –––––––––––––––––––– -->
<section data-title="Sortierung und Suche">
    <p class="git-commit">
        Git Commit:
        <a href="https://github.com/DennisSchulmeister/dhbwka-wwi-webprog-my-songbook/tree/c8ce106d0d513ab6121867b2d0b5d7ed0f998ba9" target="_blank">c8ce106</a>
    </p>

    <p>
        Aktuell wird die Songliste auf der Übersichtsseite immer nach Titel sortiert
        angezeigt. Bei vielen Einträgen ist es aber manchmal besser, die Einträge
        nach Künstler zu sortieren, oder einen gewünschten Song einfach mal schnell
        suchen zu können. Beides wollen wir deshalb nun ausprogrammieren, wobei wir
        wie immer mit ein paar kleinen Anpassungen am HTML-Code in
        <span class="fn">src/index.html</span> beginnen.
    </p>
    <pre data-gobble>
        <code class="html" data-gobble>
            …
            &lt;section id="song-overview" class="hidden"&gt;
                &lt;!-- Topbar --&gt;
                &lt;header&gt;
                    &lt;div class="left menu-content"&gt;
                        &lt;div class="item"&gt;
                            &lt;a href="/song/new/" data-navigo&gt;
                                Song hinzufügen
                            &lt;/a&gt;
                        &lt;/div&gt;
                        <b>&lt;div class="item cmd-sort" data-sort-by="title"&gt;
                            &lt;a&gt;
                                Liste nach Titel sortieren
                            &lt;/a&gt;
                        &lt;/div&gt;
                        &lt;div class="item cmd-sort" data-sort-by="artist"&gt;
                            &lt;a&gt;
                                Liste nach Künstler sortieren
                            &lt;/a&gt;
                        &lt;/div&gt;</b>
                    &lt;/div&gt;
                    &lt;div class="right"&gt;
                        &lt;input <b>class="search"</b> placeholder="Suchen" /&gt;
                    &lt;/div&gt;
                &lt;/header&gt;
                …
            &lt;/section&gt;
            …
        </code>
    </pre>
    <p>
        Auf diese Weise haben wir nun zwei Menüpunkte zum Ändern der Sortierung.
        Mit JavaScript werden wir dann sicherstellen, dass immer nur einer davon
        angezeigt wird, je nachdem wonach die Liste zuletzt sortiert wurde.
        Außerdem hat das Suchfeld nun noch eine CSS-Klasse bekommen, durch dies
        einfacher in JavaScript angesprochen werden kann. Wollen wir die entsprechenden
        deshalb gleich mal Anpassungen anschauen. Es beginnt mit ein paar Hilfsvariablen
        im Konstruktor der Klasse <span class="cmd">SongOverview</span> in der
        Datei <span class="fn">src/song-overview/song-overview.js</span>:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            class SongOverview {
                …
                constructor(app) {
                    this._app = app;

                    // Suche und Sortierung
                    this._order = "";
                    this._sort = "";
                    this._searchTimeout = null;

                    this._sortButtons = null;
                    this._searchField = null;
                    this._listElement = null;
                }
                …
            }
        </code>
    </pre>
    <p>
        In der Methode <span class="cmd">onShow()</span> entfernen wir die vier Zeilen in der Mitte,
        die sich um den Aufruf der beiden anderen Methoden <span class="cmd">_searchSongs()</span>
        und <span class="cmd">_renderList</span> kümmern, so dass nur noch die erste Zeile und die
        <span class="cmd">return</span>-Anweisung am Ende übrig bleiben. Stattdessen fügen wir folgende
        Zeilen ein:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            async onShow() {
                let section = document.querySelector("#song-overview").cloneNode(true);
                <b>
                this._sortButtons = section.querySelectorAll("header .cmd-sort");
                this._searchField = section.querySelector("header .search");
                this._listElement = section.querySelector("main &gt; ul");

                this._searchAndUpdateView("", "title");
                </b>
                return {
                    className: "song-overview",
                    topbar: section.querySelectorAll("header &gt; *"),
                    main: section.querySelectorAll("main &gt; *"),
                };
            }
        </code>
    </pre>
    <p>
        Wir rufen also nun die neue Methode <span class="cmd">_searchAndUpdateView()</span>
        auf, die wie folgt am Ende der Klasse eingefügt werden kann:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            /**
             * Diese Methode umhüllt die beiden Methoden _searchSongs() und
             * _renderList(), um die Liste der darzustellenden Songs zu ermitteln
             * und anzuzeigen. Dabei werden auch die anderen Inhalte der Seite
             * wie die Toolbar oder das Suchfeld aktualisiert.
             *
             * @param  {String} query Suchbegriff
             * @param  {String} sort Sortierung und Gruppierung
             */
            async _searchAndUpdateView(query, sort) {
                // Songs suchen und anzeigen
                this._query = query;
                this._sort = sort;

                let songs = await this._searchSongs(query, sort);
                this._renderList(songs, sort, this._listElement);

                // Sortierbuttons in der Toolbar umschalten
                this._sortButtons.forEach(element =&gt; {
                    if (element.dataset.sortBy === sort) {
                        element.classList.add("hidden");
                    } else {
                        element.classList.remove("hidden");
                    }
                });

                // Text im Suchfeld aktualisieren
                if (!this._searchField.value === query) {
                    this._searchField.value = query;
                }
            }
        </code>
    </pre>
    <p>
        Funktional hat sich dadurch erst mal nichts verändert. Wir haben jedoch eine
        wunderbare All-In-One-Methode, die immer dafür sorgt, dass alle UI-Elemente
        korrekt dargestellt werden, wenn wir die Sortierung ändern oder eine Suche
        ausführen. Hier werden zum Beispiel die Buttons zum Sortieren der Liste ein-
        und ausgeblendet, je nachdem, welche Sortierung gerade aktiv ist. Aktuell ist
        das noch fest-verdrahtet die Sortierung nach Titel. Wir können nun aber ganz
        einfach einen Event Handler einbauen, um dies zu ändern. Hierzu gehen wir
        wieder in die Methode <span class="cmd">onShow()</span> zurück und fügen vor
        den <span class="cmd">return</span>-Anweisung folgende Zeilen hinzu:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            async onShow() {
                <b>… bisherigen Code bitte stehen lassen …</b>

                // Event Listener zum Sortieren der Liste
                this._sortButtons.forEach(element =&gt; {
                    element.addEventListener("click", event =&gt; {
                        this._searchAndUpdateView(this._query, element.dataset.sortBy);
                        event.preventDefault();
                    });
                });

                return …
            }
        </code>
    </pre>
    <p>
        Wir müssen innerhalb des Event Listeners tatsächlich nur die neue Methode
        <span class="cmd">_searchAndUpdateView()</span> aufrufen und ihr im zweiten
        Parameter den Namen der Sortierspalte mitgeben. Praktischerweise haben wir
        diesen in einem <span class="cmd">data</span>-Attribut bereits im HTML-Code
        hinterlegt, so dass hier nur der Attribut weitergereicht werden muss.
    </p>
    <figure>
        <img src="02/songliste/sortierung-titel.png" class="border" />
        <figcaption>Kennen wir schon: Die Sortierung nach Titel</figcaption>
    </figure>
    <figure>
        <img src="02/songliste/sortierung-artist.png" class="border" />
        <figcaption>Es geht aber auch anders: Hier sortiert nach Künstler</figcaption>
    </figure>

    <p>
        Die Suche funktioniert jetzt dann genau so einfach. Wir müssen einfach an
        derselben Stelle wie eben einen weiteren Event Handler einbauen. Diesen
        programmieren wir so, dass nach jedem Tastendruck spätestens nach einer
        halben Sekunde die Suche ausgeführt wird, stellen dabei aber sicher, dass
        die zeitversetzte Suche nur dann vorgemerkt wird, wenn es nicht bereits
        ohnehin eine Vormerkung gibt. Bei <span class="kbd">Enter</span> wollen
        wir die Suche außerdem direkt ausführen und eine eventuell bestehende
        Vormerkung verwerfen. Der JavaScript-Code hierfür sieht so aus:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            async onShow() {
                <b>… bisherigen Code bitte stehen lassen …</b>

                // Event Listener zum Suchen von Songs
                this._searchField.addEventListener("keyup", event =&gt; {
                    if (event.key === "Enter") {
                        // Bei Enter sofort suchen
                        this._searchAndUpdateView(this._searchField.value, this._sort);

                        if (this._searchTimeout) {
                            window.clearTimeout(this._searchTimeout);
                            this._searchTimeout = null;
                        }
                    } else {
                        // Bei sonstigem Tastendruck nur alle halbe Sekunde suchen
                        if (!this._searchTimeout) {
                            this._searchTimeout = window.setTimeout(() =&gt; {
                                this._searchAndUpdateView(this._searchField.value, this._sort);
                                this._searchTimeout = null;
                            }, 500);
                        }
                    }
                });

                return …
            }
        </code>
    </pre>
    <p>
        Ohne die automatische Suche nach einer halben Sekunde wäre der Quellcode
        natürlich etwas kürzer und übersichtlicher. Wirklich kompliziert ist die
        hier gezeigte Version dann aber doch wieder nicht. Gönnen wir dem Anwender
        oder der Anwenderin daher den Luxus, auch ohne <span class="kbd">Enter</span>
        zu drücken suchen zu können.
    </p>
    <figure>
        <img src="02/songliste/suche.png" class="border" />
        <figcaption>Eine Suche noch besser als die von Google 🤣</figcaption>
    </figure>
</section>

<!-- –––––––––––––––––––––––––––––––– -->
<!-- Songtexte anzeigen und bearbeiten-->
<!-- ––––––––––––––––––––––––––––––––– -->
<section data-title="Songtexte anzeigen und bearbeiten">
    <p class="git-commit">
        Git Commit:
        <a href="https://github.com/DennisSchulmeister/dhbwka-wwi-webprog-my-songbook/tree/XXX" target="_blank">XXX</a>
    </p>

    <!--
    Ausprogrammieren der Detailseite zu einem Songtext
    Bearbeitung über contenteditable ohne WYSIWIG-Formatierung
    Buttons zum Löschen und Bearbeiten bereits vorsehen
    Bei Klick auf "Löschen" direkt löschen und zurück zur Übersicht
    -->
</section>

<!-- ––––––––––––––––––––––––––––– -->
<!-- Modales Popup vor dem Löschen -->
<!-- ––––––––––––––––––––––––––––– -->
<section data-title="Modales Popup vor dem Löschen">
    <p class="git-commit">
        Git Commit:
        <a href="https://github.com/DennisSchulmeister/dhbwka-wwi-webprog-my-songbook/tree/XXX" target="_blank">XXX</a>
    </p>

    <!--
    CSS/JS-Code für einen modalen Dialog
    Eigene Komponente <popup-ask-delete>
    Aufruf des Dialogs an der richtigen Stelle
    -->
</section>

<!-- ––––––––––––––––––––––––– -->
<!-- Ein Editor für alle Fälle -->
<!-- ––––––––––––––––––––––––– -->
<section data-title="Ein Editor für alle Fälle">
    <p class="git-commit">
        Git Commit:
        <a href="https://github.com/DennisSchulmeister/dhbwka-wwi-webprog-my-songbook/tree/XXX" target="_blank">XXX</a>
    </p>

    <!--
    Wechsel in den Änderungsmodus der Detailseite
    contenteditable-Attribut für Titel und Interpret
    Event Handler um ENTER abzufangen (keine neue Zeile bzw. <div> bei ENTER, dafür ins nächste Feld springen, event.preventDefaul())
    <textarea> zum Bearbeiten des HTML-Codes des Textes
    Installation von Qilk
    WYSIWIG-Bearbeiten des Textes mit Quilk
    Änderungen sichern bei Okay, Seite neuladen bei Abbrechen
    -->
</section>

<!-- –––––––––––––––––––––––––––––––––– -->
<!-- Onlinesuche und Anlage eines Songs -->
<!-- –––––––––––––––––––––––––––––––––– -->
<section data-title="Onlinesuche und Anlage eines Songs">
    <p class="git-commit">
        Git Commit:
        <a href="https://github.com/DennisSchulmeister/dhbwka-wwi-webprog-my-songbook/tree/XXX" target="_blank">XXX</a>
    </p>

    <!--
    Neue <popup-create-song>-Komponente ausprogrammieren (viel Copy & Paste)
    Installation von lyric-get
    Abruf eines Songs mit lyric-get
    Bessere Alternative: Fetch API mit await
    Abruf des Songs mit der Fetch API, Auswerten des JSON-Strings
    Aufruf der Detailseite im Neuanlagemodus
    Hierfür notwendige Anpassungen an der Detailseite
    -->
</section>
