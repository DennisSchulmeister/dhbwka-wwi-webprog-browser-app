<!-- =========================== -->
<!-- VERSION MIT STATISCHEM HTML -->
<!-- =========================== -->
<section data-chapter data-title="Version mit statischem HTML"></section>

<!-- ‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì -->
<!-- Das Grundger√ºst entsteht -->
<!-- ‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì -->
<section data-title="Das Grundger√ºst entsteht">
    <p class="git-commit">
        Git Commit:
        <a href="https://github.com/DennisSchulmeister/dhbwka-wwi-webprog-my-songbook/tree/abc1fc83de19c5d9f8b666cc4980515335e425be" target="_blank">abc1fc8</a>
    </p>

    <p>
        Bis hierhin sieht unsere App irgendwie noch so gar nicht wie eine App
        aus. Sondern mehr wie eine normale Webseite. Schlimmer noch: Wie ein
        ganz banales ‚ÄûHallo, Welt!‚Äù. An dieser Stelle wollen wir daher das
        Grundlayout der App erstellen, so dass das wir hinterher folgendes
        Ergebnis sehen:
    </p>
    <figure>
        <img src="02/grundstruktur/layout-fertig.jpg" class="border" />
        <figcaption>Das Layout der App, wenn wir hier fertig sind</figcaption>
    </figure>
    <p>
        Der angezeigte Inhalt ist nat√ºrlich nur ein Platzhalter und wird √ºberhaupt
        noch nicht in irgend einer Weise dynamisch erzeugt. Wir k√∂nnen ihn deshalb
        einfach direkt in die HTML-Seite schreiben, damit wir beim Erstellen der
        Stylesheets schon etwas sehen.
        Entferne nun also das <span class="cmd">&lt;h1&gt;</span> aus der
        <span class="fn">src/index.html</span> und ersetze es durch folgenden
        Code. Alle anderen Zeilen bleiben unver√§ndert.
    </p>
    <pre data-gobble>
        <code class="html" data-gobble>
            &lt;!-- ========================= --&gt;
            &lt;!-- Grundger√ºst der Anwendung --&gt;
            &lt;!-- ========================= --&gt;
            &lt;section id="app"&gt;
                &lt;!-- Topbar --&gt;
                &lt;header&gt;
                    &lt;!-- Obere Zeile (fester Inhalt) --&gt;
                    &lt;div class="top left"&gt;
                        &lt;div class="item inactive"&gt;
                            &lt;b&gt;
                                Beispiel einer Browser App: My Songbook
                            &lt;/b&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                    &lt;div class="top right"&gt;
                        &lt;div class="item"&gt;
                            &lt;a href="https://github.com/DennisSchulmeister/dhbwka-wwi-webprog-my-songbook" target="_blank"&gt;GitHub&lt;/a&gt;
                        &lt;/div&gt;
                        &lt;div class="item"&gt;
                            &lt;a href="https://www.wpvs.de/browser-app/" target="_blank"&gt;Programmieranleitung&lt;/a&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;

                    &lt;!-- Untere Zeile (dynamisch je nach View) --&gt;
                    &lt;div class="bottom left"&gt;
                        &lt;div class="item"&gt;
                            Song hinzuf√ºgen
                        &lt;/div&gt;
                        &lt;div class="item"&gt;
                            Sortierung nach Titel
                        &lt;/div&gt;
                    &lt;/div&gt;
                    &lt;div class="bottom right"&gt;
                        &lt;input placeholder="Suchen" /&gt;
                    &lt;/div&gt;
                &lt;/header&gt;

                &lt;!-- Hauptbereich (dynamisch je nach View) --&gt;
                &lt;main&gt;
                    &lt;div class="padding"&gt;
                        Under Construction
                    &lt;/div&gt;
                &lt;/main&gt;
            &lt;/section&gt;
        </code>
    </pre>
    <p>
        Denkt man sich den Dummy-Inhalt weg, l√§sst sich auch schon der Aufbau
        der Seite erkennen:
    </p>
    <pre data-gobble>
        <code class="html" data-gobble>
            &lt;section id="app"&gt;
                &lt;header&gt;
                    &lt;!-- Obere Zeile (fester Inhalt) --&gt;
                    &lt;div class="top left"&gt;
                        ‚Ä¶ Inhalt in allen Views identisch ‚Ä¶
                    &lt;/div&gt;
                    &lt;div class="top right"&gt;
                        ‚Ä¶ Inhalt in allen Views identisch ‚Ä¶
                    &lt;/div&gt;

                    &lt;!-- Untere Zeile (dynamisch je nach View) --&gt;
                    &lt;div class="bottom left"&gt;
                        ‚Ä¶
                    &lt;/div&gt;
                    &lt;div class="bottom right"&gt;
                        ‚Ä¶
                    &lt;/div&gt;
                &lt;/header&gt;

                &lt;!-- Hauptbereich (dynamisch je nach View) --&gt;
                &lt;main&gt;
                    ‚Ä¶
                &lt;/main&gt;
            &lt;/section&gt;
        </code>
    </pre>
    <p>
        Diese Inhalte m√ºssen wir nun mit den zuvor angelegten Stylesheets in Form bringen,
        da die eingebauten Layoutregeln des Browsers nat√ºrlich nicht wie von Zauberhand
        einfach das obigen Layout erzeugen werden. Doch zuvor musst du dir von GitHub
        folgende drei Bilder herunterladen:
    </p>
    <ul>
        <li>
            <a href="https://raw.githubusercontent.com/DennisSchulmeister/dhbwka-wwi-webprog-my-songbook/master/src/favicon.svg" target="_blank">src/favicon.svg</a>: Icon der App
        </li>
        <li>
            <a href="https://raw.githubusercontent.com/DennisSchulmeister/dhbwka-wwi-webprog-my-songbook/master/src/background.jpg" target="_blank">src/background.jpg</a>: Hintergrundbild auf gro√üen Bildschirmen
        </li>
        <li>
            <a href="https://raw.githubusercontent.com/DennisSchulmeister/dhbwka-wwi-webprog-my-songbook/master/src/construction.jpg" target="_blank">src/construction.jpg</a>: Platzhalter im Hauptbereich der App
        </li>
    </ul>
    <p>
        Anschlie√üend lege eine neue Datei namens <span class="fn">src/theme.css</span> und
        folgendem Inhalt an. Sie enth√§lt h√§ufig ben√∂tigte
        <a href="https://www.w3schools.com/css/css3_variables.asp" target="_blank">CSS-Variablen</a>,
        die wir an anderer Stelle immer wieder ben√∂tigen werden:
    </p>
    <pre data-gobble>
        <code class="css" data-gobble>
            html {
                --font-color:                     black;
                --highlight-background-color:     rgab(235, 235, 235, 1.0);

                --header-normal-background-color: rgba(017,111,159, 1.0);
                --header-normal-font-color:       rgba(255,255,255, 0.8);
                --header-active-background-color: rgba(255,255,255, 0.2);
                --header-active-font-color:       rgba(255,255,255, 0.9);
            }
        </code>
    </pre>
    <p>
        Damit haben wir erst einmal alle Dateien beisammen. Die Verzeichnisstruktur sollte jetzt
        wie in der n√§chsten Abbildung bei dir aussehen:
    </p>
    <figure>
        <img src="02/grundstruktur/alle-dateien.png" />
        <figcaption>Verzeichnisstruktur der Webanwendung an dieser Stelle</figcaption>
    </figure>
    <p>
        Damit das neue Stylesheet nun aber auch wirken kann, muss es erst noch importiert werden.
        √Ñndere deshalb den Import des alten Stylesheets in der <spann class="fn">src/index.js</spann>
        zu folgenden zwei Zeilen ab. Achte dabei aber darauf, wirklich erst die Datei
        <span class="fn">./index.css</span> und dann die Datei <span class="fn">./theme.css</span>
        zu importieren:
    </p>
    <pre data-gobble>
        <code class="js" data-gobble>
            import stylesheet from "./index.css";
            import theme from "./theme.css";
        </code>
    </pre>
    <p>
        Der Inhalt der Datei <span class="fn">src/index.css</span> √§ndert sich nun komplett
        zu folgenden Zeilen. Zun√§chst ein paar allgemeine Definitionen:
    </p>
    <pre data-gobble>
        <code class="css" data-gobble>
            /*
             * Dieses Stylesheet enth√§lt nur allgemeine Anweisungen, die sich auf die
             * gesamte App auswirken. Hier d√ºrfen keine √Ñnderungen vorgenommen werden,
             * die sich nur auf bestimmte Bereiche der Anwendung auswirken sollen.
             *
             * Damit @import funktioniert, muss die Anweisung vor allen anderen
             * CSS-Anweisungen stehen. Dieses Stylesheet muss daher auch vor allen
             * anderen importiert werden.
             */
            @import url('https://fonts.googleapis.com/css?family=Roboto');

            html, body {
                padding: 0;
                margin: 0;
                height: 100%;
            }

            body {
                font-family: 'Roboto', sans-serif;
                font-size: 11pt;
                line-height: 1.6;
                color: var(--font-color);
            }
        </code>
    </pre>

    <p>
        Dann ein paar Anpassungen der Schriftgr√∂√üe je nach Bildschirmaufl√∂sung:
    </p>
    <pre data-gobble>
        <code class="css" data-gobble>
            /*
             * Gr√∂√üere Schrift auf gr√∂√üeren Bildschirmen
             * Vgl. https://getbootstrap.com/docs/4.0/layout/overview/#responsive-breakpoints
             */
            @media screen and (min-width: 768px) {
                body,
                input {
                    font-size: 12pt;
                }
            }

            @media screen and (min-width: 992px) {
                body,
                input {
                    font-size: 13pt;
                }
            }

            @media screen and (min-width: 1200px) {
                body,
                input {
                    font-size: 14pt;
                }
            }
        </code>
    </pre>

    <p>
        Und zum Schluss wie immer ein Media Query, um auf gro√üen Bildschirmen
        die Darstellung zu optimieren, sowie ein paar n√ºtzliche Helferlein:
    </p>
    <pre data-gobble>
        <code class="css" data-gobble>
            /*
             * Fl√§chendeckender Seitenhintergrund auf gro√üen Bildschirmen
             */
            @media (min-width: 80em) {
                /* Hintergrundbild hinter dem Hauptbereich der App */
                html {
                    /* https://pixabay.com/de/computer-notebook-kaffee-820281/ */
                    background-image: url(background.jpg);
                    background-attachment: fixed;
                    background-size: cover;
                    background-position: center;
                }

                /* Hauptbereich der App vergr√∂√üern */
                body {
                    display: flex;
                    align-items: stretch;
                    justify-content: center;
                }

                body > * {
                    flex: 1;
                }
            }

            /*
             * H√§ufig ben√∂tigte Hilfsklassen
             */
            .hidden {
                display: none;
            }

            .padding {
                padding: 0.5rem;
            }
        </code>
    </pre>

    <p>
        Wie du (hoffentlich) siehst, werden hier wirklich nur ganz allgemeine Dinge
        geregelt, die sich auf die gesamte App auswirken. Spezifische Anpassungen
        f√ºr einen einzelnen Bereich werden stattdessen in getrennten Stylesheets
        vorgenommen, wobei es im Grunde genommen je JavaScript-Datei eine gleichnamige
        CSS-Datei gibt. Die Datei
        <span class="fn">src/app.css</span> beginnt daher wie immer mit ein paar
        allgemeinen Definitionen:
    </p>
    <pre data-gobble>
        <code class="css" data-gobble>
            /*
             * Dieses Stylesheet darf nur Selektoren beinhalten, die mit #app beginnen.
             * Denn wir wollen nicht, dass hier Eigenschaften aus anderen Bereichen der
             * Anwendung √ºberschrieben werden.
             */
            #app {
                background-color: white;
                flex: 1;
            }
        </code>
    </pre>
    <p>
        Daraufhin folgt eine gro√üe Zahl an Regeln zur Gestaltung des Kopfbereichs.
        Auch sie fangen alle mit <span class="cmd">#app</span> an, um ihre G√ºltigkeit
        zu begrenzen:
    </p>
    <pre data-gobble>
        <code class="css" data-gobble>
            /*
             * Kopfbereich √ºber dem Inhalt
             */
            #app header {
                background-color: var(--header-normal-background-color);
                color: var(--header-normal-font-color);
            }

            #app header > *,
            #app header input,
            #app header .item {
                display: block;
                box-sizing: border-box;
                width: 100%;
            }

            #app header > .top {
                font-size: 80%;

                border: 0px solid var(--header-active-background-color);
                border-bottom-width: 1px;
            }

            #app header > .top .item,
            #app header > .top input {
                padding: 0.5rem;
            }

            #app header > .bottom {
                border: 0px solid var(--header-active-background-color);
                border-bottom-width: 1px;
            }

            #app header > .bottom .item,
            #app header > .bottom input {
                padding: 1rem 0.5rem 1rem 0.5rem;
            }

            #app header .active,
            #app header .item:not(.inactive):hover {
                background-color: var(--header-active-background-color);
                color: var(--header-active-font-color);
            }

            #app header .item:not(.inactive) {
                cursor: pointer;
            }

            #app header a,
            #app header a:visited {
                color: var(--header-normal-font-color);
                text-decoration: none;
            }

            #app header a:hover {
                color: var(--header-active-font-color);
                text-decoration: underline;
            }

            #app header input {
                background: none;
                color: var(--header-normal-font-color);
                border: 0;
            }
        </code>
    </pre>

    <p>
        Dann wieder etwas tempor√§rer Inhalt, um das Baustellenbild beim Aufruf
        der App anzuzeigen üöß und einen kleinen Hinwestext in der Mitte zu
        platzieren:
    </p>
    <pre data-gobble>
        <code class="css" data-gobble>
            /*
             * Hauptinhalt
             */
            #app main {
                /*
                 * Tempor√§rer Inhalt, solange es noch keinen richtigen Inhalt gibt
                 * Bild: https://pixabay.com/de/handwerker-baustelle-arbeiter-3094035/
                 */
                background-image: url(construction.jpg);2
                background-size: 100% auto;
                background-position: bottom center;
                background-repeat: no-repeat;

                color: rgb(255, 246, 23);
                text-shadow: 1px 1px 2px black;
                font-size: 300%;
                font-weight: bold;
                text-align: center;
            }
        </code>
    </pre>
    <p>
        Und zum Schlu√ü wie immer die Anpassung an gro√üe Bildschirme. Die Angabe
        <span class="cmd">(min-width: 80em)</span> in der f√ºnften Zeile muss
        exakt mit dem Media Query in der <span class="fn">src/index.css</span>
        stehen, damit die Darstellung in jedem Fall passt:
    </p>
    <pre data-gobble>
        <code class="css" data-gobble>
            /*
             * Anpassung an gro√üe Bildschirme, sobald in der index.css das gro√üe
             * Hintergrundbild eingeschaltet wird
             */
            @media screen and (min-width: 80em) {
                /* Rahmen um den Hauptbereich zeichnen */
                #app {
                    max-width: 80em;
                    margin-top: 2em;
                    margin-bottom: 2em;

                    border: 1px solid rgba(32,32,32, 0.2);
                    box-shadow: 1px 1px 3px rgba(0,0,0, 0.1);
                }

                /* Topbar- und Toolbar-Inhalte nebeneinander */
                #app header {
                    display: grid;
                    grid-template-columns: auto 20em;
                }

                #app header .top {
                    grid-row: 1;
                }

                #app header .bottom {
                    grid-row: 2;
                }

                #app header .left {
                    grid-column: 1;

                    display: flex;
                    justify-content: flex-start;
                }

                #app header .right{
                    grid-column: 2;

                    display: flex;
                    justify-content: flex-start;

                    background-color: var(--header-active-background-color);
                    color: var(--header-active-font-color);
                }

                #app header .item {
                    width: auto;
                }

                /* Nur den Bereich unterhalb der Toolbar scrollen */
                #app {
                    display: flex;
                    flex-direction: column;
                }

                #app > main {
                    flex: 1;
                    overflow: auto;
                }
            }
        </code>
    </pre>
    <p>
        Und das war es dann auch schon. Zugegeben war das jetzt zwar extrem viel Copy &amp; Paste.
        Auf dieser Grundlage k√∂nnen wir der App im n√§chsten Schritt nun aber ein wenig Leben einhauchen.
    </p>
</section>

<!-- ‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì -->
<!-- Navigation innerhalb der App -->
<!-- ‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì -->
<section data-title="Navigation innerhalb der App">
    <p class="git-commit">
        Git Commit:
        <a href="https://github.com/DennisSchulmeister/dhbwka-wwi-webprog-my-songbook/tree/1451b1db51fce4657c253f3d3b1fe733139edcd7" target="_blank">1451b1d</a>
    </p>

    <p>
        Rein visuell sieht unsere Seite jetzt schon viel mehr wie eine App aus. Man kann aber noch
        nichts anklicken, weshalb es sich im Grunde genommen immer noch um eine statische HTML-Seite
        handelt. An dieser Stelle wollen wir daher das Grundger√ºst etwas erweitern und eine einfache
        Navigation erm√∂glichen. Dadurch soll es m√∂glich sein, zwischen der √úbersichtsseite (die wir
        an dieser Stelle immer noch nicht mit Inhalt f√ºllen werden) und der sp√§teren Detailseite
        umzuschalten, so dass wir dann endg√ºltig von einer echten Browser App sprechen k√∂nnen. Denn
        im Gegensatz zu einer serverseitigen Webanwendung soll das hin und her Schalten zwischen den
        Seiten komplett im Browser geschehen, ohne hierf√ºr eine neue Seite vom Server anzufordern.
    </p>

    <h3>Umstrukturierung des HTML-Codes</h3>
    <p>
        Im ersten Schritt m√ºssen wir die Datei <span class="fn">src/index.html</span> so umbauen,
        dass jeder Bereich der App eine eigene <span class="cmd">&lt;section&gt;</span> bekommt,
        die wir √ºber eine eindeutige Id adressieren k√∂nnen. Allerdings sollen diese neuen Bereiche
        nicht sichtbar sein, da wir sonst ja nicht zwischen den einzelnen Bereichen umherschalten
        k√∂nnten. Die CSS-Klasse <span class="cmd">hidden</span> stellt deshalb sicher, dass wirklich
        nur die erste <span class="cmd">&lt;section id="app"&gt;</span> mit dem Anwendungsrahmen
        und sonst nichts angezeigt wird.
    </p>
    <pre data-gobble>
        <code class="html" data-gobble>
            &lt;!DOCTYPE html&gt;
            &lt;html&gt;
                &lt;head&gt;
                    &lt;meta charset="utf-8" /&gt;
                    &lt;title>My Songbook&lt;/title&gt;
                    &lt;link rel="shortcut icon" href="favicon.svg"&gt;

                    &lt;script src="index.js"&gt;&lt;/script&gt;
                &lt;/head&gt;
                &lt;body&gt;
                    &lt;!-- ========================= --&gt;
                    &lt;!-- Grundger√ºst der Anwendung --&gt;
                    &lt;!-- ========================= --&gt;
                    &lt;section id="app"&gt;
                        ‚Ä¶
                    &lt;/section&gt;

                    &lt;!-- ====================== --&gt;
                    &lt;!-- View: Vorhandene Songs --&gt;
                    &lt;!-- ====================== --&gt;
                    &lt;section id="song-overview" class="hidden"&gt;
                        ‚Ä¶
                    &lt;/section&gt;

                    &lt;!-- ================================== --&gt;
                    &lt;!-- View: Song anzeigen und bearbeiten --&gt;
                    &lt;!-- ================================== --&gt;
                    &lt;section id="song-display-edit" class="hidden"&gt;
                        ‚Ä¶
                    &lt;/section&gt;
                &lt;/body&gt;
            &lt;/html&gt;
        </code>
    </pre>
    <p>
        Anschlie√üend k√∂nnen wir den Dummy-Inhalt aus dem Grundger√ºst wieder entfernen, so dass
        davon nur folgende Zeile √ºbrig bleiben. Den festen Inhalt der Topbar, der wirklich immer zu
        sehen sein woll, behalten wir hier nat√ºrlich bei.
    </p>
    <pre data-gobble>
        <code class="html" data-gobble>
            &lt;!-- ========================= --&gt;
            &lt;!-- Grundger√ºst der Anwendung --&gt;
            &lt;!-- ========================= --&gt;
            &lt;section id="app"&gt;
                &lt;!-- Topbar --&gt;
                &lt;header&gt;
                    &lt;!-- Obere Zeile (fester Inhalt) --&gt;
                    &lt;div class="top left"&gt;
                        &lt;div class="item inactive"&gt;
                            &lt;b&gt;
                                Beispiel einer Browser App: My Songbook
                            &lt;/b&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                    &lt;div class="top right"&gt;
                        &lt;div class="item"&gt;
                            &lt;a href="https://github.com/DennisSchulmeister/dhbwka-wwi-webprog-my-songbook" target="_blank"&gt;GitHub&lt;/a&gt;
                        &lt;/div&gt;
                        &lt;div class="item"&gt;
                            &lt;a href="https://www.wpvs.de/browser-app/" target="_blank"&gt;Programmieranleitung&lt;/a&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;

                    &lt;!-- Untere Zeile (dynamisch je nach View) --&gt;
                &lt;/header&gt;

                &lt;!-- Hauptbereich (dynamisch je nach View) --&gt;
                &lt;main&gt;
                &lt;/main&gt;
            &lt;/section&gt;
        </code>
    </pre>
    <p>
        Den eben entfernten HTML-Code bauen wir stattdessen weiter unten in die <span class="cmd">&lt;section&gt;</span>
        f√ºr die √úbersichtsseite wieder ein.¬π
    </p>
    <pre data-gobble>
        <code class="html" data-gobble>
            &lt;!-- ====================== --&gt;
            &lt;!-- View: Vorhandene Songs --&gt;
            &lt;!-- ====================== --&gt;
            &lt;section id="song-overview" class="hidden"&gt;
                &lt;!-- Topbar --&gt;
                &lt;header&gt;
                    &lt;div class="left"&gt;
                        &lt;div class="item new-song"&gt;
                            Song hinzuf√ºgen
                        &lt;/div&gt;
                        &lt;div class="item"&gt;
                            Sortierung nach Titel
                        &lt;/div&gt;
                    &lt;/div&gt;
                    &lt;div class="right"&gt;
                        &lt;input placeholder="Suchen" /&gt;
                    &lt;/div&gt;
                &lt;/header&gt;

                &lt;!-- Hauptbereich --&gt;
                &lt;main&gt;
                    &lt;div class="padding"&gt;
                        √úbersicht
                    &lt;/div&gt;
                &lt;/main&gt;
            &lt;/section&gt;
        </code>
    </pre>
    <p>
        ¬π
        <small>
            Die CSS-Klasse <span class="cmd">bottom</span> f√ºr die beiden <span class="cmd">&lt;div&gt;</span>
            in der Topbar haben wir hier absicshtlich weggelassen. Doch dazu sp√§ter mehr.
        </small>
    </p>
    <p>
        Und auch die Detailseite gestalten wir √§hnlich, da sie zur diesem Zeitpunkt nat√ºrlich auch noch keinen
        wirklichen Inhalt besitzt. Immerhin bekommt sie in der Topbar jedoch bereits einen Eintrag, mit dem der
        Anwender zur√ºck auf die √úbersichtsseite gelangen soll.
    </p>
    <pre data-gobble>
        <code class="html" data-gobble>
            &lt;!-- ================================== --&gt;
            &lt;!-- View: Song anzeigen und bearbeiten --&gt;
            &lt;!-- ================================== --&gt;
            &lt;section id="song-display-edit" class="hidden"&gt;
                &lt;!-- Topbar --&gt;
                &lt;header&gt;
                    &lt;div class="left"&gt;
                        &lt;!-- Leer --&gt;
                    &lt;/div&gt;
                    &lt;div class="right"&gt;
                        &lt;div class="item overview"&gt;
                            Zur√ºck zur √úbersicht
                        &lt;/div&gt;
                    &lt;/div&gt;
                &lt;/header&gt;

                &lt;!-- Hauptbereich --&gt;
                &lt;main&gt;
                    &lt;div class="padding"&gt;
                        Song anzeigen/bearbeiten
                    &lt;/div&gt;
                &lt;/main&gt;
            &lt;/section&gt;
        </code>
    </pre>

    <h3>Austausch der sichtbaren Inhalte mit JavaScript</h3>
    <p>
        Mit diesen √Ñnderungen nun an Ort und Stelle k√∂nnen wir uns an die Ausprogrammierung der
        <span class="cmd">App</span>-Klasse innerhalb der Datei <span class="fn">src/app.js</span>
        machen. Denn sie soll f√ºr die Navigation innerhalb der App zust√§ndig sein und zwischen den
        verschiedenen Ansichten umschalten. Die eigentliche Arbeit macht dabei die folgende, neue
        Methode, wobei der Unterstrich am Anfang des Namens ausdr√ºckt, dass sie nur innerhalb der
        Klasse selbst aufgerufen werden sollte. Erzwungen wird das von JavaScript allerdings nicht.
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            /**
             * Auswechseln des sichtbaren Inhalts der App. Hierf√ºr muss der Methode
             * ein Objekt mit folgendem Aufbau √ºbergeben werden:
             *
             *   {
                    className: "CSS-Klassenname",
             *      topbar: [DOM Element, DOM Element, DOM Element, ...],
             *      main: [DOM Element, DOM Element, DOM Element, ...],
             *   }
             *
             * Beide Attribute (topbar und main) sind optional, was dazu f√ºhrt, dass
             * im jeweiligen Bereich einfach nichts angezeigt wird. Werden sie jedoch
             * mitgegeben, m√ºssen sie mit forEach(element =&gt; { ‚Ä¶ }) iteriert werden
             * k√∂nnen, um ihren Inhalt in den DOM-Baum zu integrieren.
             *
             * Wichtig ist, dass die √ºbergebenen Elemente noch an keiner Stelle im
             * DOM vorhanden sein d√ºrfen. Werden die Elemente in der index.html
             * als Vorlage definiert, muss hier deshalb eine Kopie anstelle der
             * Elemente selbst √ºbergeben werden!
             *
             * @param {Object} content Objekt mit den anzuzeigenden DOM-Elementen
             */
            _switchVisibleContent(content) {
                // &lt;header&gt; und &lt;main&gt; des HTML-Grundger√ºsts ermitteln
                let app = document.querySelector("#app");
                let header = document.querySelector("#app &gt; header");
                let main = document.querySelector("#app &gt; main");

                // Zuvor angezeigte Inhalte entfernen
                // Bei der Topbar nur die untere Zeile, im Hauptbereich alles!
                app.className = "";
                header.querySelectorAll(".bottom").forEach(e =&gt; e.parentNode.removeChild(e));
                main.innerHTML = "";

                // CSS-Klasse √ºbernehmen, um die viewspezifischen CSS-Regeln zu aktivieren
                if (content && content.className) {
                    app.className = content.className;
                }

                // Neue Inhalte der Topbar einf√ºgen
                if (content && content.topbar) {
                    content.topbar.forEach(element =&gt; {
                        element.classList.add("bottom");
                        header.appendChild(element);
                    });
                }

                // Neue Inhalte des Hauptbereichs einf√ºgen
                if (content && content.main) {
                    content.main.forEach(element =&gt; {
                        main.appendChild(element);
                    });
                }
            }
        </code>
    </pre>
    <p>
        Der Quellcode ist im Grunde genommen nicht sehr kompliziert. Dennoch sollten wir ihn an dieser
        Stelle kurz durchgehen, um sicherzustellen, dass du ihn wirklich verstehst:
    </p>
    <ol>
        <li>
            Zun√§chst greift die Methode auf das DOM zu, um sich die
            <span class="cmd">&lt;section id="app"&gt;</span> sowie die darin enthaltenen
            <span class="cmd">&lt;header&gt;</span>- und
            <span class="cmd">&lt;main&gt;</span>-Elemente zu besorgen.
        </li>
        <li>
            Anschlie√üend werden die zuvor sichtbaren Inhalte verworfen. Im Falle der
            Topbar mit einer <span class="cmd">forEach()</span>-Schleife, die nur
            die Elemente der unteren Zeile erwischt. Und im Hauptbereich durch
            √úberschreiben des <spann class="cmd">innerHTML</spann>-Attributs,
            was de facto seinen kompletten Inhalt l√∂scht.
        </li>
        <li>
            Dann wird mit einer <span class="cmd">if</span>-Abfrage gebpr√ºft, ob
            ob das <span class="cmd">content</span>-Objekt ein Attribut mit dem
            Namen <span class="cmd">classList</span> enth√§lt. Falls ja wird die
            CSS-Klasse des <span class="cmd">&lt;section id="app"&gt;</span>
            entsprechend abge√§ndert, damit etwaige CSS-Regeln, die sich auf
            diese Klasse beziehen, wirksam werden k√∂nnen.
        </li>
        <li>
            Danach wird gepr√ºft, ob ein neuer Inhalt f√ºr die Topbar √ºbergeben wurde.
            Falls ja, wird in einer Schleife √ºber die neuen Topbar-Elemente jedem
            Element die CSS-Klasse <span class="cmd">bottom</span> hinzugef√ºgt
            und die Elemente an den <span class="code">&lt;header&gt;</span>
            angeh√§ngt.
        </li>
        <li>
            Dann erfolgt mit einer √§hnlichen Abfrage eine Pr√ºfung f√ºr den Hauptbereich
            der App, nur dass den Elementen hier keine zus√§tzliche CSS-Klasse mitgegeben
            werden muss.
        </li>
    </ol>

    <p>
        Auf diese Weise k√∂nnen wir nun den angezeigten Inhalt der App variieren. Wirklich
        anwenderfreundlich ist die neue Methode aber noch nicht, da wir ihr, um eine neue
        Seite anzuzeigen, genau die hierf√ºr notwendigen DOM-Elemente mitgegeben m√ºssen.
        Besser w√§re es jedoch, wenn wir eine bestimmte Seite einfach aufrufen k√∂nnten,
        ohne genau zu wissen, wie die Seite eigentlich aufgebaut ist. Wir ben√∂tigen daher
        f√ºr jede Seite eine weitere Methode, die genau diesen Zweck erf√ºllt. Doch hierf√ºr
        m√ºssen wir uns erst noch √ºberlegen, wie wir den Quellcode der App weiter strukturieren
        wollen.
    </p>

    <h3>Eine Klasse je Bildschirmseite</h3>
    <p>
        Nat√ºrlich k√∂nnten wir die komplette Anwendungslogik einfach in der Datei <span class="fn">src/app.js</span>
        oder sogar nur in der Klasse <span class="fn">App</span> ausprogrammieren. Dem Computer w√§re das
        ziemlich gleich. Allerdings wissen wir, dass die beiden Seiten mit der √úbersicht und zur Anzeige
        eines Songtextes nicht wirklich viel gemeinsam haben. Alles in eine Klasse zu packen w√§re daher
        ziemlich un√ºbersichtlich. Das alte Sprichwort ‚Äûteile und herrsche‚Äù liefert stattdessen viel bessere
        Ergebnisse, da es uns an die
        <a href="https://t3n.de/news/prinzipien-software-entwicklung-solid-615556/" target="_blank">SOLID-Kriterien</a>
        und hier insbesondere an das Single-Responsibility-Prinzip erinnert. Es liegt deshalb nahe, f√ºr
        jede Bildschirmseite eine eigene Klasse vorzusehen. Und f√ºr jede Klasse dementsprechend eine
        eigene JavaScript-Datei und ein eigenes Stylesheet, die wir um die √úbersichtlichkeit noch
        weiter zu erh√∂hen, jeweils in ein eigenes Verzeichnis packen.
    </p>
    <p>
        Bevor wir also weiter programmieren, lege zun√§chst folgende Dateistruktur an. Die Dateien
        k√∂nnen dabei an dieser Stelle noch leer bleiben:
    </p>
    <ul>
        <li>
            <span class="fn">src/song-overview/song-overview.js:</span> Klasse <span class="cmd">SongOverview</span> f√ºr die √úbersichtsseite
        </li>
        <li>
            <span class="fn">src/song-overview/song-overview.css:</span> Stylesheet f√ºr die √úbersichtsseite
        </li>
        <li>
            <span class="fn">src/song-display-edit/song-display-edit.js:</span> Klasse <span class="cmd">SongDisplayEdit</span> f√ºr die Detailseite
        </li>
        <li>
            <span class="fn">src/song-display-edit/song-display-edit.css:</span> Stylesheet f√ºr die Detailseite
        </li>
    </ul>
    <p>
        Das Ergebnis sollte dementsprechend so aussehen:
    </p>
    <figure>
        <img src="02/navigation/neue-dateien.png" />
        <figcaption>Erweiterte Verzeichnisstruktur f√ºr die √úbersichts- und die Detailseite</figcaption>
    </figure>
    <p>
        Die beiden Stylesheets sind am einfachsten. Hier wollen wir zun√§chst nur etwas Dummy-Inhalt
        einbauen, damit wir sp√§ter sehen, ob sie auch wirklich ausgewertet werden. F√ºge daher in die
        Datei <span class="fn">src/song-overview/song-overview.css</span> folgende Zeile ein:
    </p>
    <pre data-gobble>
        <code class="css" data-gobble>
            /*
             * Dieses Stylesheet darf nur Selektoren beinhalten, die mit .song-overview
             * beginnen. Denn wir wollen nicht, dass hier Eigenschaften aus anderen Bereichen
             * der Anwendung √ºberschrieben werden.
             */
            .song-overview main {
                color: orangered !important;
            }
        </code>
    </pre>
    <p>
        Und in die <span class="fn">src/song-display-edit/song-display-edit.css</span> folgende Zeilen:
    </p>
    <pre data-gobble>
        <code class="css" data-gobble>
            /*
             * Dieses Stylesheet darf nur Selektoren beinhalten, die mit .song-display-edit
             * beginnen. Denn wir wollen nicht, dass hier Eigenschaften aus anderen Bereichen
             * der Anwendung √ºberschrieben werden.
             */
            .song-display-edit main {
                color: orchid !important;
            }
        </code>
    </pre>
    <p>
        Bei den beiden Klassen wird es hingegen schon interessanter, da wir uns noch gar
        keine Gedanken dar√ºber gemacht haben, welche Methoden sie besitzen sollen und zu
        welchem sie aufgerufen werden. Letztlich gibt es auch gar keine universelle L√∂sung
        hierf√ºr, in der Praxis hat sich aber ganz unabh√§ngig von der Art der Anwendung oder
        der verwendeten UI-Technologie folgende, einfache Struktur bew√§hrt:
    </p>
    <ol>
        <li>
            Jedes Mal, wenn eine Seite aufgerufen wird, wird ein neues Objekt der dazugeh√∂rigen
            Klasse erzeugt. Das Objekt bleibt dabei so lange aktiv, wie die Seite sichtbar ist.
        </li>
        <li>
            Wird von einer Seite auf dieselbe Seite nur mit anderen Daten gewechselt (zum Beispiel
            von der Detailseite eines Songs zur Detailseite eines anderen Songs), wird hierf√ºr
            ebenfalls ein neues Objekt erzeugt.
        </li>
        <li>
            Denn dies erm√∂glicht es, die Klassen einfach zu halten und f√ºr die Anzeige ben√∂tigte
            Informationen wie die Song-ID einfach dem Konstruktor zu √ºbergeben.
        </li>
        <li>
            Bevor eine neue Seite aufgerufen wird, wird die Methode <span class="cmd">onShow()</span>
            des jeweiligen Objekts aufgerufen.
        </li>
        <li>
            Davor wird jedoch erst die Methode <span class="cmd">onLeave()</span> der aktuell sichtbaren
            Seite aufgerufen, um ihr die M√∂glichkeit zu geben, Aufr√§umarbeiten durchzuf√ºhren oder den
            Seitenwechsel zu unterbinden.
        </li>
        <li>
            Eine Methode mit dem Namen <span class="cmd">getTitle()</span> gibt den Titel der aktuellen
            Seite zur√ºck, um ihn in der Titelzeile des Browserfensters anzuzeigen.
        </li>
        <li>
            Sobald eine Seite verlassen wurde, kann das dazugeh√∂rige Objekt abger√§umt werden.
        </li>
    </ol>
    <p>
        Damit haben wir einen klaren Lebenszyklus definiert, der genau vorschreibt, zu welchem Zeitpunkt
        neue Objekte entstehen, welche Methoden dementsprechend aufgerufen werden und wann die Objekte
        wieder verschwinden. Au√üerdem haben wir eine M√∂glichkeit geschaffen, besondere F√§lle wie das
        Vorliegen nicht gespeicherter Daten abzufangen, bei denen wir den Anwender erst fragen m√ºssen,
        ob er seine √Ñnderungen sichern will, oder wir den Aufruf der Folgeseite ganz einfach unterbinden.
    </p>
    <p>
        Die Datei <span class="fn">src/song-overview/song-overview.js</span> soll dementsprechend
        folgenden Inhalt besitzen.
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            "use strict";

            import stylesheet from "./song-overview.css";

            /**
             * View mit der √úbersicht der vorhandenen Songs.
             */
            class SongOverview {
                /**
                 * Konstruktor.
                 * @param {Objekt} app Zentrales App-Objekt der Anwendung
                 */
                constructor(app) {
                    this._app = app;
                }

                /**
                 * Von der Klasse App aufgerufene Methode, um die Seite anzuzeigen. Die
                 * Methode gibt daher ein passendes Objekt zur√ºck, das an die Methode
                 * _switchVisibleContent() der Klasse App √ºbergeben werden kann, um ihr
                 * die darzustellenden DOM-Elemente mitzuteilen.
                 *
                 * @return {Object} Darzustellende DOM-Elemente gem√§√ü Beschreibung der
                 * Methode App._switchVisibleContent()
                 */
                onShow() {
                    // Machen wir gleich
                }

                /**
                 * Von der Klasse App aufgerufene Methode, um festzustellen, ob der Wechsel
                 * auf eine neue Seite erlaubt ist. Wird hier true zur√ºckgegeben, wird der
                 * Seitenwechsel ausgef√ºhrt.
                 *
                 * @param  {Function} goon Callback, um den Seitenwechsel zu einem sp√§teren
                 * Zeitpunkt fortzuf√ºhren, falls wir hier false zur√ºckgeben
                 * @return {Boolean} true, wenn der Seitenwechsel erlaubt ist, sonst false
                 */
                onLeave(goon) {
                    return true;
                }

                /**
                 * @return {String} Titel f√ºr die Titelzeile des Browsers
                 */
                get title() {
                    return "√úbersicht";
                }
            }

            export default SongOverview;
        </code>
    </pre>
    <p>
        Die Datei <span class="fn">src/song-display-edit/song-display-edit.js</span> soll hingegen
        folgenden Inhalt besitzen:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            "use strict";

            import stylesheet from "./song-display-edit.css";

            /**
             * View zur Anzeige oder zum Bearbeiten eines Songs.
             */
            class SongDisplayEdit {
                /**
                 * Konstruktor.
                 *
                 * @param {Objekt} app Zentrales App-Objekt der Anwendung
                 * @param {String} id   ID des darzustellenden Songs
                 * @param {String} mode "new", "display" oder "edit"
                 */
                constructor(app, id, mode) {
                    this._app = app;
                    this._id = id;
                    this._mode = mode;
                }

                /**
                 * Von der Klasse App aufgerufene Methode, um die Seite anzuzeigen. Die
                 * Methode gibt daher ein passendes Objekt zur√ºck, das an die Methode
                 * _switchVisibleContent() der Klasse App √ºbergeben werden kann, um ihr
                 * die darzustellenden DOM-Elemente mitzuteilen.
                 *
                 * @return {Object} Darzustellende DOM-Elemente gem√§√ü Beschreibung der
                 * Methode App._switchVisibleContent()
                 */
                onShow() {
                    // Machen wir gleich
                }

                /**
                 * Von der Klasse App aufgerufene Methode, um festzustellen, ob der Wechsel
                 * auf eine neue Seite erlaubt ist. Wird hier true zur√ºckgegeben, wird der
                 * Seitenwechsel ausgef√ºhrt.
                 *
                 * @param  {Function} goon Callback, um den Seitenwechsel zu einem sp√§teren
                 * Zeitpunkt fortzuf√ºhren, falls wir hier false zur√ºckgeben
                 * @return {Boolean} true, wenn der Seitenwechsel erlaubt ist, sonst false
                 */
                onLeave(goon) {
                    return true;
                }

                /**
                 * @return {String} Titel f√ºr die Titelzeile des Browsers
                 */
                get title() {
                    switch (this._mode) {
                        case "new":
                            return "Song hinzuf√ºgen";
                        case "edit":
                            return "Song bearbeiten";
                        default:
                            return "Song anzeigen";
                    }
                }
            }

            export default SongDisplayEdit;
        </code>
    </pre>

    <h3>Weitere Methoden f√ºr die Klasse App</h3>
    <p>
        Da der Vertrag mit dem View-Klassen nun klar ist, besitzen wir alle Informationen, um die
        Klasse <span class="cmd">App</span> nun zu Ende zu programmieren. F√ºge deshalb √ºber der
        Methode <span class="cmd">_switchVisibleContent()</span> eine neue Methode mit dem Namen
        <span class="cmd">_switchVisibleView()</span> ein, die sie aufruft und hierf√ºr ein
        View-Objekt entgegen nimmt:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            /**
             * Hilfsklasse zum Umschalten auf eine neue Seite. Sie ruft zun√§chst die
             * Methode onLeave() der gerade sichtbaren View auf und pr√ºft damit, ob
             * die View verlassen werden kann. Falls ja ruft sie die Methode onShow()
             * der neuen View auf und √ºbergibt das Ergebnis an die eigene Methode
             * _switchVisibleContent(), um den sichtbaren Inhalt der Seite auszutauschen.
             *
             * @param  {Object} view View-Objekt mit einer onShow()-Methode
             * @return {Boolean} Flag, ob die neue Seite aufgerufen werden konnte
             */
            _switchVisibleView(view) {
                // Callback, mit dem die noch sichtbare View den Seitenwechsel zu einem
                // sp√§teren Zeitpunkt fortf√ºhren kann, wenn sie in der Methode onLeave()
                // false zur√ºckliefert. Dadurch erh√§lt sie die M√∂glichkeit, den Anwender
                // zum Beispiel zu fragen, ob er ungesicherte Daten speichern will,
                // bevor er die Seite verl√§sst.
                let goon = () =&gt; this._switchVisibleView(view);

                // Aktuelle View fragen, ob eine neue View aufgerufen werden darf
                if (this._currentView && !this._currentView.onLeave(goon)) {
                    return false;
                }

                // Alles klar, aktuelle View nun wechseln
                document.title = `${this._title} ‚Äì ${view.title}`;

                this._currentView = view;
                this._switchVisibleContent(view.onShow());
                return true;
            }

            /**
             * ‚Ä¶
             */
            _switchVisibleContent(content) {
                ‚Ä¶
            }
        </code>
    </pre>
    <p>
        Die zwei Instanzattribute <span class="cmd">this._currentView</span> und
        <span class="cmd">this._title</span> m√ºssen hierf√ºr im Konstruktor definiert
        werden:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            /**
             * Konstruktor.
             */
            constructor() {
                this._title = "My Songbook";
                this._currentView = null;
            }
        </code>
    </pre>
    <p>
        Und damit das Ganze einfach zu verwenden ist, legen wir nun f√ºr jede Seite eine
        eigene, f√ºr die √∂ffentliche Verwendung freigebene Methode an, mit der sie √ºberall
        in der App aufgerufen werden kann. Die Methode <span class="cmd">start()</span>
        passen bei der Gelegenheit dann auch gleich noch an, damit beim Aufruf der App
        immer die √úberssichtsseite geladen wird:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            ‚Ä¶
            import SongDisplayEdit from "./song-display-edit/song-display-edit.js";
            import SongOverview from "./song-overview/song-overview.js";

            /**
             * ‚Ä¶
             */
            class App {
                ‚Ä¶

                /**
                 * Ab hier beginnt die Anwendung zu laufen.
                 */
                start() {
                    this.showSongOverview();
                }

                /**
                 * Aufruf der √úbersichtsseite der vorhandenen Songs.
                 * @return {Boolean} Flag, ob die neue Seite aufgerufen werden konnte
                 */
                showSongOverview() {
                    let view = new SongOverview(this);
                    this._switchVisibleView(view);
                }

                /**
                 * Aufruf der Detailseite zur Anzeige oder zum Bearbeiten eines Songs.
                 *
                 * @param  {String} id Song-ID
                 * @param  {String} mode "new", "display" oder "edit"
                 * @return {Boolean} Flag, ob die neue Seite aufgerufen werden konnte
                 */
                showSongDisplayEdit(id, mode) {
                    let view = new SongDisplayEdit(this, id, mode);
                    this._switchVisibleView(view);
                }

                /**
                 * ‚Ä¶
                 */
                _switchVisibleView(view) {
                    ‚Ä¶
                }
            }
        </code>
    </pre>

    <h3>Ausprogrammieren der onShow()-Methoden</h3>
    <p>
        Damit das Ganze nun auch wirklich funktioniert, m√ºssen wir noch die Methode
        <span class="cmd">onShow()</span> unserer beiden View-Klassen ausprogrammieren.
        Denn noch √ºbergeben wir dem <span class="cmd">App</span>-Objekt keine DOM-Elemente
        zum Anzeigen und wir registrieren auch noch keine Event Handler, mit denen der
        Anwender zwischen den Seiten umherschalten k√∂nnte.
    </p>
    <p>
        √ñffne daher noch einmal die Datei <span class="fn">src/song-overview/song-overview.js</span>
        und ersetze die <span class="cmd">onShow()</span>-Methode durch die nun folgende Version:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            onShow() {
                // Anzuzeigende HTML-Elemente ermitteln
                let section = document.querySelector("#song-overview").cloneNode(true);

                let content = {
                    className: "song-overview",
                    topbar: section.querySelectorAll("header &gt; *"),
                    main: section.querySelectorAll("main &gt; *"),
                };

                // Event Handler registrieren
                let newSongItem = section.querySelector("header .item.new-song");

                newSongItem.addEventListener("click", () =&gt; {
                    this._app.showSongDisplayEdit("", "new");
                })

                // Ergebnis zur√ºckliefern
                return content;
            }
        </code>
    </pre>
    <p>
        In der Datei <span class="fn">src/song-display-edit/song-display-edit.js</span> ersetze
        die <span class="cmd">onShow()</span>-Methode durch folgende Version:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            onShow() {
                // Anzuzeigende HTML-Elemente ermitteln
                let section = document.querySelector("#song-display-edit").cloneNode(true);

                let content = {
                    className: "song-display-edit",
                    topbar: section.querySelectorAll("header &gt; *"),
                    main: section.querySelectorAll("main &gt; *"),
                };

                // Event Handler registrieren
                let overviewItem = section.querySelector("header .item.overview");

                overviewItem.addEventListener("click", () =&gt; {
                    this._app.showSongOverview();
                })

                // Ergebnis zur√ºckliefern
                return content;
            }
        </code>
    </pre>
    <p>
        Beide Methoden sind prinzipiell gleich aufgebaut. Um sie zu verstehen m√ºssen wir allerdings
        erst einen Bogen zur√ºck zum Anfang des Kapitels machen. Dort haben wir n√§mlich den HTML-Code
        der Datei <span class="fn">src/index.html</span> etwas umger√§umt und zwei
        <span class="cmd">&lt;section&gt;</span>-Elemente f√ºr die beiden Unterseiten angelegt.
        Auf diese Elemente greifen wir nun zu, um die anzuzeigenden HTML-Elemente aus dem Document
        Object Model auszulesen. Allerdings erzeugen wir durch Aufruf der Methode
        <span class="fn">cloneNode(true)</span> eine tiefe Kopie der ausgelesenen Elemente, da der
        Kommentar vor der Methode <span class="fn">App._switchVisibleContent()</span> eindeutig
        besagt, dass ihr keine Elemente √ºbergeben werden d√ºrfen, die sich bereits im DOM-Baum der
        HTML-Seite befinden.
    </p>
    <p>
        Mit diesen Elementen bauen wir dann das <span class="fn">content</span>-Objekt auf, welches
        die Methode <span class="fn">App._switchVisibleContent()</span> von uns erwartet. Daraufhin
        suchen wir uns in der Topbar jeweils ein Element, mit dem der Anwender zwischen den Seiten
        umschalten kann und registrieren einen Click Event Handler darauf. In der entsprechenden
        Handler-Funktion rufen wir daher die jeweils richtige <span class="cmd">show‚Ä¶()</span>-Methode
        des <span class="fn">App</span>-Objekts auf, um die Seite tats√§chlich zu wechseln.
    </p>
    <p>
        Und am Ende geben wir die <span class="fn">content</span>-Struktur zur√ºck, damit die Methode
        <span class="fn">App._switchVisibleView()</span>, von der wir aufgerufen werden, sie an die
        Methode <span class="fn">App._switchVisibleContent()</span> √ºbergeben kann.
    </p>
    <p>
        Wenn du alles richtig gemacht hast, solltest du daher nun zwischen den beiden Seiten umherschalten
        k√∂nnen. Dabei sollte dann auch aufgrund der unterschiedlichen Stylesheets die Schriftfarbe von
        orange auf lila wechseln, wie in der folgenden Animation dargestellt.
    </p>
    <figure>
        <img src="02/navigation/seiten-wechseln.gif" class="border"/>
        <figcaption>All der M√ºhen Lohn: Eine funktionierende Navigation innerhalb der App</figcaption>
    </figure>
</section>

<!-- ‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì -->
<!-- Integration des Single Page Routers -->
<!-- ‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì -->
<section data-title="Integration des Single Page Routers">
    <p class="git-commit">
        Git Commit:
        <a href="https://github.com/DennisSchulmeister/dhbwka-wwi-webprog-my-songbook/tree/afd89090abf9e432dc6fd9d80b48a8205de387be" target="_blank">afd8909</a>
    </p>

    <p>
        Zugegeben, das war schon eine ganze Menge Code, der da eben zusammenpassen musste, bevor wir
        wirklich zwischen den beiden Seiten hin und her schalten konnten. Doch damit hast du nun eine
        vollst√§ndige Grundstruktur zur Verf√ºgung, die im Grunde genommen auf jede Art von Anwendung
        ausgerollt werden kann. Du musst nur die beiden Klassen f√ºr die Song√ºbersicht und die Details
        zu einem Song durch eigene Klassen ersetzen. Ein paar Nachteile hat die bisherige L√∂sung aber
        noch, weshalb wir sie an dieser Stelle noch etwas verfeinern wollen:
    </p>
    <ul>
        <li>
            Die Views unserer App besitzen keine eindeutigen URLs und k√∂nnen daher nur per JavaScript
            aufgerufen werden. Dadurch kann eine View (zum Beispiel f√ºr einen bestimmten Song) nicht
            durch Eingabe der richtigen Adresse im Browser direkt aufgerufen werden.
        </li>
        <li>
            Auch k√∂nnen wir keine einfachen <span class="cmd">&lt;a&gt;</span>-Elemente innerhalb des
            HTML-Codes verwenden, um einen Link auf eine andere View zu platzieren. Wir m√ºssen immer
            zus√§tzliche Event Handler schreiben und den Seitenwechsel mit JavaScript durchf√ºhren.
        </li>
        <li>
            Der Zur√ºck-Button des Browsers sowie ganz allgemein ein Aufruf √ºber den Browserverlauf
            wird nicht unterst√ºtzt.
        </li>
    </ul>
    <p>
        Die L√∂sung all dieser Probleme h√∂rt auf den Namen
        <a href="https://css-tricks.com/using-the-html5-history-api/" target="_blank">HTML5 History API</a>.
        Doch anstatt jetzt uns jetzt selbst damit herumzuschalgen (die Details richtig hinzubekommen ist
        tats√§chlich nicht ganz einfach), wollen wir auf eine Library zur√ºckgreifen, die das alles viel
        besser kann. Wir wollen einen ‚ÄûSingle Page Router‚Äù verwenden, der es uns ganz einfach erm√∂glicht,
        eine URL-Struktur f√ºr unsere App zu definieren und dabei festzulegen, was beim Aufruf welcher URL
        passieren soll. Den Grundstock daf√ºr haben wir bereits im letzten Teilkapitel gelegt. Jetzt geht
        es nur noch darum, die ganze Sache ein wenig zu optimieren.
    </p>

    <h3>Installation von Navigo</h3>
    <p>
        Die Library, die wir hier verwenden wollen, hei√üt <a href="https://github.com/krasimir/navigo" target="_blank">navigo</a>.
        Sie implementiert einen einfachen Single Page Router, der im Gegensatz zu vielen √§hnlichen
        Bibliotheken ganz ohne fremde Abh√§ngigkeiten auskommt und daher in nahezu jede beliebige
        Webanwendung integriert werden kann. Und wie das
        <a href="https://github.com/krasimir/navigo/blob/master/README.md" target="_blank">README auf GitHub</a>
        andeutet, scheint sie relativ einfach nutzbar zu sein. Grund genug also mal wieder das gute alte
        Terminal anzuschmei√üen, mit <span class="cmd">cd</span> in unser Projektverzeichnis zu wechseln
        die Library mit folgendem Befehl zu installieren:
    </p>
    <p class="cmd">
        npm add --save-dev navigo
    </p>
    <p>
        Die installation sollte dabei in gewohnter node.js-Manier schnell und ger√§uschlos √ºber die B√ºhne gehen.
    </p>
    <figure>
        <img src="02/spa-router/installation-navigo.jpg" />
        <figcaption>Installation des <span class="scr">navigo</span> Single Page Routers</figcaption>
    </figure>

    <h3>Anpassungen an der App-Klasse</h3>
    <p>
        Um den Single Page Router zu initialisieren m√ºssen wir ein paar kleinere Umbauten der
        <span class="cmd">App</span>-Klasse vornehmen. Allerdings nichts allzu dramatisches.
        Zun√§chst m√ºssen wir die Klasse <span class="fn">Navigo</span> aus dem Modul
        <span class="fn">navigo/lib/navigo.js</span> importieren, was wir dank Parcel einfach
        tun k√∂nnen, ohne hierf√ºr auch nur eine Datei umkopieren zu m√ºssen:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            ‚Ä¶
            import Navigo from "navigo/lib/navigo.js";
            import SongDisplayEdit from "./song-display-edit/song-display-edit.js";
            import SongOverview from "./song-overview/song-overview.js";
            ‚Ä¶

            class App { ‚Ä¶ }
        </code>
    </pre>
    <p>
        Danach k√∂nnen wir den Konstruktor von <span class="cmd">App</span> wie folgt erweitern:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            constructor() {
                this._title = "My Songbook";
                this._currentView = null;

                // Single Page Router aufsetzen
                this._router = new Navigo();
                this._currentUrl = "";
                this._navAborted = false;

                this._router.on({
                    "*":                       () =&gt; this.showSongOverview(),
                    "/song/new/":              () =&gt; this.showSongDisplayEdit("", "new"),
                    "/song/display/:id/":  params =&gt; this.showSongDisplayEdit(params.id, "display"),
                    "/song/edit/:id":      params =&gt; this.showSongDisplayEdit(params.id, "edit"),
                });

                this._router.hooks({
                    after: (params) =&gt; {
                        if (!this._navAborted) {
                            // Navigation durchf√ºhren, daher die neue URL merken
                            this._currentUrl = this._router.lastRouteResolved().url;
                        } else {
                            // Navigation abbrechen, daher die URL in der Adresszeile
                            // auf den alten Wert der bisherigen View zur√ºcksetzen
                            this._router.pause(true);
                            this._router.navigate(this._currentUrl);
                            this._router.pause(false);

                            this._navAborted = false;
                        }
                    }
                });
            }
        </code>
    </pre>
    <p>
        Das sieht jetzt erst einmal sehr komplex aus. Wichtig aber nur der Aufruf von
        <span class="cmd">this._router.on({‚Ä¶})</span> als Herzst√ºck dieser Anpassung.
        Alle anderen Zeilen, bis auf die Erzeugung des Router-Objekts selbst k√∂nnte man
        auch weglassen. Sie werden nur ben√∂tigt, weil wir die Navigation in bestimmten
        F√§llen unterbrechen wollen und den Navigo hierf√ºr ein wenig zum Mitspielen
        √ºberreden m√ºssen.
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            this._router.on({
                "*":                       () =&gt; this.showSongOverview(),
                "/song/new/":              () =&gt; this.showSongDisplayEdit("", "new"),
                "/song/display/:id/":  params =&gt; this.showSongDisplayEdit(params.id, "display"),
                "/song/edit/:id":      params =&gt; this.showSongDisplayEdit(params.id, "edit"),
            });
        </code>
    </pre>
    <p>
        Hier wird die URL-Struktur der Seite definiert, wobei jedes URL-Pattern mit einer
        anonymen Lambda-Funktion (zu erkennen an <span class="cmd">() => &gt; ‚Ä¶</span>)
        verkn√ºpft ist. Es liegt nahe, dass der Router die entsprechende Lambda-Funktionen
        aufruft, wenn eine URL erkannt wurde, um dadurch den sichtbaren Inhalt zu wechseln.
        Praktischerweise k√∂nnen wir hier unsere Methoden von vorhin direkt weiterverwenden.
    </p>
    <p>
        In der <span class="cmd">start()</span>-Methode m√ºssen wir nun nicht mehr explizit
        die √úbersichtsseite aufrufen. Stattdessen sagen wir dem Router hier, dass er die
        URL, mit der die gesamte App gestartet wurde, auswerten und die anzuzeigende View
        automatisch erkennen soll:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            start() {
                this._router.resolve();
            }
        </code>
    </pre>
    <p>
        Das sind eigentlich schon alle √Ñnderungen an der Klasse <span class="cmd">App</span>.
        Damit aber das Unterbrechen der Navigation richtig funktioniert, m√ºssen wir die
        Methode <span class="cmd">_switchVisibleView()</span> noch ein klein wenig modifizieren.
        Die neue Version lautet wie folgt:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            _switchVisibleView(view) {
                // Callback, mit dem die noch sichtbare View den Seitenwechsel zu einem
                // sp√§teren Zeitpunkt fortf√ºhren kann, wenn sie in der Methode onLeave()
                // false zur√ºckliefert. Dadurch erh√§lt sie die M√∂glichkeit, den Anwender
                // zum Beispiel zu fragen, ob er ungesicherte Daten speichern will,
                // bevor er die Seite verl√§sst.
                let newUrl = this._router.lastRouteResolved().url;
                let goon = () =&gt; {
                    // ?goon an die URL h√§ngen, weil der Router sonst nicht weiternavigiert
                    this._router.navigate(newUrl + "?goon");
                }

                // Aktuelle View fragen, ob eine neue View aufgerufen werden darf
                if (this._currentView && !this._currentView.onLeave(goon)) {
                    this._navAborted = true;
                    return false;
                }

                // Alles klar, aktuelle View nun wechseln
                document.title = `${this._title} ‚Äì ${view.title}`;

                this._currentView = view;
        </code>
    </pre>
    <p>
        Im Vergleich zur alten Version setzen wir hier noch ein Kennzeichen, wenn die
        Navigation durch die aktuell sichtbare View unterbunden wird, damit wir im weiter
        oben definieren ‚ÄûAfter Hook‚Äù von Navigo die Adresszeile des Browsers wieder auf
        die alte URL setzen k√∂nne. Au√üerdem m√ºssen wir hier die URL der n√§chsten Seite
        innerhalb des <span class="cmd">goon</span>-Callbacks etwas anders ermitteln.
    </p>

    <h3>Vereinfachung der restlichen Quellcodes</h3>
    <p>
        Undank sei der Welten Lohn, sagt man. Nicht jedoch an dieser Stelle. Zwar ist
        die Klasse durch die neuerlichen √Ñnderungen nochmal ein klein wenig komplizierter
        geworden, daf√ºr vereinfachen sich aber alle anderen Quellcodes. Und wir haben eine
        ordentliche URL-Struktur, mit der wir jede View der App √ºber eine eigene URL direkt
        aufrufen oder als Lesezeichen im Browser speichern k√∂nnen. Und der Zur√ºck-Button
        des Browsers tut nun auch das, was er soll.
    </p>
    <p>
        Zun√§chst einmal wollen wir die <span class="cmd">onShow()</span>-Methoden der beiden
        View-Klassen etwas aufr√§umen. Hier fallen die Event Handler komplett weg, so dass die
        Methoden nun nur noch so aussehen:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            // src/song-overview/song-overview.js:
            onShow() {
                let section = document.querySelector("#song-overview").cloneNode(true);

                return content = {
                    className: "song-overview",
                    topbar: section.querySelectorAll("header > *"),
                    main: section.querySelectorAll("main > *"),
                };
            }
        </code>
    </pre>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            // src/song-display-edit/song-display-edit.js:
            onShow() {
                let section = document.querySelector("#song-display-edit").cloneNode(true);

                return {
                    className: "song-display-edit",
                    topbar: section.querySelectorAll("header > *"),
                    main: section.querySelectorAll("main > *"),
                };
            }
        </code>
    </pre>
    <p>
        Wir konnten tats√§chlich die H√§lfte des Quellcodes einfach wegschmei√üen. Und da wir zum
        Umschalten zwischen den Views nun kein explizites JavaScript mehr ben√∂tigen, k√∂nnen wir
        die <span class="fn">src/index.html</span> nun so anpassen, dass hierf√ºr einfache Links
        verwendet werden. Die Definitionen innerhalb der Topbar √§ndern sich dadurch wie folgt:
    </p>
    <pre data-gobble>
        <code class="html" data-gobble>
            &lt;div class="item"&gt;
                &lt;a href="/song/new/" data-navigo&gt;
                    Song hinzuf√ºgen
                &lt;/a&gt;
            &lt;/div&gt;

            ‚Ä¶

            &lt;div class="item"&gt;
                &lt;a href="/" data-navigo&gt;
                    Zur√ºck zur √úbersicht
                &lt;/a&gt;
            &lt;/div&gt;
        </code>
    </pre>
    <p>
        Wenn es gut l√§uft, sollte das Ergebnis nun wie folgt aussehen. Beachte dabei, wie sic
        die URL in der Adresszeile des Browsers beim Wechseln der Seite ebenfalls √§ndert:
    </p>
    <figure>
        <img src="02/spa-router/seiten-wechseln.gif" class="border"/>
        <figcaption>Navigation innerhalb der App mit Hilfe des Single Page Routers</figcaption>
    </figure>

    <h3>Hinweis zum Parcel-Entwicklungsserver</h3>
    <p>
        Leider vertr√§gt sich das Prinzip eines Single Page Routers nicht immer 100%ig mit dem
        Hot Module Replacement (automatisches Nachladen der Seite bei einer Quellcode√§nderung)
        des Parcel-Entwicklungsservers. Deshalb kann es nach einer √Ñnderung am Quellcode passieren,
        dass die Seite zwar neul√§dt, in der Adresszeile des Browsers aber noch eine alte URL steht.
        In diesem Fall entferne am Besten alle Bestandteile nach der Port-Nummer der URL und lade
        die Seite erneut. Dadurch kannst du Navigo und Parcel wieder in Einklang bringen. In der
        Produktivversion der App kann das nicht passieren, da es hier das automatische Neuladen
        der Seite ja nicht gibt.
    </p>
</section>

<!-- ‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì -->
<!-- Die √úbersichtsseite entsteht -->
<!-- ‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì -->
<section data-title="Die √úbersichtsseite entsteht">
    <p class="git-commit">
        Git Commit:
        <a href="https://github.com/DennisSchulmeister/dhbwka-wwi-webprog-my-songbook/tree/XXX" target="_blank">XXX</a>
    </p>

    <!--
    Ausprogrammieren der √úbersichtsseite mit Dummy-Daten im HTML
    -->
</section>

<!-- ‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì -->
<!-- Lokale Datenhaltung im Browser -->
<!-- ‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì -->
<section data-title="Lokale Datenhaltung im Browser">
    <p class="git-commit">
        Git Commit:
        <a href="https://github.com/DennisSchulmeister/dhbwka-wwi-webprog-my-songbook/tree/XXX" target="_blank">XXX</a>
    </p>

    <!--
    Installation von PouchDB
    Grundlagen der Nutzung (aus API-Dokumentation)
    Definition einer Datenbank-Fassaden-Klasse
    Vorl√§ufige Dummy-Daten erzeugen, wenn die DB leer ist
    Anpassung der √úbersichtsseite (direkte DOM-Manipulation)
    -->
</section>

<!-- ‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì -->
<!-- Songtexte anzeigen -->
<!-- ‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì -->
<section data-title="Songtexte anzeigen">
    <p class="git-commit">
        Git Commit:
        <a href="https://github.com/DennisSchulmeister/dhbwka-wwi-webprog-my-songbook/tree/XXX" target="_blank">XXX</a>
    </p>

    <!--
    Ausprogrammieren der Detailseite zu einem Songtext
    Bis hierhin nur im Anzeigemodus
    Buttons zum L√∂schen und Bearbeiten bereits vorsehen
    Bei Klick auf "L√∂schen" direkt l√∂schen und zur√ºck zur √úbersicht
    Navigation zur√ºck zur √úbersicht (wenn nicht bereits gekl√§rt)
    -->
</section>

<!-- ‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì -->
<!-- Modales Popup vor dem L√∂schen -->
<!-- ‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì -->
<section data-title="Modales Popup vor dem L√∂schen">
    <p class="git-commit">
        Git Commit:
        <a href="https://github.com/DennisSchulmeister/dhbwka-wwi-webprog-my-songbook/tree/XXX" target="_blank">XXX</a>
    </p>

    <!--
    CSS/JS-Code f√ºr einen modalen Dialog
    Eigene Komponente <popup-ask-delete>
    Aufruf des Dialogs an der richtigen Stelle
    -->
</section>

<!-- ‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì -->
<!-- Ein Editor f√ºr alle F√§lle -->
<!-- ‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì -->
<section data-title="Ein Editor f√ºr alle F√§lle">
    <p class="git-commit">
        Git Commit:
        <a href="https://github.com/DennisSchulmeister/dhbwka-wwi-webprog-my-songbook/tree/XXX" target="_blank">XXX</a>
    </p>

    <!--
    Wechsel in den √Ñnderungsmodus der Detailseite
    contenteditable-Attribut f√ºr Titel und Interpret
    Event Handler um ENTER abzufangen (keine neue Zeile bzw. <div> bei ENTER, daf√ºr ins n√§chste Feld springen, event.preventDefaul())
    <textarea> zum Bearbeiten des HTML-Codes des Textes
    Installation von Qilk
    WYSIWIG-Bearbeiten des Textes mit Quilk
    √Ñnderungen sichern bei Okay, Seite neuladen bei Abbrechen
    -->
</section>

<!-- ‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì -->
<!-- Onlinesuche und Anlage eines Songs -->
<!-- ‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì -->
<section data-title="Onlinesuche und Anlage eines Songs">
    <p class="git-commit">
        Git Commit:
        <a href="https://github.com/DennisSchulmeister/dhbwka-wwi-webprog-my-songbook/tree/XXX" target="_blank">XXX</a>
    </p>

    <!--
    Neue <popup-create-song>-Komponente ausprogrammieren (viel Copy & Paste)
    Installation von lyric-get
    Abruf eines Songs mit lyric-get
    Bessere Alternative: Fetch API mit await
    Abruf des Songs mit der Fetch API, Auswerten des JSON-Strings
    Aufruf der Detailseite im Neuanlagemodus
    Hierf√ºr notwendige Anpassungen an der Detailseite
    -->
</section>
