<!-- ============== -->
<!-- VORBEREITUNGEN -->
<!-- ============== -->
<section data-chapter data-title="Vorbereitungen"></section>

<!-- ‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì -->
<!-- Einleitung -->
<!-- ‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì -->
<section data-title="Einleitung">
    <h3>Herzlich Willkommen!</h3>
    <p>
        Puh, das w√§re geschafft. Das dritte Semester ist nun halb vorbei und du hast hoffentlich
        alle Selbstlerneinheiten erfolgreich hinter dir gelassen. Es war auch eine ganze Menge
        Zeugs, das du dir da angeeignet hast. Das ein oder andere haben wir schon in kleineren
        √úbungen vertieft und praktisch angewendet. Jetzt wird es aber Zeit, die ganzen Puzzleteile
        zu einem Gesamtwerk zusammenzusetzen. Es wird Zeit, dass wir endlich einmal eine komplette
        Webanwendung programmieren, mit allem was dazu geh√∂rt. Diese Anleitung soll dir dabei helfen.
        Zwar werden wir die wesentlichen Teile daraus auch in der Vorlesung besprechen, hier kannst
        du aber nochmal jeden Schritt nachvollziehen und dir dabei auch die Dinge anschauen, die wir
        in der Vorlesung nicht so ausf√ºhrlich erkl√§ren oder aus Zeitgr√ºnden √ºberspringen m√ºssen.
    </p>
    <p>
        Falls du √ºber Google auf diese Seite gelangt bist und dich nun fragst, was mit alle dem
        hier gemeint ist, mach dir keine weiteren Gedanken dar√ºber. Diese Anleitung ist Bestandteil
        der Vorlesung ‚ÄûWebprogrammierung‚Äù im Bachelor-Studiengang ‚ÄûWirtschaftsinformatik‚Äù an der
        <a href="https://karlsruhe.dhbw.de" target="_blank">DHBW Karlsruhe</a>. Dort lernen wir
        erst gemeinsam die grundlegenden Konzepte der Webentwicklung wie HTML, CSS und JavaScript
        und gehen dann in einen praktischen Teil zur Entwicklung einer Browser App √ºber. Ganz
        ohne Vorwissen wird dir diese Anleitung daher nicht viel nutzen. S√§mtliche Selbstlerneinheiten
        aus der Vorlesung sind jedoch auf <a href="https://www.wpvs.de" target="_blank">wpvs.de</a> verf√ºgbar.
    </p>

    <h3>Was wir programmieren werden</h3>
    <p>
        Die Anwendung, die wir gemeinsam entwickeln, nennt sich ‚ÄûMy Songbook‚Äù und ist eine
        browserseitige Single Page App. Sie hat also keinen Serveranteil, da sich die gesamte
        Anwendungslogik innerhalb des Browsers abspielt. Lediglich einen Webserver, der die
        Anwendung √ºber das Web aufrufbar macht, werden wir dabei verwenden. Der Server wird
        jedoch nur den statischen Quellcode der Anwendung zur Verf√ºfung stellen und selbst
        keinerlei Intelligenz besitzen.
    </p>
    <p>
        ‚ÄûMy Songbook‚Äù soll eine einfache, musikerfreundliche App werden, die es erm√∂glicht,
        Songtexte im Internet zu suchen und diese in sein pers√∂nliches Songbuch aufzunehmen.
        Hierf√ºr soll es eine √úbersichtsseite mit allen bereites enthaltenen Songtexten geben,
        wobei die Liste entweder nach Songtitel oder nach Interpret sortiert werden kann.
        Auch soll es m√∂glich sein, die Liste zu durchsuchen. Dar√ºber hinaus k√∂nnen die
        vorhandenen Songtexte angezeigt, bearbeitet und gel√∂scht werden. Die nachfolgenden
        Skizzen zeigen, wie die Anwendung ungef√§hr aussehen soll. Wie du siehst, wollen wir
        die Anwendung nach dem ‚ÄûMobile First‚Äù-Ansatz responsive gestalten, so dass sie auch
        auf Smartphones und Tablets genutzt werden kann:
    </p>
    <figure style="max-width: 15em;">
        <img src="01/einleitung/mobile.png" />
        <figcaption>Mobile Darstellung</figcaption>
    </figure>
    <p>
        Beim Start der Anwendung soll eine √úbersicht mit allen Songtexten erscheinen.
        Der Anwender kann hier entscheiden, ob die Liste nach Titel oder nach Interpret
        sortiert sein soll und innerhalb der Liste suchen. Ebenso kann er von hier aus
        einen neuen Song anlegen oder einen vorhandenen Song aufrufen:
    </p>
    <figure>
        <img src="01/einleitung/uebersicht.png" />
        <figcaption>√úbersicht der vorhandenen Songtexte</figcaption>
    </figure>
    <p>
        Zu jedem Songtext gibt es eine Detailseite zur Anzeige des Textes. Sie soll ungef√§hr
        wie folgt aussehen. Von hier aus kann der Text auch bearbeitet oder gel√∂scht werden:
    </p>
    <figure>
        <img src="01/einleitung/anzeige.png" />
        <figcaption>Anzeige eines Songtexts</figcaption>
    </figure>
    <p>
        Klickt der Anwender auf ‚ÄûBearbeiten‚Äù soll sich die Seite wie folgt ver√§ndern:
        Titel und Interpret werden zu eingabebereiten Feldern und der Text kann innerhalb
        eines WYSIWYG-Editors ver√§ndert werden. √úber zwei Buttons kann der Anwender dann
        entscheiden, ob er die √Ñnderungen sichern oder wieder verwerfen will:
    </p>
    <figure>
        <img src="01/einleitung/bearbeiten.png" />
        <figcaption>Bearbeiten eines Songtexts</figcaption>
    </figure>
    <p>
        Bevor ein Text gel√∂scht wird, soll ein Popup mit einer Sicherheitsabfrage erscheinen:
    </p>
    <figure>
        <img src="01/einleitung/loeschen.png" />
        <figcaption>L√∂schen eines Songtexts</figcaption>
    </figure>
    <p>
        Will der Anwender einen neuen Songtext hinzuf√ºgen, soll ein Popup mit zwei
        Suchfeldern f√ºr Songtitel und Interpret hochkommen. Sobald der Anwender den Popup
        best√§tigt, wirrd die Suche durchgef√ºhrt und der Text wird angelegt. M√∂glicherweise
        bleibt der Text dabei leer, wenn er nicht online gefunden wurde. In diesem Fall
        soll der Anwender ihn von Hand eingeben k√∂nnen:
    </p>
    <figure>
        <img src="01/einleitung/anlegen.png" />
        <figcaption>Anlegen eines Songtexts</figcaption>
    </figure>
</section>

<!-- ‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì -->
<!-- Werkzeuge und Bibliotheken -->
<!-- ‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì -->
<section data-title="Werkzeuge und Bibliotheken">
    <p>
        So simpel die zu erstellende Anwendung ist, so kompliziert ist sie auch. Denn manche scheinbar
        triviale Dinge sind am Ende doch aufw√§ndiger als man zun√§chst denkt. Wann immer das passiert,
        werden wir nicht lange versuchen, das Rad neuzuerfinden. Denn Open Source und Free Software
        zum Dank m√ºssen wir das auch gar nicht. Im Internet hat sich eine ausgepr√§gte Sharing-Kultur herausgebildet,
        so dass es f√ºr viele Probleme bereits fertige Werkzeuge und Bibliotheken gibt, die wir nur zu nutzen
        brauchen. W√§re doch schade, wenn wir das nicht nutzen w√ºrden. Wir m√ºssen dabei auch gar kein
        schlechtes Gewissen haben, da heutzutage kaum ein echtes Projekt ohne diese Art der Hilfestellung auskommt.
        Im Gegenteil: Es gibt sogar eigene Werkzeuge, die die Nutzung fremder Werkzeuge und Bibliohekten so
        einfach machen, dass ihre Nutzung inzwischen zum guten Ton geh√∂rt.
    </p>

    <h3>Entwicklungswerkzeuge</h3>
    <ul>
        <li>
            <b><a href="https://atom.io/" target="_blank">Atom:</a></b> Spezieller Texteditor f√ºr Webentwickler und Programmierer
        </li>
        <li>
            <b><a href="https://git-scm.com/" target="_blank">git:</a></b> Versionsverwaltung zur gemeinsamen Arbeit am Quellcode
        </li>
        <li>
            <b><a href="https://nodejs.org/" target="_blank">npm:</a></b> Paketverwaltung zum automatischen Download abh√§ngiger Bibliotheken
        </li>
        <li>
            <b><a href="https://parceljs.org/" target="_blank">Parcel:</a></b> Web Application Bundler und Entwicklungsserver
        </li>
    </ul>
    <p>
        Parcel installieren wir ihm Rahmen dieser Anleitung als lokale Abh√§ngigkeit f√ºr unser Projekt.
        In der <a href="https://www.wpvs.de/software/" target="_blank">Anleitung zur Installation der Software</a>
        ist es daher nicht aufgef√ºhrt und du musst hier noch nichts unternehmen.
    </p>

    <h3>Bibliotheken</h3>
    <ul>
        <li>
            <b><a href="https://github.com/krasimir/navigo" target="_blank">Navigo:</a></b> Single Page Router zur Vereinfachung der Navigation innerhalb der App
        </li>
        <li>
            <b><a href="https://pouchdb.com/" target="_blank">PouchDB:</a></b> Clientseitige NoSQL-Datenbank zum Speichern der Songtexte
        </li>
        <li>
            <b><a href="https://github.com/rhnvrm/lyric-api" target="_blank">lyric-get:</a></b> Kleine Bibliothek zur Suche von Songtexten im Internet
        </li>
        <li>
            <b><a href="https://quilljs.com/" target="_blank">Quill:</a></b> WYSIWYG-Editor zum Nachbearbeiten der Songtexte
        </li>
    </ul>

    <p>
        Wenn du willst, kannst du dich auf den einzelnen Webseiten ein wenig umschauen und dir ein Bild davon
        verschaffen, was die Werkzeuge leisten und wie die Bibliotheken genutzt werden. Doch keine Angst, wenn
        das jetzt alles sehr kompliziert aussieht. Wir werden hier alles Schritt f√ºr Schritt durchgehen und
        alle wichtigsten Dinge erkl√§ren.
    </p>
    <p>
        Eventuell ist dir aber aufgefallen, dass wir kein bekanntes Framework wie
        <a href="https://angularjs.org/" target="_blank">Angular</a> oder
        <a href="https://reactjs.org/" target="_blank">React</a> nutzen.

        Der Grund hierf√ºr ist, dass das f√ºr unsere kleine Anwendung gar nicht erforderlich ist. Diese
        Frameworks sind viel zu gro√ü, als dass sich ihr Einsatz hier lohnen w√ºrde. Viel problematischer
        ist jedoch, dass sie jeweils eine ganz eigene Art der Entwicklung vorschreiben, die zwar zum
        jeweiligen Framework passt, aber nur schwer verallgemeinert werden kann. Auch nehmen Sie uns
        viele Aufgaben ab, auf die wir in dieser Anleitung bewusst eingehen wollen, um dir ihre
        Bedeutung vor Augen zu f√ºhren. F√ºr unser Projekt haben wir uns deshalb entschieden, nur kleine
        Bibliotheken zu nutzen, die genau ein Problem l√∂sen, sonst aber alles selbst zu programmieren.
        Auch das ist ein durchaus praxisrelevanter Weg, weil wir dadurch eine sehr schlanke, genau auf
        unsere Bed√ºrfnisse zugeschnittene Codebasis mit geringer Codekomplexit√§t erhalten.
    </p>
</section>

<!-- ‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì -->
<!-- Bevor es losgehen kann -->
<!-- ‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì -->
<section data-title="Bevor es losgehen kann">
    <h3>Folgende Dinge solltest du bereits erledigt haben</h3>
    <p>
        Wenn du an dieser Stelle angekommen bist, gehen wir davon aus, dass du folgende Dinge bereits
        erledigt hast. Wenn nicht, hole sie jetzt schnell nach, damit wir loslegen k√∂nnen.
    </p>
    <ol>
        <li>
            Du hast alle <a href="https://www.wpvs.de/" target="_blank">Folienskripte</a> durchgearbeitet.
        </li>
        <li>
            Du hast die <a href="https://www.wpvs.de/software/" target="_blank">Anleitung zur Installation der Software</a> durchgearbeitet.
        </li>
        <li>
            Du hast dich mit <a href="https://www.wpvs.de/atom-git/" target="_blank">git, GitHub und Atom</a> vertraut gemacht.
        </li>
    </ol>

    <h3>Wie diese Anleitung zu bearbeiten ist</h3>
    <p>
        Diese Anleitung f√ºhrt dich Schritt f√ºr Schritt durch das Programmierprojekt.
        Du solltest sie deshalb nutzen, um die in der Vorlesung besprochenen Inhalte
        zu wiederholen und zu vertiefen. Es handelt sich allerdings nur bedingt um eine
        gute Bettlekt√ºre. Stattdessen gehen wir davon aus, dass du alle Schritte
        genau wie beschrieben auf deinem eigenen Rechner nachvollziehst. Mitmachen ist
        strengstens erw√ºnscht. üòé
    </p>
    <p>
        Solltest du an einer Stelle nicht weiter kommen oder noch eine Frage haben,
        nutze das Forum in Moodle, um Hilfe zu erhalten. Wir antworten auf jede Frage!
        Au√üerhalb des Semesters kannst du nat√ºrlich auch einfach eine E-Mail schreiben.
        Die Adresse findest du ganz unten am Ende der Seite. Alternativ kann auhc ein
        Blick in den fertigen Quellcode weiterhelfen. Du findest die komplett fertig
        gebaute App an folgender Stelle:
    </p>
    <ul>
        <li>
            <a href="https://github.com/DennisSchulmeister/dhbwka-wwi-webprog-my-songbook" target="_blank">Quellcode auf GitHub</a>
        </li>
        <li>
            <a href="https://www.wpvs.de/my-songbook/" target="_blank">Start der Anwendung</a>
        </li>
    </ul>

    <h3>Alles klar? Dann los!</h3>
    <figure>
        <img src="01/voraussetzungen/space-1951858_1280.png" />
        <figcaption>
            Alles klar zum Abheben! <br />
            Bildnachweis: <a href="https://pixabay.com/de/raum-rakete-reisen-wissenschaft-1951858/" target="_blank">Pixabay: onuromeryavuz</a>
        </figcaption>
    </figure>
</section>

<!-- ‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì -->
<!-- Ein neues Projekt wird geboren -->
<!-- ‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì -->
<section data-title="Eine neues Projekt wird geboren">
    <h3>Hinweis zur Teamarbeit</h3>
    <p>
        Wenn du mit mehreren Personen an dem Projekt arbeiten willst, muss nur einer
        von euch die nachfolgenden Schritte ausf√ºhren. Dabei solltet ihr aber
        jeden Fall wie beschrieben ein git-Repository anlegen, damit ihr den Quellcode
        untereinander teilen k√∂nnt.
    </p>

    <h3>Anlage des Projektverzeichnisses</h3>
    <p>
        In dieser Anleitung fangen wir wirklich ganz von vorne an. Als erstes musst du daher erst ein
        neues Verzeichnis anlegen, in dem wir die Webanwendung entwickeln werden. Am Besten legst du
        dir hierf√ºr ein allgemeines Verzeichnis f√ºr all deine Programmierprojekte an, wenn du noch
        keins hast, und erstellst darin ein Unterverzeichnis namens ‚ÄûMy-Songbook‚Äù.¬π Dieses Unterverzeichnis
        wird sp√§ter alle Dateien beinhalten, die w√§hrend der Entwicklung der App entstehen.
    </p>
    <figure>
        <img src="01/projektstruktur/verzeichnis-leer.png" />
        <figcaption>Es beginnt alles mit einem leeren Projektverzeichnis</figcaption>
    </figure>
    <p>
        ¬π
        <small>
            Achte darauf, dass das Projektverzeichnis kein Leerzeichen im Namen hat. Zwar darf
            das Verzeichnis, in dem es liegt, Leerzeichen beinhalten, das Projektverzeichnis
            selbst jedoch nicht. Andernfalls l√§sst sicher weiter unten node.js nicht richtig
            initialisieren.
        </small>
    </p>
    <p>
        Damit fremde Entwickler, die auf den Quellcode sto√üen, wissen um was f√ºr eine Anwendung es sich
        handelt und was sie mit dem Quellcode tun d√ºrfen, ist es √ºblich, dass das Projektverzeichnis
        zwei Textdateien mit den Namen <span class="fn">README</span> und <span class="fn">LICENSE</span>
        beinhaltet. Sie enthalten eine allgemeine Beschreibung der Anwendung, wichtige Hinweise sowie die
        Lizenz, unter welcher die Anwendung ver√∂ffentlicht wird. Diese beiden Dateien sind so wichtig,
        dass Code-Plattformen wie GitHub ihren Inhalt auf der Projektseite direkt anzeigen.
    </p>
    <p>
        Bei einer echten Anwendung, kann man bei der Auswahl der Lizenz und beim Schreiben der
        <span class="fn">README</span>-Datei gar nicht gewissenhaft genug sein. An dieser Stelle
        gen√ºgt es aber, wenn du dir von
        <a href="https://github.com/DennisSchulmeister/dhbwka-wwi-webprog-my-songbook" target="_blank">GitHub</a>
        folgende Dateien herunterl√§dst und im Projektverzeichnis ablegst. Klicke hierf√ºr einfach
        auf die Dateinamen in der Aufz√§hlung.
    </p>
    <ul>
        <li>
            <a href="https://github.com/DennisSchulmeister/dhbwka-wwi-webprog-my-songbook/raw/master/LICENSE" target="_blank"><tt>LICENSE</tt></a>:
            Lizenzbeschreibung unserer Anwendung, hier CC-BY-4.0.
        </li>
        <li>
            <a href="https://github.com/DennisSchulmeister/dhbwka-wwi-webprog-my-songbook/raw/master/README.md" target="_blank"><tt>README.md</tt></a>:
            Textdatei im
            <a href="http://markdown.de/" target="_blank">Markdown-Format</a> mit wichtigen Hinweisen
        </li>
        <li>
            <a href="https://github.com/DennisSchulmeister/dhbwka-wwi-webprog-my-songbook/raw/master/mockup1.png" target="_blank"><tt>mockup1.png</tt></a>:
            Skizze der Anwendung f√ºr die <span class="fn">README</span>-Datei
        </li>
        <li>
            <a href="https://github.com/DennisSchulmeister/dhbwka-wwi-webprog-my-songbook/raw/master/mockup2.png" target="_blank"><tt>mockup2.png</tt></a>:
            Skizze der Anwendung f√ºr die <span class="fn">README</span>-Datei
        </li>
        <li>
            <a href="https://github.com/DennisSchulmeister/dhbwka-wwi-webprog-my-songbook/raw/master/mockup3.png" target="_blank"><tt>mockup3.png</tt></a>:
            Skizze der Anwendung f√ºr die <span class="fn">README</span>-Datei
        </li>
    </ul>
    <p>
        Dein Projektverzeichnis sollte hinterher so aussehen:
    </p>
    <figure>
        <img src="01/projektstruktur/license-und-readme.png" />
        <figcaption>
            Projektverzeichnis mit <span class="fn">README</span> und <span class="fn">LICENSE</span>-Datei
        </figcaption>
    </figure>

    <h3>Initialisierung des git-Repositories</h3>
    <p>
        Kaum ein Programmierprojekt kommt heute noch ohne eine gute Versionsverwaltung aus, wobei
        <a href="https://git-scm.com/" target="_blank">git</a> hier der absolute Spitzenreiter ist.
        Allein schon die M√∂glichkeit, sp√§ter noch ganz genau nachvollziehen zu k√∂nnen, was wann
        warum und wie ge√§ndert wurde, spricht daf√ºr, deinen Quellcode mit git zu verwalten, selbst
        wenn du nur ganz alleine daran arbeiten willst. F√ºr die Vorlesung haben wir darum extra
        eine eigene <a href="https://www.wpvs.de/atom-git/" target="_blank">Anleitung f√ºr den
        Umgang mit git, GitHub und Atom</a> zur Verf√ºgung gestellt.
    </p>
    <p>
        Auch an dieser Stelle wollen wir auf unser eigenes git-Repository nicht verzichten.
        Im Gegensatz zur Anleitung wollen wir die notwendigen Schritte jedoch auf der Konsole
        ausf√ºhren. Als n√§chstes musst du deshalb ein Konsolenfenster √∂ffnen und darin mit
        <span class="cmd">cd Verzeichnisname</span> in das Projektverzeichnis wechseln.
        Falls der Verzeichnispfad Leerzeichen enth√§lt, musst du ihn in Anf√ºhrungszeichen setzen.
        Ob es geklappt hat, siehst du in der Regel am Verzeichnisnamen, der als Teil des
        Befehlsprompt angezeigt wird. Au√üer unter macOS, wo du das aktuelle Verzeichnis mit
        <span class="cmd">pwd</span> √ºberpr√ºfen kannst. Anschlie√üend f√ºhre folgende Befehle aus:
    </p>
    <ol>
        <li>
            <span class="cmd">git init</span>
        </li>
        <li>
            <span class="cmd">git add . </span> (beachte den Punkt am Ende des Befehls)
        </li>
        <li>
            <span class="cmd">git commit</span>
        </li>
    </ol>
    <p>
        Dadurch sollte sich ein Texteditor √∂ffnen und dich zur Eingabe einer Commit-Nachricht auffordern.
        Hier kannst du dann einfach ‚ÄûInitialer Commit‚Äù oder ‚ÄûProjekt angelegt‚Äù reinschreiben und den Editor
        wieder schlie√üen. Wie du das anstellst, siehst du anhand der folgenden Screenshots:
    </p>
    <figure>
        <img src="01/projektstruktur/commit-gui-editor.jpg" />
        <figcaption>
            Wenn sich ein normaler Editor √∂ffnet, gibt die Commit-Nachricht ein, speichere und schlie√üe den Editor.
        </figcaption>
    </figure>
    <figure>
        <img src="01/projektstruktur/commit-nano.jpg" />
        <figcaption>
            Wenn in der Konsole folgendes erscheint, ist das der Editor
            <a href="https://de.wikipedia.org/wiki/Nano_(Texteditor)" target="_blank">nano</a>.
            Gib deine Meldung ein und dr√ºcke <kbd>Strg</kbd>+<kbd>O</kbd> zum Sichern und dann
            <kbd>Strg</kbd>+<kbd>X</kbd> zum Beenden.
        </figcaption>
    </figure>
    <figure>
        <img src="01/projektstruktur/commit-vi.jpg" />
        <figcaption>
            Das ist <a href="https://de.wikipedia.org/wiki/Vi" target="_blank">Vi</a>.
            Dr√ºcke erst <kbd>i</kbd>, um den <span class="scr">Insert Mode</span> zu gelangen,
            und gib dann deine Commit-Nachricht ein. Anschlie√üend wechsle mit <kbd>ESC</kbd>,
            <kbd>:</kbd> wieder zur√ºck in den Befehlsmodus und beende den
            Editor mit dem Befehl <span class="cmd">wq</span>.
        </figcaption>
    </figure>
    <p>
        Am Ende sollte <span class="cmd">git</span> folgende Zeilen ausgeben:
    </p>
    <figure>
        <img src="01/projektstruktur/git-init.png" />
        <figcaption>Initialisierung des git-Repositories</figcaption>
    </figure>

    <p>
        Dadurch kannst du jetzt aber nur lokal arbeiten. Dein Quellcode wird noch nicht mit anderen
        Entwicklern geteilt. Hierf√ºr musst du das Repository auf einen speziellen git-Server schieben,
        auf den alle Projektmitglieder Zugriff haben. √úblicherweise wird hierf√ºr einfach
        <a href="https://github.com/" target="_blank">GitHub</a> genutzt,
        obwohl es auch eine ganze Reihe genauso leistungsf√§higer Webanwendungen zum selbst hosten gibt.
        Melde dich daher nun auf GitHub an und lege dort ebenfalls ein neues Repository an. Achte dabei
        aber unbedingt darauf, dass das Repository wirklich leer ist und noch keine Dateien beinhalten darf.
        Wenn folgende Ansicht erscheint, hast du alles richtig gemacht:
    </p>
    <figure>
        <img src="01/projektstruktur/github-leer.png" />
        <figcaption>Alles in Ordnung. Das Repository auf GitHub ist komplett leer.</figcaption>
    </figure>
    <p>
        Die Befehle, die du nun im Konsolenfenster eingeben musst (du hast es hoffentlich noch nicht geschlossen),
        stehen unter der √úberschrift <span class="scr">‚Ä¶ or push an existing repository from the command line</span>.
        Kopiere sie in die Zwischenablage und f√ºhre sie in der Konsole aus. Anschlie√üend sollten deine Dateien
        auch auf GitHub sichtbar sein.
    </p>
    <figure>
        <img src="01/projektstruktur/git-push.png" />
        <figcaption>Bildschirmausgabe beim Verbinden des lokalen git-Repositories mit GitHub</figcaption>
    </figure>
    <figure>
        <img src="01/projektstruktur/github-voll.png" />
        <figcaption>Hurra! Alle Dateien werden angezeigt.</figcaption>
    </figure>

    <h3>Konfiguration von node.js</h3>
    <p>
        Da du das Konsolenfenster ohnehin schon offen hast, wollen wir an dieser Stelle gleich noch
        <a href="https://nodejs.org/" target="_blank">node.js</a> bzw. den darin enthaltenen
        <a href="https://www.npmjs.com/" target="_blank">Node Package Manager</a>
        npm in Betrieb nehmen. Zwar ist node.js vielen nur als ‚ÄûJavaScript f√ºr den Server‚Äù ein Begriff,
        in Wirklichkeit kann es aber auch ganz hervorragend in der Frontendentwicklung eingesetzt werden.
        Denn der Node Package Manager macht es geradezu zum Kinderspiel, externe Bibliotheken und zus√§tzliche
        Werkzeuge in unser Projekt einzubinden, weshalb sich npm inzwischen auch gegen√ºber allen anderen,
        √§hnlichen Werkzeugen als Standard durchsetzen konnte.
    </p>
    <p>
        Die Einrichtung von npm ist zum Gl√ºck genauso einfach wie seine Benutzung. Du musst lediglich den Befehl
        <span class="cmd">npm init</span> in die Konsole eingeben und ein paar grundlegende Fragen beantworten.
        Die meisten Vorschlagswerte kannst du dabei auch einfach √ºbernehmen. Der gesamte Ablauf sollte ungef√§hr
        so aussehen:
    </p>
    <figure>
        <img src="01/projektstruktur/npm-init.png" />
        <figcaption>Initialisierung von node.js und npm</figcaption>
    </figure>
    <p>
        Wie das Kommando bereits ank√ºndigt, wird dadurch eine neue Datei namens <span class="fn">package.json</span>
        angelegt. Technisch gesehen macht sie unser Projekt zu einem node.js-Paket, das sogar auf
        <a href="https://www.npmjs.com/" target="_blank">npmjs.com</a> hochgeladen werden k√∂nnte. F√ºr reine
        Browser-Anwendungen ist dies jedoch vollkommen unerheblich. Alles was hier z√§hlt ist, dass wir dadurch
        npm zur Verwaltung aller externen Abh√§ngigkeiten nutzen k√∂nnen.
    </p>
    <p>
        Im Zusammenhang mit git besitzt npm jedoch auch einen kleinen Nachteil: Es legt sehr viele aus dem Internet
        heruntergeladene Dateien im Projektverzeichnis ab, die wertvollen Platz innerhalb des git-Repositories belegen.
        Da diese Dateien aber jederzeit wieder mit npm nachgeladen werden k√∂nnen, ist es weder erforderlich noch wirklich
        sinnvoll, diese Dateien mit git zu verwalten. Bevor du also irgendetwas weiteres mit npm und git unternimmst,
        lege erst eine Datei namens <span class="fn">.gitignore</span> mit folgendem Inhalt im Projektverzeichnis an:
    </p>
    <pre data-gobble>
        <code data-gobble class="html">
            .cache/**
            /dist/**
            /node_modules/**
        </code>
    </pre>
    <p>
        Anschlie√üend f√ºhre einen neuen Add-Commit-Push-Zyklus aus, um deine √Ñnderungen zu versionieren:
    </p>
    <ol>
        <li>
            <span class="cmd">git add . </span> (beachte den Punkt am Ende des Befehls)
        </li>
        <li>
            <span class="cmd">git commit</span>
        </li>
        <li>
            <span class="cmd">git push</span>
        </li>
    </ol>
    <p>
        Das Projektverzeichnis steht nun bereit und wartet darauf, von uns mit Quellcode gef√ºllt zu werden.
    </p>
</section>

<!-- ‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì -->
<!-- Alles sch√∂n verpackt mit Parcel -->
<!-- ‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì -->
<section data-title="Alles sch√∂n verpackt mit Parcel">
    <h3>H√§ufige Aufgaben automatisieren</h3>
    <p>
        Wie wir bisher in der Vorlesung gesehen haben, braucht es im Grunde genommen keinerlei
        Werkzeuge, um mit der Entwicklung von Webanwendungen zu beginnen: Ein einfacher Texteditor
        und ein Verzeichnis zur Ablage der Quellcodes reichen f√ºr kleine Projekte bereits v√∂llig aus.
        Je gr√∂√üer oder professioneller ein Projekt jedoch wird, desto mehr st√∂√üt dieser einfache
        Ansatz an seine Grenzen, da einfach viel zu viele Aufgaben immer wieder von Hand erledigt
        werden m√ºssen:
    </p>
    <ul>
        <li>
            Externe Bibliotheken m√ºssen bei jeder Aktualisierung manuell heruntergeladen und innerhalb
            des Projektverzeichnisses abgelegt werden.
        </li>
        <li>
            Pr√ºfwerkzeuge, welche die Qualit√§t des Codes √ºberpr√ºfen sollen, m√ºssen in regelm√§√üigen Abst√§nden
            ausgef√ºhrt werden, bevor eine neue Version der Anwendung online gestellt wird.
        </li>
        <li>
            Komplexe Stylesheets m√ºssen erst durch so genannte CSS-Preprozessoren bearbeitet werden, um die
            tats√§chlichen CSS-Dateien zu erzeugen.
        </li>
        <li>
            Falls eine Sprache wie TypeScript oder eine besonders neue JavaScript-Version, die noch
            nicht von allen Browsern unterst√ºtzt wird, zum Einsatz kommt, m√ºssen die entsprechenden
            Quellcdes erst durch einen Transpiler in regul√§res JavaScript √ºbersetzt werden.
        </li>
        <li>
            HTML-, CSS- und JavaScript-Codes m√ºssen durch Minifier unleserlich gemacht und um alle
            √ºberfl√ºssigen Bytes abgespeckt werden.
        </li>
        <li>
            Bilder m√ºssen in ihrer Gr√∂√üe reduziert und f√ºr schnelle Ladezeiten optimiert werden.
        </li>
    </ul>
    <p>
        Seit geraumer Zeit hat sich daher die Verwendung so genannter ‚ÄûTask Runner‚Äù wie Grunt
        oder Gulp durchgesetzt, die all diese Schritte wie eine Fertigungsstra√üe automatisieren.
        Es handelt sich dabei im Grunde genommen um das JavaScript-Pendant zu den Build-Werkzeugen
        anderer Sprachen, wie zum Beispiel Ant und Maven f√ºr Java oder Make und Meson f√ºr C/C++.
        Denn sie erm√∂glichen es uns, ganz exakte Abl√§ufe zu definieren und dabei festzulegen, bei
        Eintreten welcher Bedingung welche Aktion auszuf√ºhren ist. Leider sind sie deshalb aber
        auch nicht unbedingt einsteigerfreundlich, da sie erst relativ aufwendig konfiguriert werden
        m√ºssen, bevor sie √ºberhaupt etwas sinnvolles tun.
    </p>

    <h3>JavaScript gestern, heute, morgen</h3>
    <p>
        Aufgrund seiner langen Historie als einfache Skriptsprache f√ºr das Web hat JavaScript einen
        entscheidenen Nachteil, der bei der Entwicklung gro√üer Anwendungen wirklich ins Gewicht f√§llt:
        Es gibt keine saubere Trennung zwischen den Quellcodedateien. Oder anders ausgedr√ºckt:
        JavaScript hat (oder besser gesagt hatte) kein Modulsystem, wodurch es m√∂glich w√§re, den
        Inhalt einer Quellcodedatei vor allen anderen zu verstecken. H√§ufig konnte es daher zu
        Namenskonflikten kommen, wenn in einem Projekt zwei externe Bibliotheken zum Einsatz
        kamen, die beide denselben Namen f√ºr eine globale Variable, eine Funktion oder eine Klasse
        verwendeten.
    </p>
    <p>
        Erst in j√ºngerer Zeit wurde dieses Problem durch die Einf√ºhrung eines Modulsystems f√ºr
        JavaScript im Sprachstandard ber√ºcksichtigt. Dadurch ist gew√§hrleistet, dass alle Inhalte
        einer Quellcodedatei nur innerhalb derselben Datei sichtbar sind und nicht aus anderen
        Dateien heraus aufgerufen werden k√∂nnen. Nur die mit der Anweisung <span class="cmd">export</span>
        gekennzeichneten Inhalte k√∂nnen in den anderen Dateien mit <span class="cmd">import</span>
        wieder eingelesen werden. Der Nachteil davon ist jedoch, dass dies Stand 09/2018 noch von
        keinem einzigen Browser unterst√ºtzt wird.
    </p>
    <p>
        ‚ÄûWeb Application Bundler‚Äù bieten hier eine L√∂sung, da sie die fehlende Funktionalit√§t
        im Browser nachr√ºsten und somit das JavaScript-Modulsystem nutzbar machen. Gleichzeitig
        erlauben sie es uns, mit npm nachinstallierte Bibliotheken direkt in unserem Quellcode
        zu verwenden, ohne hierf√ºr irgendwelche Dateien umkopieren zu m√ºssen. Und last but not
        least k√∂nnen sie alles, was ‚ÄûTask Runner‚Äù auch k√∂nnen, inklusive der Verzweiflung und
        dem Frust, der mit ihnen verbunden ist, da die meisten ‚ÄûWeb Application Bundler‚Äù mindestens
        genauso umst√§ndlich eingerichtet werden m√ºssen.
    </p>

    <h3>B√ºhne frei f√ºr Parcel</h3>
    <p>
        An genau diesem Punkt setzt <a href="https://parceljs.org/" target="_blank">Parcel</a> an,
        da es sich dabei um einen ausgewachsenen ‚ÄûWeb Application Bundler‚Äù handelt, der komplett
        ohne Konfiguration auskommt. Parcel setzt stattdessen einfach voraus, dass unser Projekt
        den g√§ngigen Konventionen entsprechend strukturiert ist und dass wir genau das Gleiche
        wollen, wie die meisten Webentwickler vor und nach uns auch. Dadurch kann es vorkommen,
        dass die eingebauten Regeln von Parcel nicht immer genau das sind, was f√ºr ein Projekt
        ben√∂tigt wird. K√∂nnen wir uns jedoch an die Vorgaben von Parcel anpassen, bietet es uns
        eine elegante und einfache M√∂glichkeit, all die genannten Vorteile in unseren Projekten
        auszukosten.
    </p>
    <p>
        Um unserem Projekt also gleich von Anfang an den n√∂tigen, professionellen Anstrich zu
        verleihen, wollen wir Parcel sogleich in das Projekt integrieren. Du musst daher wieder
        eine Konsole √∂ffnen und in darin in das Projektverzeichnis verzweigen. Anschlie√üend
        f√ºhre den folgenden Befehl aus:
    </p>
    <p class="cmd">
        npm add --save-dev parcel-bundler
    </p>
    <p>
        Das Ergebnis sollte wie folgt aussehen:
    </p>
    <figure>
        <img src="01/parcel/npm-add.png" />
        <figcaption>Installation von Parcel</figcaption>
    </figure>
    <p>
        Dadurch wird folgende Maschinerie in Gang gesetzt:
    </p>
    <ol>
        <li>
            Das Paket <span class="scr">parcel-bundler</span> wird in der Datei <span class="fn">package.json</span>
            als Abh√§ngigkeit f√ºr die Entwicklung¬π aufgenommen.
        </li>
        <li>
            Anschlie√üend wird das Paket <span class="scr">parcel-bundler</span> zusammen mit all seinen eigenen
            Abh√§ngigkeiten heruntergeladen und innerhalb des Unterverzeichnisses <span class="fn">node_modules</span>
            entpackt.
        </li>
    </ol>
    <p>
        ¬π
        <small>
            npm unterscheidet zwei Arten von Abh√§ngigkeiten: Eine normale Abh√§ngigkeit besagt, dass ein bestimmtes
            Paket zur Laufzeit ben√∂tigt wird, damit unser Code ausgef√ºhrt werden kann. Eine Entwicklungsabh√§ngigkeit
            besagt hingegen, dass das Paket nur w√§hrend der Entwicklung, nicht aber sp√§ter bei der Ausf√ºhrung ben√∂tigt
            wird. Diese Unterscheidung macht allerdings nur dann Sinn, wenn du Serveranwendungen mit node.js entwickelst.
            In unserem Fall kannst du davon ausgehen, dass es nur Entwicklungsabh√§ngigkeiten gibt, selbst dann, wenn du
            eine zur Laufzeit ben√∂tigte Bibliothek hinzuf√ºgen willst. Denn ohne einen Bundler, der die Bibliothek mit
            unserem Quellcode verkn√ºpft, l√§sst sie sich nur sehr umst√§ndlich nutzen.
        </small>
    </p>

    <h3>Was die anderen Teammitglieder sp√§ter tun m√ºssen</h3>
    <p>
        Im vorherigen Kapitel haben wir durch die <span class="fn">.gitignore</span>-Datei sichergestellt, dass
        der Inhalt von <span class="fn">node_modules</span> nicht mit git verwaltet wird. Dies ist auch richtig
        so, bedeutet aber auch, dass Parcel bei den anderen Teammitgliedern nicht automatisch installiert wird,
        sobald sie ihre lokalen Quellcodes mit git aktualisieren. Stattdessen m√ºssen die anderen Teammitglieder
        folgenden Befehl ausf√ºhren, damit npm die Datei <span class="fn">package.json</span> nach neuen Abh√§ngigkeiten
        untersucht und diese nachinstalliert:
    </p>
    <p class="cmd">
        npm install
    </p>

    <h3>Eine winzig kleine HTML-Datei hinzuf√ºgen</h3>
    <p>
        Damit wir die Wirkungsweise von Parcel beobachten k√∂nnen, ben√∂tigen wir eine HTML-Datei in unserem
        Projekt, die gleichzeitig auch den Einstiegspunkt f√ºr unsere App darstellt. Hierf√ºr ben√∂tigen wir
        ein Unterverzeichnis namens <span class="fn">src</span>, in dem wir eine neue Datei mit dem Namen
        <span class="fn">index.html</span> anlegen. Andernfalls kann Parcel die Datei sp√§ter nicht finden.
        Die Verzeichnisstruktur muss also so aussehen:
    </p>
    <figure>
        <img src="01/parcel/src-index.png" />
        <figcaption>
            Alle Quellcodes m√ºssen im Unterverzeichnis <span class="fn">src</span> abgelegt werden.
        </figcaption>
    </figure>
    <p>
        F√ºr den Anfang gen√ºgt uns dabei eine einfache ‚ÄûHallo, Welt‚Äù-Seite:
    </p>
    <pre data-gobble>
        <code class="html" data-gobble>
            &lt;!DOCTYPE html&gt;
            &lt;html&gt;
                &lt;head&gt;
                    &lt;meta charset="utf-8" /&gt;
                    &lt;title&gt;My Songbook&lt;/title&gt;
                &lt;/head&gt;
                &lt;body&gt;
                    &lt;h1&gt;Hallo, Welt!&lt;/h1&gt;
                &lt;/body&gt;
            &lt;/html&gt;
        </code>
    </pre>

    <h3>npm-Skripte zum Aufruf von Parcel definieren</h3>
    <p>
        Leider ist Parcel, wenn es auf diese Weise installiert wird, ein wenig umst√§ndlich aufzurufen,
        da seine Startdatei im Unterverzeichnis <span class="fn">node_modules/.bin</span> versteckt ist.
        npm bietet uns jedoch die M√∂glichkeit, in der Datei <span class="fn">package.json</span> so
        genannte Skripte zu definieren, die nicht nur den Aufruf vereinfachen, sondern uns auch gleich die
        M√∂glichkeit geben, mehrere Befehle hintereinander auszuf√ºhren. √ñffne daher die
        <span class="fn">package.json</span> in Atom und entferne folgende Zeilen daraus:
    </p>
    <pre data-gobble>
        <code class="json" data-gobble>
            "scripts": {
              "test": "echo \"Error: no test specified\" && exit 1"
            },
        </code>
    </pre>
    <p>
        Stattdessen f√ºge an der gleichen Stelle folgende, neue Zeilen ein:
    </p>
    <pre data-gobble>
        <code class="json" data-gobble>
            "scripts": {
              "clean": "node scripts/clean.js",
              "build": "npm run clean; parcel build src/*.html --public-url . --detailed-report --experimental-scope-hoisting",
              "watch": "npm run clean; parcel watch src/*.html --public-url . --detailed-report --experimental-scope-hoisting",
              "start": "parcel src/index.html --open"
            },
        </code>
    </pre>
    <p>
        Anschlie√üend lege ein neues Unterverzeichnis mit dem Namen <span class="fn">scripts</span>
        an und lege dort die Datei <span class="fn">clean.js</span> ab, die du dir aus dem
        <a href="https://raw.githubusercontent.com/DennisSchulmeister/dhbwka-wwi-webprog-my-songbook/master/scripts/clean.js" target="_blank">
            Vorlageprojekt auf GitHub
        </a>
        herunterladen kannst. Zus√§tzlich gib noch folgenden Befehl ein, um das von dieser Datei
        ben√∂tigte Paket <span class="cmd">shelljs</span> zu installieren:
    </p>
    <p class="cmd">
        npm add --save-dev shelljs
    </p>
    <p>
        Letztlich muss das Projektverzeichnis am Ende so aussehen:
    </p>
    <figure>
        <img src="01/parcel/scripts-clean.png" />
        <figcaption>
            Neue Projektstruktur nach dem Hinzuf√ºgen von <span class="fn">scripts/clean.js</span>
        </figcaption>
    </figure>

    <h3>Unsere erste Probefahrt mit Parcel</h3>
    <p>
        Durch die eben ausgef√ºhrten Schritte stehen dir nun folgende, neue Kommandos zur Verf√ºgung:
    </p>
    <table>
        <tr>
            <td class="cmd" style="width: 9em;">
                npm run start
            </td>
            <td>
                Startet einen lokalen Webserver und √∂ffnet die App anschlie√üend.
            </td>
        </tr>
        <tr>
            <td class="cmd">
                npm run build
            </td>
            <td>
                Baut eine fertige Version der App, die auf einem echten Webserver deployed werden kann.
                Die Dateien werden hierf√ºr im Unterverzeichnis <span class="fn">dist</span> abgelegt.
            </td>
        </tr>
        <tr>
            <td class="cmd">
                npm run watch
            </td>
            <td>
                Aktualisiert die Dateien im Verzeichnis <span class="fn">dist</span> automatisch
                nach jeder Quellcode√§nderung, ohne jedoch einen lokalen Webserver zu starten.
            </td>
        </tr>
        <tr>
            <td class="cmd">
                npm run clean
            </td>
            <td>
                R√§umt das <span class="fn">dist</span>-Verzeichnis auf und l√∂scht alle Inhalte darin.
            </td>
        </tr>
    </table>
    <p>
        F√ºhrst du an dieser Stelle nun den Befehl <span class="cmd">npm run build</span> aus,
        siehst du, dass Parcel ein neues Verzeichnis mit dem Namen <span class="fn">dist</span>
        anlegt und unsere <span class="fn">index.html</span>-Datei darin ablegt. F√ºr den Anfang
        ist das noch wenig spektakul√§r. Es zeigt aber, dass Parcel richtig arbeitet und wir sp√§ter
        in den Genuss aller oben genannter Vorteile kommen k√∂nnen.
    </p>
    <p>
        Als n√§chstes gib den Befehl <span class="cmd">npm run start</span> ein, um unsere
        Baby-App zu starten. Nach einer kurzen Zeit sollte sich ein neues Browserfenster
        mit dem guten alten ‚ÄûHallo, Welt!‚Äù √∂ffnen. Das ist jetzt schon interessanter. Richtig
        toll wird es aber erst, wenn du eine √Ñnderung an der HTML-Datei vornimmst, ohne die
        App im Browser zu schlie√üen. Du wirst sehen, dass sich die Seite nach jeder √Ñnderung
        automatisch neul√§dt, so dass du beim Entwickeln wirklich immer die aktuellste Version
        vor dir hast.
    </p>
    <figure>
        <img src="01/parcel/hallo-welt.png" class="border" />
        <figcaption>Schlicht und ergreifend. Die ersten Worte unsere neuen App.</figcaption>
    </figure>
    <p>
        Zum Schluss gib noch <span class="cmd">npm run clean</span> ein, um alle Inhalte
        aus dem <span class="fn">dist</span>-Verzeichnis wegzuputzen. Aber keine Sorge.
        Durch <span class="fn">.gitignore</span> haben wir ohnehin daf√ºr gesorgt, dass sie
        nicht unn√∂tigerweise im git-Repository landen.
    </p>

    <h3>√Ä propos git</h3>
    <p>
        An dieser Stelle wird es mal wieder Zeit, den aktuellen Stand in git einzuchecken
        und auf GitHub bereitzustellen. Der folgende Dreisatz erledigt das f√ºr dich:
    </p>
    <p>
        <span class="cmd">git add . </span> (wie immer achte auf den Punkt am Ende des Befehls) <br />
        <span class="cmd">git commit</span> <br />
        <span class="cmd">git push</span>
    </p>
</section>

<!-- ‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì -->
<!-- Ein Modul kommt selten allein -->
<!-- ‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì -->
<section data-title="Ein Modul kommt selten allein">
    <p>
        Wie eben schon ausgef√ºhrt  und wie wir bald sehen werden, bringt die Nutzung eines Bundlers
        viele Vorteile mit sich. Insbesondere die M√∂glichkeit, den Quellcode einer App in isolierte
        Module einteilen zu k√∂nnen, die sich nicht gegenseitig in die Quere kommen, macht den Einsatz
        bereits lohnenswert. Denn normalerweise haben wir in JavaScript ein Problem, wenn wir in
        zwei Dateien dieselben globalen Bezeichner verwenden, weil dann die Definition aus der zuletzt
        ausgewerteten Datei die Definition aus der anderen Datei √ºberschreibt. Dank des Bundlers, der aus
        jeder JavaScript-Datei automatisch ein Modul macht, geh√∂ren diese Probleme jedoch der Vergangenheit
        an und wir k√∂nnen unsere Funktionen (und alles andere, was uns sonst noch so einf√§llt) einfach
        nennen, wie wir wollen. Legen wir daher zwei Dateien an, die wir ohnehin bald ben√∂tigen, um das
        gleich mal auszuprobieren:
    </p>
    <ul>
        <li>
            <span class="fn">src/index.js</span>: JavaScript-Code zum Starten der Anwendung
        </li>
        <li>
            <span class="fn">src/app.js</span>: Hauptklasse unserer Anwendung
        </li>
    </ul>
    <p>
        F√ºr den Anfang reicht es, wenn du zwei leere Dateien anlegst. Bevor wir uns ihrem Inhalt
        zuwenden, wollen wir sie erst in die <span class="fn">src/index.html</span> einbinden.
        In einer normalen Webseite ‚Äì ohne Unterst√ºtzung f√ºr JavaScript-Module ‚Äì m√ºssten wir hierf√ºr
        den <span class="cmd">&lt;head&gt;</span> wie folgt erweitern:
    </p>
    <pre data-gobble>
        <code class="html" data-gobble>
            &lt;head&gt;
                ‚Ä¶
                &lt;script src="index.js"&gt;&lt;/script&gt;
                &lt;script src="app.js"&gt;&lt;/script&gt;
            &lt;/head&gt;
        </code>
    </pre>
    <p>
        Dadurch k√∂nnten an jeder beliebigen Stelle in jeder beliebigen HTML- oder JavaScript-Datei die in diesen
        beiden Dateien definierten Klassen, Funktionen und globalen Variablen verwenden. Da wir jetzt aber einen
        Bundler verwenden, funktioniert das so nicht mehr. Die Inhalte der einen Datei k√∂nnen nicht in der anderen
        verwendet werden. Zumindest nicht ohne die beiden Anweisungen <span class="cmd">export</span> und
        <span class="cmd">import</span> zu verwenden. Wir wollen daher die <span class="fn">src/app.js</span>
        wieder aus dem HTML ausbauen, so dass nur noch folgendes √ºbrig bleibt:
    </p>
    <pre data-gobble>
        <code class="html" data-gobble>
            &lt;head&gt;
                ‚Ä¶
                &lt;script src="index.js"&gt;&lt;/script&gt;
            &lt;/head&gt;
        </code>
    </pre>
    <p>
        Anschlie√üend legen wir in der <span class="fn">src/app.js</span> unsere neue Hauptklasse an. An dieser
        Stelle noch ohne viel Logik, daf√ºr aber von Anfang an mit ordentlichen Kommentaren:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            "use strict";

            /**
             * Hauptklasse der Anwendung. K√ºmmert sich darum, die Anwendung auszuf√ºhren
             * und die angeforderten Bildschirmseiten anzuzeigen.
             */
            class App {
                /**
                 * Konstruktor.
                 */
                constructor() {
                }

                /**
                 * Ab hier beginnt die Anwendung zu laufen.
                 */
                start() {
                    console.log("Die Klasse App sagt Hallo!");
                }
            }
        </code>
    </pre>
    <p>
        In der <span class="fn">src/index.js</span> wollen wir, sobald das Document Object Model
        zur Verf√ºgung steht, ein Objekt von der Klasse erzeugen und ihre <code>start()</code>-Methode
        ausf√ºhren. Unser erster Versuch schl√§gt jedoch fehl:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            "use strict";

            // Erst loslaufen, wenn das Document Object Modul bereit ist
            window.addEventListener("load", () => {
                // Anwendung starten
                let app = new App();
                app.start();
            });
        </code>
    </pre>
    <p>
        Um dies zu sehen, musst du zun√§chst mit folgendem Befehl den Entwicklungsserver
        starten:
    </p>
    <p class="cmd">
        npm run start
    </p>
    <p>
        Dadurch √∂ffnet sich die Adresse <span class="scr">localhost:1234</span>
        im Browser, wo du dann die Entwicklungswerkzeuge und dort die
        JavaScript-Konsole √∂ffnen musst. Anstelle der freundlichen Begr√º√üung
        <span class="scr">Die Klasse App sagt Hallo!</span> erscheint
        dann (wie erwartet) folgender Fehler:
    </p>
    <figure>
        <img src="01/umdenken/reference-error.png" class="border"/>
        <figcaption>
            Die Klasse <span class="cmd">App</span> wird in der Datei
            <span class="fn">src/index.js</span> nicht gefunden, da sie
            hier nicht definiert wurde.
        </figcaption>
    </figure>
    <p>
        Die L√∂sung des Problems ist zum Gl√ºck ganz einfach. Zun√§chst m√ºssen
        wir die Klasse <span class="cmd">App</span> in der Datei
        <span class="fn">src/app.js</span> exportieren, indem wir ganz am Ende
        folgende Zeile hinzuf√ºgen:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            export default App;
        </code>
    </pre>
    <p>
        In der Datei <span class="fn">src/index.js</span> k√∂nnen wir sie dann wie
        folgt importieren:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            "use strict";

            import App from "./app.js";
            ‚Ä¶
        </code>
    </pre>
    <p>
        Und schon funktioniert alles, wie es soll.
    </p>
    <figure>
        <img src="01/umdenken/app-start-okay.png" class="border"/>
        <figcaption>
            Juhu, es funktioniert!
        </figcaption>
    </figure>
    <p>
        Hier zur Sicherheit nochmal beide Dateien in G√§nze. Zun√§chst die
        Datei <span class="fn">src/app.js</span>:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            "use strict";

            /**
             * Hauptklasse der Anwendung. K√ºmmert sich darum, die Anwendung auszuf√ºhren
             * und die angeforderten Bildschirmseiten anzuzeigen.
             */
            class App {
                /**
                 * Konstruktor.
                 */
                constructor() {
                }

                /**
                 * Ab hier beginnt die Anwendung zu laufen.
                 */
                start() {
                    console.log("Die Klasse App sagt Hallo!");
                }
            }

            export default App;
        </code>
    </pre>
    <p>
        Und hier die Datei <span class="fn">src/index.js</span>:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            "use strict";

            import App from "./app.js";

            // Erst loslaufen, wenn das Document Object Modul bereit ist
            window.addEventListener("load", () => {
                // Anwendung starten
                let app = new App();
                app.start();
            });
        </code>
    </pre>
</section>

<!-- ‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì -->
<!-- Je Modul ein Stylesheet -->
<!-- ‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì -->
<section data-title="Je Modul ein Stylesheet">
    <p>
        Getreu dem Motto ‚Äûjedem Kind sein Luftballon‚Äù üéà wollen wir als n√§chstes
        jedem unserer JavaScript-Module (sofern sie etwas mit dem sichtbaren
        Inhalt der App zu tun haben) ein eigenes Stylesheet spendieren:
    </p>
    <ul>
        <li>
            <span class="fn">src/index.css</span>: √úbergreifende CSS-Anweisungen
        </li>
        <li>
            <span class="fn">src/app.jss</span>: Spezifische Anweisungen f√ºr den Hauptbereich
        </li>
    </ul>
    <p>
        F√ºr den Anfang sollen sie folgenden Inhalt haben. Hier die Datei
        <span class="fn">src/index.css</span>:
    </p>
    <pre data-gobble>
        <code class="css" data-gobble>
            /*
             * Dieses Stylesheet enth√§lt nur allgemeine Anweisungen, die sich auf die
             * gesamte App auswirken. Hier d√ºrfen keine √Ñnderungen vorgenommen werden,
             * die sich nur auf bestimmte Bereiche der Anwendung auswirken sollen.
             *
             * Damit @import funktioniert, muss die Anweisung vor allen anderen
             * CSS-Anweisungen stehen. Dieses Stylesheet muss daher auch vor allen
             * anderen importiert werden.
             */
            @import url('https://fonts.googleapis.com/css?family=Roboto');

            html, body {
                margin: 0;
            }

            body {
                font-family: 'Roboto', sans-serif;
                font-size: 12pt;

                background-color: rgb(212, 227, 237);
            }
        </code>
    </pre>
    <p>
        Und dann die Datei <span class="fn">src/app.css</span>:
    </p>
    <pre data-gobble>
        <code class="css" data-gobble>
            /*
             * Dieses Stylesheet darf nur Selektoren beinhalten, die mit #app beginnen.
             * Denn wir wollen nicht, dass hier Eigenschaften aus anderen Bereichen der
             * Anwendung √ºberschrieben werden.
             */
            #app {}
        </code>
    </pre>
    <p>
        Wie du siehst, haben die beiden Stylesheets eine genau definierte
        Aufgabe. Und wie du siehst, binden wir hier eine Schriftart von
        <a href="https://fonts.google.com" target="_blank">Google Fonts</a>
        ein. Doch wie bauen wir sie in die App ein? Normalerweise ‚Äì ohne
        einen Bundler ‚Äì durch folgende √Ñnderung am HTML-Code:
    </p>
    <pre data-gobble>
        <code class="html" data-gobble>
            &lt;head&gt;
                ‚Ä¶
                &lt;link rel="stylesheet" href="index.css" /&gt;
                &lt;link rel="stylesheet" href="app.css" /&gt;
            &lt;/head&gt;
        </code>
    </pre>
    <p>
        √úberraschenderweise ist das in Zusammenhang mit einem Bundler jedoch kein
        gutes Vorgehen. Zwar kommt Parcel damit genauso gut wie mit der nachfolgenden
        L√∂sung zurecht, es gibt jedoch Bundler, die die Stylesheets in diesem Fall
        ignorieren w√ºrden. Stattdessen hat sich eingeb√ºrgert, bei Verwendung eines
        Bundlers die Stylesheets im JavaScript-Code zu importieren, genauso als w√§ren sie
        selbst JavaScript-Dateien, wie zum Beispiel hier In der Datei
        <span class="fn">src/index.js</span>:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            import stylesheet from "./index.css";
        </code>
    </pre>
    <p>
        Der Bezeichner <span class="cmd">stylesheet</span> spielt hierbei √ºbrigens
        keine Rolle. Wir brauchen ihn nur, da wir bei jedem Import einen Bezeichner
        angeben m√ºssen. Wichtig ist nur der Dateiname, der relativ zur importierenden
        JavaScript-Datei angegeben werden und mit <span class="cmd">./</span> beginnen
        muss. In der Datei <span class="fn">src/app.js</span> sieht derselbe Import
        deshalb so aus:
    </p>
    <pre data-gobble>
        <code class="javascript" data-gobble>
            import stylesheet from "./app.css";
        </code>
    </pre>
    <figure>
        <img src="01/umdenken/import-style-index.png" />
        <figcaption>
            Import der Stylesheet-Datei <span class="fn">src/index.css</span>
        </figcaption>
    </figure>
    <figure>
        <img src="01/umdenken/import-style-app.png" />
        <figcaption>
            Import der Stylesheet-Datei <span class="fn">src/app.css</span>
        </figcaption>
    </figure>
    <p>
        Unsere App sollte dadurch nun wie folgt aussehen:
    </p>
    <figure>
        <img src="01/umdenken/app-mit-stylesheets.png" class="border" />
        <figcaption>Die Stylesheets wurden korrekt geladen, dieses mal aber im JavaScript und nicht im HTML.</figcaption>
    </figure>
    <p>
        Ein weiterer Vorteil dieser Vorgehensweise ist, dass es dadurch sp√§ter leichter
        wird, die Anwendung zu einer Progressive App umzubauen, bei der nicht einfach
        am Anfang der gesamte Code vom Server geladen wird (der ja durchaus sehr umfangreich
        werden kann), sondern immer nur der Teil, der f√ºr die Anzeige des aktuellen Bereichs
        gerade ben√∂tigt wird. Darauf kommen wir gegen Ende des Tutorials nochmal zur√ºck.
    </p>
</section>
